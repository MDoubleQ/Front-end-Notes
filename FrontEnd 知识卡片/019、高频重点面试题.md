# JavaScript、ES6 高频重点面试题

2023 最新，Web 前端重点面试题

汇总了 2023 年各互联网大厂以及中小型创业公司 JavaScript+ES6 相关的最新高频面试题

- 有关会陆续更新，为确保每一个面试题的都是最佳实践和有竞争力的回答，需要一点点时间 ！
- 面试题是检验自己学习成果和查缺补漏的最好方式之一，同时也是了解企业对求职者技能要求的风向标 。
- 希望正在学习或找工作的同学少走弯路 ！

有兴趣的同学，可在评论区尝试着练习先给出自己的答案，我会给出建议和意见，每天进步一点点 ！一起加油 ^_^

## 数据类型和变量

1、JS 有哪些数据类型，如何判断这些数据类型 ？（腾讯、阿里、滴滴、货拉拉、百度、招银、字节）

2、number 类型表示整数的最大范围（字节）

3、什么是变量提升 ？（腾讯、网易、小米）

4、typeof(NaN) 返回什么 ？（滴滴）

5、 typeof(null) 为什么返回的是 'object'（滴滴）

6、`null` 和 `undefined`的区别 ？（同花顺、滴滴）

7、console.log([] == `false`）的输出结果（同花顺）

8、== 和 === 的区别？（滴滴）

9、const、let、var 区别（叠纸、字节）

10、 const 定义的值一定是不能改变的吗？（滴滴）

11、 const 声明了数组，还能 push 元素吗，为什么？（阿里）

12、JS 获取字符串的第 N 个字符（网易）

13、const 声明生成对象的时候，如何使其不可更改（字节）

14、 这两种方式的区别 ？typeof 判断（字节）

```js
const str1 = "abc";
const str2 = new String("abc");
```

> [数据类型和变量，详细 ..... 👆]

## 闭包 、作用域

1、说一下对闭包的理解 ?（快手、滴滴、58 篇、字节、小米、腾讯）

2、你在实际项目中遇到过哪些闭包的坑 ？（腾讯、字节）

3、闭包的好处，闭包里面的变量为什么不会被回收（网易）

4、 JS 作用域和作用域链（小米、腾讯、商汤）

5、 说一下 ES6 的块级作用域（百度）

6、有哪些类型的作用域（字节）

7、怎么理解 JS 静态作用域和动态作用域（小米）

8、 以下代码输出的结果是 ？（小米）

```js
Object.prototype.a = 10;
var s = Symbol();
var obj = {
    [s]: 20,
    b: 30
}
Object.defineProperty(obj, 'c', {
    enumerable: true，
    value: 40
})
for(let var in obj) {
    console.log(val)
}
```

> [闭包 、作用域，详细 ..... 👆]

## 原型链

1、说说你对原型链的理解 ？（腾讯、货拉拉、字节、招银、阿里、小米）

2、原型链的终点是什么？（货拉拉）

3、es6 class 怎么设置原型、静态、实例方法 ？（阿里）

4、 []的原型链是什么 ？（腾讯）

## 继承

1、JS 的继承有几种方式 ？是怎么实现的？（腾讯、百度）

2、在 JS 中如何实现多重继承 ？（腾讯）

3、对象继承的方法 （网易）

4、 怎么实现类的继承 （网易）

## 数组

1、你知道 JS 数组有哪些方法 ？（同花顺，阿里、自如、网易）

2、数组去重的方式有哪些？时间复杂度分别是多少？（同花顺、阿里、字节、百度）

3、将数组的`length`设置为 0，取第一个元素会返回什么？（同花顺）

4、 代码题 ：用尽可能多的方法实现数组扁平化（同花顺）

5、 什么是类数组 ？（百度）

6、类数组怎么转换为数组，说说你知道的所有方法 （阿里）

7、arguments 类数组，如何遍历类数组（滴滴）

8、 判断数组的方式（小米）

9、新创建一个数组空间（小米）

10、用过 ES6 哪些数组的方法，简述他们的特性（小米）

11、数组中的方法如何实现 break（滴滴）

12、比较常用的数组方法 map() reduce() find() findIndex() push() .... 哪些可以改变原数组，哪些不可以改变（滴滴）

13、JS 中 filter 方法如何使用 ？（小米）

## Promise 与 async await

1、JS 异步处理发展史（小红书、深信服）

2、同步任务和异步任务区别（百度）

3、了解异步调用栈吗（网易）

4、 使用 Promise 封装一下 ajax（叠纸、快手）

5、 JS 实现异步方法有哪些 ？（招银）

6、说一下 async 和 await 的原理，generator 用来做什么（百度、自如、字节、深信服、红书、腾讯）

7、有了 promise 为什么还需要 async/await（滴滴）

8、 promise 和 await async 有什么区别吗 ？（百度）

9、说一下你了解的 promise 的方法（百度，58 篇、广联达）

10、Promise 有哪些状态，状态之间互相转换（字节、知乎）

11、说说 Promise.race，Promise.all，如果 Promise.all 有一个异常了，其他 Promise 还会继续执行么？（字节、百度）

12、如何捕获 async await 的异常，如果不写 await promise 报错了你的 try catch 能捕获到错误么 （字节）

13、给定一个 promise 数组[p1,p2,p3...] （招银）

> ① 返回物理上第一个成功的 promise 的结果
>
> ② 若全部为失败，则返回物理上最后一个 promise 的结果

14、 Promise 实现过程和原理（字节、滴滴、百度）

15、 Promise 的一些静态方法说说它们作用和区别（百度）

16、promise.catch 后，后面的.then 还会执行吗（知乎）

17、如何为 Promise 添加一个方法（滴滴）

18、 async defer 的区别（腾讯）

19、以下代码输出的结果是 ？（字节）

```js
async function async1() {
  console.log("async1");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(() => {
  console.log("setTimeOut");
}, 0);
async1();
new Promise((resolve) => {
  console.log("promise");
  resolve();
}).then(() => {
  console.log("promise2");
});
console.log("script end");
```

## this 和 执行上下文

1、说一下 this 的指向有几种方式及使用场景 （58、小米、货拉拉）

2、说一下 JS 的执行上下文（字节）

3、函数和对象及其上下文存储在哪里（字节）

4、 this 指向问题（招银、字阿波波）

5、 箭头函数中 this 的指向（字节）

6、改变 this 指向的方法 call()、apply()、 bind()的作用和区别 ？（字节、网易）

7、箭头函数可以用 call 或者 apply 改变 this 指向吗 ？（百度）

8、 bind 如果第一次传入了 this，我再给 bind 传入一次 this，他执行的是哪个 this （字节）

9、以下代码输出什么 ？

```js
for (let i = 0; i < 10; i++) {
  this.a = i;
  this.$nextTick(() => {
    console.log(i);
    console.log(this.a);
  });
}
```

## ajax 与 axios

1、介绍下 ajax 及其原理（招银、创业公司）

2、说一下 axios 拦截器的使用（快手）

3、说说 fetch，优缺点？怎么做 polyfill（阿里）

4、 axios 拦截器、取消功能是怎么实现的（字节）

5、 Axios 中会判断使用 fetch 还是 xhr，其中 fetch 本身是没有 abort 方法的，那么 fetch 怎么实现取消功能？（字节）

6、封装 ajax（深信服）

7、axios 和 fetch 的区别 ？（同花顺）

## 对象

1、说说 es6 中的 class（腾讯、滴滴）

2、JSONP 原理（字节）

3、说说对 OOP 的理解（腾讯、字节）

4、 instanceof 原理（百度、滴滴、58、同花顺）

5、 实现 instanceof 的 polyfill（小米）

6、了解哪些设计模式（猿辅导）

7、说一下 new 创建实例的时候都做了什么（滴滴、字节）

8、 浅拷贝和深拷贝的区别 ？（货拉拉、创业公司）

9、深浅拷贝，有哪些方法实现深拷贝（知乎）

10、数组和对象是如何在内存中存储的（叠纸）

11、如果让你实现一个 new 是怎么实现 （字节）

12、怎么区别 array 和 object ？（阿里）

13、说一下继承的几种方式，怎么实现的（百度）

14、 Object 和 Map 的理解 和 相互转换（小米、滴滴）

## DOM 与事件

1、说一说事件冒泡，事件委托以及应用场景（同花顺、网易）

2、冒泡和捕获，这个浏览器的冒泡和捕获能颠倒么 ？ （字节）

3、如何阻止事件冒泡（网易、京东）

4、 `setTimeout`为什么会存在延迟？怎么解决这个问题 ？（广联达）

5、 DOM 怎么添加事件（阿里）

6、给一个 DOM 同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获（知乎）

7、dom 树和 render 树有啥区别（腾讯）

8、 异步加载 css 会阻塞页面的渲染吗？（腾讯）

9、DOM 树和 css dom 树是互斥的还是同时的（字节）

10、JS 脚本阻塞 DOM 构建，JS 脚本会不会对 css dom 树影响（字节）

## 事件循环

1、说说 JS 的事件循环机制 ？（广联达、滴滴、商汤、百度、小米）

2、说一下浏览器的事件循环机制 和 node 事件循环机制（自如、滴滴）

3、说一下 JS 的事件循环和 node 事件循环的区别（商汤、滴滴）

4、 EventLoop JS 事件循环队列、宏任务和微任务（字节）

## ES6 相关

1、ES6 和 CommonJS 对循环引用的处理有什么不同（猿辅导）

2、ES6 有哪些新特性，说一下你用过的 ES6 的新特性（百度、快手、字节、知乎、小米）

3、如何用 ES5 实现 ES6 的 class 的 static 和 private（百度）

4、 map 的返回值（网易）

5、 map 记录出现次数（小米）

6、Map 和 weakMap 有啥不一样的（字节、同花顺、阿里、滴滴）

7、map 和 object 区别（滴滴）

8、 Set、Map、WeakMap、WeakSet 区别（小米）

9、Array.map some forEach 区别（百度）

## 函数

1、说一下你知道的纯函数（滴滴）

2、箭头函数和普通函数的区别（招银、百度、知乎、字节）

3、箭头函数有 super 吗 ？（百度）

4、 实现一个柯里化函数（字节、商汤）

5、 箭头函数如何表示不定长的参数（字节）

## 综合题

1、取两个整数之间随机一个整数（叠纸）

2、从数组中取 m 个数和为 n（叠纸）

3、写一道题：给两个矩形，有每个矩形点坐标以及长宽高，判断是否相交（字节）

4、 查找字符串中最长不重复子串（字节）

5、 实现函数的链式调用（商汤）

6、写一个返回数字类型的函数，要求自定义的类实例化的对象返回定义的类名（商汤）

7、前端如何导出列表全部页面数据（快手）

8、 监听时间的三个参数 ？（网易）

9、JS 随机生成颜色（阿里）

10、如何判断元素出现在可视区域（小米）

11、判断元素距离文档顶部的距离和视图窗口高度和滚动过距离和的大小关系（小米）

12、正则你知道多少，实现一个简单用户名的匹配（字节）

## 相关概念

1、说说进程、线程是什么，了解协程么 ？（字节）

2、说说读写锁（字节）

3、说一下 JS 的微任务和宏任务有哪些（商汤）

4、 前端部分做了哪些数据存储 ？（小公司）

5、 渐进增强和优雅降级（深信服）

6、代理和反向代理（百度）

## 防抖与节流，垃圾回收

1、实现防抖和节流，原理介绍+应用场景（商汤、同花顺、广联达、百度、小红书、知乎、小米、字节）

2、说说 JS 垃圾回收（百度）

3、说一下 v8 的垃圾回收机制（58、字节）

4、 JS 的堆、栈，以及垃圾回收方式（字节）

## 手写代码面试题

1、手写获取数组的重复元素，要求尽可能用多种方法实现（小米）

2、手写 Array.prototype.reduce()（百度）

3、用 promise 封装实现 readfile 和 writefile 的同步请求（百度）

4、 手写 Promise（字节、百度、深信服、小红书）

5、 手写 apply（深信服）

6、手写 call 函数（滴滴、网易）

7、手写 new（阿里、深信服）

8、手写深拷贝（招银、滴滴、货拉拉）

9、手写虚拟 dom 转换成真实 dom（字节）

10、手写 assign，要考虑全面，包括 symbol 也要考虑在内（猿辅导）

11、手写 ES6 的模板字符串（百度）

12、手写发布订阅模式，订阅，触发，移除（小米）

13、手写斐波那锲数列（知乎）

14、 手写防抖和节流（商汤、同花顺、广联达、百度、小红书、知乎、小米、字节）

## 其它

1、object 的 tostring 和构造器的 tostring 的区别（招银）

2、esbuild 的主要功能（招银）

3、cjs 和 esm 的区别（招银）

4、 对于没有标注 es module 的如何引入，转化 cjs 模块（招银）

5、 如何使用 Reflect，它提供了什么？（百度）

6、raf setTimeout setInterval 区别（百度）

7、getBoundingClientRect 方法的使用场景（小米）

8、 IntersectionObserver 方法的应用场景（小米）

9、useMemo() 和 useCallback() 有什么区别 ？（字节）

10、平时使用 JS 还是 TS，为什么越来越多的企业使用 TS 了（字节）

11、说说 JS 中 with 的使用 ？（字节）

12、页面有一个 iframe，将主页面的一个数组传到 iframe 中再用 instanceof 判断数组是否可行（字节）

13、回答以下代码输出结果（小米）

```js
var a = 1;
function f() {
  console.log(a);
  var a = 2;
}
f();
```

14、说出代码输出并改正错误（小米）

```js
function A(a) {
  this.x = a;
  var get = function () {
    return this.x;
  };
  this.print = function () {
    console.log(get());
  };
}
a = new A(1);
a.print();
```

15、以下输出的结果

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

## TypeScript

1、为什么越来越多的企业选择使用 TypeScript ？

2、TypeScript 中的原始类型有哪些 ？

3、说说数组在 TypeScript 中是如何工作的 ？

4、什么是 any 类型，何时使用 ？

5、什么是 void，什么时候使用 void 类型 ？

6、TypeScript 中声明变量有哪些不同的关键字 ？

7、如何书写带有类型注释的函数 ？

8、如何在 TypeScript 中创建对象 ？

9、如何在 TypeScript 中指定可选属性 ？

10、说说枚举在 TypeScript 中是如何工作的 ？

11、什么是参数解构 ？

12、说说 TypeScript 中 for 循环的不同变体

13、TypeScript 中控制成员可见性有几种方法 ？

14、TypeScript 支持静态类吗 ？为什么 ？

# JS 数据类型面试题

关于

- JS 数据类型 相关面试题过程是根据自身项目实践以及查阅官方文档等最终的得出结论。
- 仅供学习参考，评论区感谢补充和纠错 ！

### 1、JS 有哪些数据类型，如何判断这些数据类型 ？（腾讯、阿里、滴滴、货拉拉、百度）

**最新的 ECMAScript 标准定义了 8 种数据类型（7 种基本数据类型、1 种引用数据类型）**

| 分类             | 数据类型                                                     |
| :--------------- | :----------------------------------------------------------- |
| 7 种基本数据类型 | string（字符串）、number（数字）、boolean（布尔）、undefined（未定义）、null（空）、Symbol（符号）、BigInt（数值类型，表示任意精度的整数） |
| 1 种引用数据类型 | Object 对象：Array（数组）、Function（函数）、Date（时间）等 |

**JS 检测数据类型的 4 种方式**

- typeof
- instanceof
- constructor
- Object.prototype.toString.call()

这四种方法各有自己的优缺点，我们可以根据自己的需要去选择。

**① 数据类型检测方法一：typeof**

详细解读

语法

```js
typeof 变量;
//或
typeof 变量;
```

例子

```js
typeof 1; //'number'
typeof ""; //'string'
typeof true; //'boolean'
typeof undefined; // 'undefined'
typeof null; //'object'
typeof [1, 2, 3]; //'object'
typeof {}; //'object'
typeof function () {}; //'function'
typeof Symbol(); //'symbol'
```

- typeof 的返回值类型为字符串类型
- typeof 判断基本数据类型时，除了 null 的输出结果为'object' 其它类型都能正确判断
- typeof 判断引用数据类型时，除了判断函数会输出'function' 其它都输出'object'

**注意点：**

null 的数据类型是 object （null 是对一个空对象的引用，是一个占位符）

- typeof 并不能区分引用数据类型（Array 数组、Date 时间）等
- 所以我们可以使用 instanceof 来判断引用数据类型

**② 数据类型检测方法二：instanceof**

详细解读



语法：

```js
obj1 instanceof obj2; // 判断obj1是否为obj2的实例
```

- instanceof 用来判断两个对象是否属于实例关系，通过这种关系来判断对象是否属于某一类型。（但不能判断对象具体属于哪种类型）。
- instanceof 可以准确判断引用数据类型，**它的原理是**：检测构造函数的 prototype 属性是否在某个实例对象的原型链上。
- instanceof 返回值为布尔值

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238);"><summary style="outline: none; cursor: pointer; color: rgb(62, 175, 124);">点击查看源代码</summary><div class="language-html extra-class" style="position: relative; background-color: rgb(40, 44, 52); border-radius: 6px;"><pre class="language-html" style="color: rgb(204, 204, 204); background: transparent; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; font-size: 1em; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.4; tab-size: 4; hyphens: none; padding: 1.25rem 1.5rem; margin: 0.85rem 0px; overflow: auto; border-radius: 6px; position: relative; z-index: 1;"><code style="font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; color: rgb(255, 255, 255); padding: 0px; margin: 0px; font-size: 0.85em; background-color: transparent; border-radius: 0px;"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token parameter"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token parameter"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span></span></span><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span></code></pre></div><p style="line-height: 1.7; margin-bottom: 0px; padding-bottom: 0px;"><img src="https://www.arryblog.com/assets/img/image-20220523162449860.fd020483.png" alt="image-20220523162449860" class="medium-zoom-image" style="cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; max-width: 100%;"></p></details>

**③ 数据类型检测方法三：constructor（构造函数）**

详细解读



语法：

```js
"".constructor === String; // true
var num = 1;
num.constructor === Number; // true
true.constructor === Boolean; // true
[].constructor === Array; // true
var obj = {};
obj.constructor === Object; // true
```

当一个函数 F 被定义时，JS 引擎会为 F 添加 prototype 原型，然后在 prototype 上添加了一个 constructor 属性，并让其指向 F 的引用

```html
<script>
  function F() {}
  const f = new F(); // 实例
  console.log(F.prototype.constructor); // function F(){}
  console.log(F.prototype.constructor === F); // 构造器指向F
  console.log(f.constructor === F);
</script>
```

当执行 const f = new F() 时，F 被当成了构造函数，f 是 F 的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此`f.__proto__.constructor===F`简写成`f.constructor === F`

从上面的整个过程来看，构造函数 F 就是新对象 f（实例）的类型。所以如果某个实例的 constructor 指向某个构造函数，那这个构造函数就是这个实例的类型。

**注意**：

> - constructor 是不稳定的，因为开发者可以重写 prototype,重写后，原有的 constructor 引用会丢失，需要我们重新指定 constructor 的引用
> - 在没有重新指定时，constructor 会默认为 Object

**为什么重写 prototype 后，constructor 的默认值会为 Object 呢？**

```html
<script>
  function F() {}
  F.prototype = {};
  console.log(F.prototype.constructor);
  // 结果为 Object() { [native code] }
</script>
```

当 F.prototype={ }时，{ }是 new Object 的字面量（Object 的实例），所以 Object 原型上的 constructor 会被传递给{ }，Object 的 constructor 指向的就是 Object 本身。

**④ 、数据类型检测方法四：Object.prototype.toString.call()**

详细解读

`toString()`是 Object 的原型方法，调用该方法，默认返回当前对象的 `[object type]`。其中 type 就是对象的类型。

- `Object`对象，直接调用`toString()` 就能返回 [object Object]
- 其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息

```js
Object.prototype.toString.call(""); // [object String]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(Symbol()); // [object Symbol]
Object.prototype.toString.call(undefined); // [object Undefined]
Object.prototype.toString.call(new Function()); // [object Function]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call([]); // [object Array]
Object.prototype.toString.call({}); // [object Object]
Object.prototype.toString.call(document); // [object HTMLDocument]
Object.prototype.toString.call(window); // [object Window]
```

### 2、null 和 undefined 的区别 ？

- **undefined（未定义）**：当一个变量被定义（声明）但并没有赋值时，他的初始值就是 undefined。

- null（空）

  ：表示对一个空对象的引用。

  - 当一个变量定好之后，未来是用来保存对象的引用时，我们可以给他赋初始值为 null。
  - 当一个对象使用完，需要对其进行释放内存时，可以将其值设置 null （js 会自动垃圾回收）

**相同点**：

- undefined 和 null 都是基本数据类型，保存栈中。
- undefined 和 null 转换为 boolean 布尔值都为 false

**不同点**:

两者转换为数字类型时，其值不一样

```js
Number(undefined); //NaN
Number(null); //0
```

**特殊点**:

```js
undefined == null; //true
```

### 3、基本数据类型和引用数据类型的区别？

| 比较           | 基本数据类型                                                 | 引用数据类型                                                 |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 数据存放位置   | 基本数据类型存放在**栈**中，数据大小确定，内存空间大小可以分配 | 引用数据类型存放在**堆**中，每个空间大小不一样，要根据情况进行特定的配置 |
| 变量存储内容   | 变量中存储的是**值本身**                                     | 变量存储的是**地址**                                         |
| 变量用来赋值时 | 把变量的**值**复制一份去赋值                                 | 把变量的**内存地址**复制一份去赋值                           |
| 存储内容大小   | 存储**值较小**                                               | 存储**值较大**                                               |

**栈和堆的的介绍**

详细解读

当我们创建数据时就会占用内存，在内存中主要开辟两类空间：**堆内存** 和 **栈内存**

| 比较     | 栈（线程）                                   | 堆（进程，线程共享）                 |
| :------- | :------------------------------------------- | :----------------------------------- |
| 大小固定 | 创建时，确定大小（值大小固定），故可能会溢出 | 大小不固定，可随时增加               |
| 存储类型 | 存储基本数据类型及引用类型数据的堆地址       | 存储引用类型数据                     |
| 如何访问 | 按值访问                                     | 按引用（堆内存地址）访问             |
| 特点     | 空间小，运行效率高                           | 空间大，运行效率相对较低             |
| 存放规则 | 按顺序存放，先进后出                         | 无序存储，可根据引用（地址）直接获取 |

**实例**:

基本类型和引用类型赋值的区别

```html
<script>
  var a = 10;
  var b = a; //10
  a = 20;
  console.log(a, b); //20 10
</script>
```

- a 变量是基本数据类型,他在赋值是把 a 的值复制一份给到 b
- 所以 b = 10 ，最后我们修改 a 的值，并不会响影到 b

![image-20220513164139171](E:\coder\09_OneNote\image\image-20220513164139171.36372a70.png)

```html
<script>
  var obj = {
    name: "清心",
    age: 34,
  };
  var obj2 = obj; //是把obj中地址赋值给obj2,两者指向的是同一个堆内存中地址
  obj.name = "小丽"; //操作是堆内存中的数据
  console.log(obj === obj2); //true
  console.log(obj.name, obj2.name); //小丽 小丽
</script>
```

> 栈内存中存着变量 obj 对堆内存中的地址，而堆内存中存着对应地址的数据内容

![image-20220513164726666](E:\coder\09_OneNote\image\image-20220513164726666.ef4e20b0.png)

当 obj2=obj 时，其实是把 obj 中保存的地址赋值给了 obj2,所以本质上 obj===obj2 比较时,比较的是地址，地址始终没有变，所以两者是全等的。

我们在操 obj.name = '小丽' 时，操作的是堆内存中的数据，所以 obj.name 和 obj2.name 的值是一样的。

### 4、typeof(NaN)返回结果？

- NaN 不是数字的数字类型，所以 `typeof(NaN)` 返回结果就是 number
- NaN === NaN 结果为 false，他自己和他自己都不相等
- 如何判断一个变量的值是 NaN ?

```js
var a = "我" - "你";
isNaN(a) && typeof a === "number";
```

### 5、以下两种方式的区别？及 typeof 得到的结果（字节）

```js
const str1 = "abc";
const str2 = new String("abc");
```

**str1 是基本数据类型**

- 存储在在栈内存中，用 typeof 检测的结果为 string。
- 当我们把 str1 赋值给别一个变量时，是把 str1 中的值复制一份来赋值。

**str2 是引用数据类型**

- 存储在堆内存中，不过变量 str2 中存的是指向堆内存中的地址，用 typeof 检测 str2 结果为 Object。
- 当我们把 str2 赋值给另一个变量时，是把 str2 中存入的地址复制一分给到了变量。

### 6、typeof 能判断那些类型 ？

typeof 能判断的类型有：string、number、boolean、undefined、symbol、function

- typeof 判断基本数据类型时，除了 null 的输出结果为'object' 其它类型都能正确判断
- typeof 判断引用数据类型时，除了判断函数会输出'function' 其它都输出'object'

### 7、typeof(null) 为什么返回的是'object' ?



- `typeof(null) = object` 是 JS 在诞生设计之初留下的历史遗留 BUG 问题
- 在 JS 中进行数据底层存储的时候是用二进制存储的，这是一定的，而且它的前三位是代表存储的数据类型，而 000 是代表 object 类型也就是引用类型的数据。
- 而 null 正好全是 0，所以它巧妙的符合 object 类型的存储格式，所以在 typeof 检测的时候，它才会输出 object。

### 8、== 和 === 的区别 ？



== 在比较类型不同的变量时，如果两侧的数据类型不同，则会按以下规则进行相应的隐式类型类型转换

- 对象 --> 字符串 --> 数值
- 布尔值 --> 数值

> 转换后，再比较两边的值是否相等，值相等返回 true，不等返回 false;

=== 在比较时，会比较值和类型两个。只要两边值的类型不相等就返回 false

```js
var x = 2;
var y = "2";
(x == y)(
  // 返回 true，因为 x 和 y 的值相同
  x === y
);
// 返回 false，因为 x 的类型是“数字”，y 的类型是“字符串”
```

**不过要注意以下几个特殊情况的比较**

```js
NaN === NaN; // false NaN和任何数据都不相等，包括自身
[] == []; // false 比较的是地址
{} == {}; // false 比较的是地址
undefined == null; // true; 特殊情况，记下
```

> 对象转字符串，得到的是'[object Object]'

**考题 1：以下输出结果**

```js
console.log([] == false); // true
```

> - [] 转换成字符串是'' ，然后'' 转换成数值是 0
> - false 转换成数值是 0 所以最后比较的值是 0==0 ，结果为 true

**考题 2：以下输出结果**

```js
if ([]) {
  alert("能弹出吗？"); // 可以弹出弹窗
}
```

> - if 语句中的表达式或值都会被转成 boolean
> - [] 转成布尔值是 true，所以可以弹出。

### 9、什么是变量提升 ？（腾讯、网易、小米）

变量提升：是指使用 var 关键字声明的变量会自动提升到当前作用域的最前面。不过只会提升声明，不会提升其初始化。

```html
<script>
  console.log(a); // undefined
  var a = 10;
  function fn() {
    console.log(b); // undefined
    var b = 1;
  }
  fn();
</script>
```

**变量只有被声明后，才能使用**

- 我们在 var a=10; 之前 console.log(a); 之所以不会报错，就是因为变 a 的声明被提前到了当前作用域的最顶部
- 不过只提升了声明，并没会提升初始化，所以打印结果为 undefined; （变量声明初始化，其默认值是 undefined）

上面代码可以看成如下：

```html
<script>
  var a;
  console.log(a); // undefined
  a = 10;
  function fn() {
    var b;
    console.log(b); // undefined
    b = 1;
  }
  fn();
</script>
```

**补充**：

- 函数声明也会被提升，函数和变量相比，会被优先提升。
- 这意味着函数会被提升到更靠前的位置，如果出现了重名的变量和函数，声明提升时会以函数为主。

```html
<script>
  console.log(num); // function num(){console.log('函数');}  函数被优先提升
  var num = 1;
  console.log(num); // 1 在从上往下执行时num变量赋值为 1
  function num() {
    console.log("函数");
  }
  console.log(num()); // 报错，因为变量num被重新赋值为1，不会再有函数了
</script>
```

### 10、const、let、var 区别（叠纸、字节、阿里）

const、let、var 三者的区别，我们可以从以下 5 个点来展开对比

- **变量提升和暂时性死区**： var 存在变量提升，let 和 const 不存在变量提升，所以 let 和 const 会存在暂时性死区
- **块级作用域**： var 不存在块级作用域，let 和 const 存在块级作用域
- **重复声明**： var 允许重复声明变量，let 和 const 在同一作用域下不允许重复声明变量
- **修改变量**： var 和 let 声明的变量可以修改，const 是不可以的。
- **使用**：const 用来声明常量，引用类型值。其它情况推荐用 let ，避免用 var

**① 变量提升**

详细解读

- var 声明的变量存在变量提升，即变量可以在声明之前被调用。
- let 和 const 不存在变量提升，即它们所声明的变量一定要在声明后使用，否则会报错

```html
<script>
  console.log(a); // undefined
  var a = 1;
</script>
<script>
  console.log(b); // Cannot access 'b' before initialization
  let b = 2;
  console.log(c); // Cannot access 'c' before initialization
  const c = 3;
</script>
```

**② 块级作用域**

详细解析

var 不存在块级作用域，let 和 const 存在块级作用域

```js
{
  var a = 1;
}
console.log(a); // 1
{
  let b = 2;
}
console.log(b); // Uncaught ReferenceError: b is not defined
{
  const c = 3;
}
console.log(c); // Uncaught ReferenceError: c is not defined
```

**③ 重复声明**

详细解读

var 允许重复声明变量，let 和 const 在同一作用域下不允许重复声明变量

```html
<script>
  var a = 1;
  var a = 2;
</script>
<script>
  let b = 1;
  let b = 2; // Uncaught SyntaxError: Identifier 'b' has already been declared
</script>
<script>
  const c = 1;
  const c = 2; // Uncaught SyntaxError: Identifier 'c' has already been declared
</script>
```

**④ 修改变量**

详细解读

- var 和 let 声明的变量，可以修改
- const 声明的是一个只读的常量。一旦声明，常量的值就不能改变

```html
<script>
  var a = 1;
  a = 2;
  let b = 2;
  b = 3;
  console.log(a, b); // 2 3
</script>
<script>
  const c = 3;
  c = 3;
  console.log(c); // ncaught TypeError: Assignment to constant variable.
</script>
```

**⑤ 使用**

详细解读

- 能用 const 的情况尽量使用 const，比如声明的变量是用来保存 对象、数组等引用类型时，用 const
- 其他情况下大多数使用 let，比如 for 循环，避免使用 var

> 提示：var 在全局作用域中声明的变量，相当于 window 对象的属性。

### 11、const 定义的值一定是不能改变的吗？



- const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个**栈内存**地址所保存的数据不得改动。
- 对于简单类型的数据（数值、字符串、布尔值）值就保存在变量指向的那个栈内存地址，因此等同于常量。
- 引用类型的数据（主要是对象和数组）变量指向的栈内存地址，保存的只是一个指向实际数据的指针
- const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

所以如果是 const 声明的是一个引用类型的变量，其引用类型的结构是可以发生改变的。

### 12、const 声明了数组，还能 push 元素吗，为什么 ？





可以

- 因为 const 声明的变量保存的只是**栈内存**中的地址，只是一个指向实际数据的指针。指针指向堆内存中保存的数据。
- const 只能保证栈内存中的地址不变，但是堆内存中的数据如何改变是没有办法控制的。
- push 方法相当于是改变了堆内存中的数据结构。

# 闭包 、作用域面试题

关于

- JS 闭包 、作用域 相关面试题过程是根据自身项目实践以及查阅官方文档等最终的得出结论。
- 仅供学习参考，评论区感谢补充和纠错 ！

### 1、闭包里面的变量为什么不会被垃圾回收（快手、滴滴、58 篇、字节、小米、腾讯、网易）

**① 首先我们来了解下什么是垃圾回收 ？**

详细解读

在 js 中所谓的垃圾就是指不会再被使用的值，就会被当成垃圾回收掉。

- javaScript 会自动回收不再使用的变量，释放其所占的内存，开发人员不需要手动的做垃圾回收的处理。

- 垃圾回收机制只会回收局部变量，全局变量不会被回收，因为全局变量随时有可能被使用。（全局变量在浏览器关闭之后会回收）所以当我们定义了一个全局对象时，在使用完毕之后，最好给它重新复值为 null，以便释放其所占用的内存。

- 目前浏览器基本使用**标记清除**和**引用计数**两种垃圾回收策略

  - 标记清理
    - 当函数被调用，变量进入上下文时，会被加上存在上下文标记，是不会被清理的。
    - 当函数执行完成后，就会去掉存在上下文中的标记，随后垃圾回收程序会做一次内存清理，销毁这些变量。

  ```js
  function fn() {
    var a = 1; // 函数调用时 被标记 进入上下文
  }
  test(); // 函数执行完毕，a的标记去掉，被回收
  ```

  - 引用计数
    - 引用计数就是追踪**值**被引用的次数。声明变量并给它赋一个引用类型值时，这个值的引用数 为 1。
    - 如果同一个值又被赋给另一个变量，那引用数+1 。如果保存该值引用的变量被其它值覆 盖了，则引用数减 1。
    - 当引用计数为 0 时，表示这个值不再用到，垃圾收集器就会回收他所占 用的内存。

```html
<script>
  var a = [1, 2, 3]; // [1,2,3]的引用计数为1
  var b = a; // 变量b也引用了这个数组，所以[1,2,3]的引用数为2
  var a = null; // [1,2,3]的引用被切断，引用数-1，所以[1,2,3]的引用数为1
  // 如果只是到这里，那[1,2,3]不所占的内存不会被回收
  var b = null; // [1,2,3] 的引用被切断，引用数-1，所 [1,2,3]的引用数为0
  // 到这里，垃圾收集器在下一次清理内存时，就会把[1,2,3]所占的内存清理掉
</script>
```

> 引用计数有一个很大的坑，就是循环引用时，会造成内存永远无法释放。

**② 为什么闭包中的变量不会被垃圾回收 ？**



这里我们要明确一个点，如果闭包函数的引用计数为 0 时，函数就会释放，它引用的变量也会被释放。

- 只有当闭包函数的引用计数不为 0 时，说明闭包函数随时有可能被调用，他被调用后，就会引用他在定义时所处的环境的变量。
- 闭包中的变量就得一直需要在内存中，则就不会被垃圾回收掉。

### 2、说说 JS 作用域及作用域链（字节、小米、腾讯、商汤）

要回答这个问题 ，我们可以从以下几个方面来展开讲解：

- 什么是作用域 ？
- js 中作用域的分类 ？
- 每种作用域的特点 ？（作用或创建 ，销毁，变量和函数访问权限）
- 什么是作用域链 ？
- 什么是作用域链查找 ？

#### ① 什么是作用域 ？

简单点理解：

- 作用域是一套规则，规定了代码的作用范围。
- 这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。
- 简单来说，作用域规定了如何查找变量。比如函数外部是不能访问函数里面的变量（**闭包除外**），函数里面是可以访问函数外面的变量。

```html
<script>
  var b = 2;
  function fn() {
    var a = 1;
    console.log(b);
  }
  fn(); // 2
  console.log(a); // a is not defined  不能访问函数作用域中的变量a
</script>
```

**全面理解**：

- 作用域就是代码的执行环境。执行环境定义了变量或函数有没有权访问其他数据。
- 每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。
- 虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

比如特殊的**全局执行环境中的变量对象 window 对象**，因此所有全局变量和函数都作为 window 对象的属性和方法创建的。
在 Node 环境中，全局执行环境是 global 对象

```html
<script>
  var a = 1;
  function sum(a, b) {
    return a + b;
  }
  var n = window.sum(2, 3); // sum 相当于window对象上的方法
  console.log(window.n); // 5  n相当于window对象的属性
  console.log(window.a); // 1  a相当于window对象的属性
</script>
```

> - 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
> - 而在函数执行之后，栈将被环境弹出，把控制权返回给之前的执行环境。
> - ECMAScript 程序中的执行流正是由这个方便的机制控制着。

#### ② JS 中作用域的分类

JS 中有 3 种类型的作用域：

- 全局作用域
- 局部作用域（函数作用域）
- 块级作用域

**全局作用域**

详细解答

编写在 script 标签中的 js 代码（或单独 js 文件），都是在全局作用域中。

- 全局作用域 在页面打开时创建，在页面关闭时销毁。我们可以把全局作用中不再使用的引用类型变量重新赋值为 null
- 这样垃圾回收器就会把切断的引用类型数据当成垃圾回收掉，释放其在内存中占用的空间。

```js
let arr = [1, 2, 3]; // 堆内存开辟空间，用来保存[1,2,3]
arr = null; // 垃圾回收器会把[1,2,3]回收掉，释放其在堆内存中占用的空间
```

- 全局作用域中有一个全局对象 window,代表一个浏览器窗口，由浏览器创建，可以直接使用
- 在代码的任何地方，都可以访问全局作用域中的变量

**局部作用域（函数作用域）：**

详细解答

写在函数内部的代码，就是在局部作用域中

- 每调用一次函数就会创建一个新的私有函数作用域，形参和当前私有函数作用域中声明的变量都是私有变量，保存在内部的一个变量对象中。
- 函数被调用时创建函数作用域，函数执行完毕后，函数作用域被销毁，保存在其中的变量和函数定义了随之被销毁（**闭包除外，只有当闭包函数的引用次数为 0 时，闭包函数和闭包中的变量被销毁**）
- 函数里能访问函数外变量，但函数外部是不能访问函数里面的变量，**闭包除外，闭包函数会记住它在定义时所处的环境**

```html
<script>
  function fn(a, b) {
    var c = 10;
    console.log((a + b) * c);
  }
  fn(1, 2); //函数调用创建函数作用域，代码执行用，作用域和变量a,b,c销毁
  fn(2, 3); //函数调用创建函数作用域，代码执行用，作用域和变量a,b,c销毁
</script>
```

**特殊的闭包**：

详细解答

```html
<script>
  function checkWeight(weight) {
    return function (_weight) {
      weight > _weight ? alert("过胖") : alert("ok达标");
    };
  }
  var P1 = checkWeight(100); // 调用完毕，作用域和变量weight不会被销毁
  P1(110); // 调用完毕，作用域和变量_weight会被销毁
</script>
```

> - 如果我们在最后加上`P1 = null`，则垃圾回收器回在下一次清理内存时
> - 销毁掉 checkWeight 调用形成的作用域和作用域中的变量 weight。

**块级作用域**：

使用 let 或 const 关键字声明的变量，会形成块级作用域。

- 在 {}、if 、for 里用 let 来声明变量，会形成块级作用域。{} 之外是不能访问 {} 里面的内容。
- 块级作用域中定义的变量，在 if 或 for 等语句执行完后，变量就会被销，不占用内存

```js
{
  let a = 1;
}
console.log(a); // 会报错，{}里是块级作用域，外面是访问不到里面的变量的
<script>
  for (let i = 0; i < 3; i++) {
    console.log(i); // 0 1 2
  }
  console.log(i); // i is not defined
</script>
```

> **注意点：**
>
> 对象的 { } 不会形成块级作用域

#### ③ 作用域链：

详细解读

当代码在一个环境中执行时，会创建**变量对象**的一个作用域链（作用域形成的链条）

- 作用域链的前端，始终都是当前执行的代码所在环境的变量对象
- 作用域链中的下一个对象来自于外部环境，再下一个变量对象则来自下下一个外部环境，一直到全局执行环境
- 全局执行环境的变量对象始终都是作用域链上的最后一个对象

**作用域链查找：**

内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。

- 在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找
- 如果在某个变量对象中找到则使用该变量对象中的变量值，如果没有找到，则会一直找到全局作用域。如果最后还找不到，就会报错。

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238);"><summary style="outline: none; cursor: pointer; color: rgb(62, 175, 124);">点击查看源代码</summary><div class="language-html extra-class" style="position: relative; background-color: rgb(40, 44, 52); border-radius: 6px;"><pre class="language-html" style="color: rgb(204, 204, 204); background: transparent; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; font-size: 1em; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.4; tab-size: 4; hyphens: none; padding: 1.25rem 1.5rem; margin: 0.85rem 0px; overflow: auto; border-radius: 6px; position: relative; z-index: 1;"><code style="font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; color: rgb(255, 255, 255); padding: 0px; margin: 0px; font-size: 0.85em; background-color: transparent; border-radius: 0px;"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span></span><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span></code></pre></div></details>

### 3、怎么理解 JS 静态作用域和动态作用域（小米）

- **静态作用域**：又称词法作用域，是指作用域在词法阶段就被确定了（**函数定义的位置就决定了函数的作用域**）不会改变，javascript 采用的是词法作用域。
- **动态作用域**：函数的作用域在函数调用时才决定的。

```html
<script>
  var a = 1;
  function fn() {
    console.log(a);
  }
  function test() {
    var a = 2;
    fn();
  }
  test(); // 1
</script>
```

> 最终输出的结果为 1

说明 fn 中打印的是全局下的 a ，这也印证了 JavaScript 使用了静态作用域。

**静态作用域执行过程**

当执行 fn 函数时，先从内部的`AO`对象查找是否有`a`变量，如果没有，沿着作用域链往上查找(由于`JavaScript`是词法作用域)，上层为全局`GO`，所以结果打印`1`

### 4、以下代码输出的结果是 ？（小米）





```js
Object.prototype.a = 10;
var s = Symbol();
var obj = {
    [s]: 20,
    b: 30
}
Object.defineProperty(obj, 'c', {
    enumerable: true，
    value: 40
})
for(let val in obj) {
    console.log(val)
}
```

> 以上输出的结果为：b c a

`for...in`语句以任意顺序遍历一个对象的可枚举属性（除 Symbol 类型的属性）

# 原型、原型链面试题

关于

- 原型、原型链面试题过程是根据自身项目最佳实践以及查阅官方文档等最终的得出结论。
- 仅供学习参考，评论区感谢补充和纠错 ！

### 1、如何理解原型和原型链 ？（腾讯、货拉拉、字节、招银、阿里、小米）

- JavaScript 是一门基于原型的语言，在软件设计模式中，有一种模式叫做**原型模式**
- JavaScript 正是利用这种模式而被创建出来。

**关于原型和原型链，我们需要了解以下几个方面的内容：**

| 问题                        | 相关知识点                                                   |
| :-------------------------- | :----------------------------------------------------------- |
| 什么是原型和原型特点        | 构造函数、对象实例、prototype、`__proto__`、constructor      |
| 什么是原型链                | 绘制实例对象原型链、数组原型链、原型链的终点                 |
| 原型链查找                  | 原型链查找、属性遮蔽                                         |
| 重写原型带来的问题          | 切断现有实例与新原型之间的联系、 会导致原型对象的 constructor 属性指向 Object |
| Object.create() 方法        | 手写 create 方法、用 create 方法实现继承                     |
| instanceof 操作符           | 用法和实现原理                                               |
| in 和 hasOwnProperty 操作符 | in 与 hasOwnProperty 的对比、如何判断一个属性是原型上属性    |
| for ...in                   | for...in 的用法、可枚举对象的哪些属性？                      |

**扩展知识点：**

| 方法                  | 说明                                                         |
| :-------------------- | :----------------------------------------------------------- |
| Object.keys()         | Object.keys()方法可以将一个对象作为参数，然后把这个对象`[key，value]`对中的 key 值以数组的形式遍历出来。 |
| Object.values()       | Object.values()方法可以将一个对象作为参数，然后把这个对象`[key，value]`对中的 value 值以数组的形式遍历出来。 |
| Object.entries()      | Object.entries()方法可以将对象作为参数，返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 `for...in`循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性） |
| getOwnPropertyNames() | 方法返回一个由指定对象的所有**自身属性的属性名**（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。 |

### ① 原型和原型特点

- 我们创建的每一个函数都有一个**prototype（原型）\**属性，被称为\**显示原型**，这个属性是一个指针，指向一个对象（原型对象）。
- 这个对象的好处是，在它上面定义的属性和方法可以由特定类型的所有实例共享。
- 原型对象默认拥有一个 constructor 属性，指向它的构造函数

**代码解析**

```html
<script>
  /*Person 构造函数*/
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  /*构造函数的原型上添加方法*/
  Person.prototype.sayHello = function () {
    console.log(`大家好，我是${this.name}今年${this.age}岁了`);
  };
  /*构造函数的原型上添加方法*/
  Person.prototype.study = function () {
    console.log(`我${this.name}要学习了`);
  };
  let p1 = new Person("小明", 23); // p1为 构造函数Person new出来的实例对象
  /*实例对象上的属性会屏蔽（遮蔽）原型上同名的属性*/
  p1.study = function () {
    console.log(`我${this.name}正在学习web前端开发课程`);
  };
</script>
```

**原型结构图：**

![原型结构图](E:\coder\09_OneNote\image\20220523prototype011.7f1b23e4.png)

- 原型对象默认拥有一个 constructor 属性，指向它的构造函数

```js
console.log(Person.prototype.constructor === Person); // true
```

- 每个`对象实例`都有一个隐藏的属性`__proto__`，被称为`隐式原型`,指向它的构造函数的原型

```js
console.log(p1.__proto__ === Person.prototype); // true
```

- 对象实例可以共享原型上面的所有属性和方法

```js
p1.sayHello(); // 大家好，我是小明今年23岁了
```

- 实例自身的属性会`屏蔽(遮蔽)`原型上同名的属性，实例上没有的属性就会去原型上去找

```js
p1.study(); // 我小明正在学习web前端开发课程
```

### ② 原型链

- JavaScript 中所有的对象都是由它的原型对象继承而来。
- 而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链

**以下代码的原型链结构图：**

```html
<script>
  /*Person 构造函数*/
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  /*构造函数的原型上添加方法*/
  Person.prototype.sayHello = function () {
    console.log(`大家好，我是${this.name}今年${this.age}岁了`);
  };
  /*构造函数的原型上添加方法*/
  Person.prototype.study = function () {
    console.log(`我${this.name}要学习了`);
  };
  let p1 = new Person("小明", 23); // p1为 构造函数Person new出来的实例对象
  /*实例对象上的属性会屏蔽（遮蔽）原型上同名的属性*/
  p1.study = function () {
    console.log(`我${this.name}正在学习web前端开发课程`);
  };
  console.log(p1.__proto__ === Person.prototype); //true
  console.log(Person.prototype.constructor === Person); //true
  console.log(Person.prototype.__proto__ === Object.prototype); //true
  console.log(Object.prototype.constructor === Object); //true
  console.log(Object.prototype.__proto__); //null
</script>
```

**原型链结构图：**

![原型链结构图](E:\coder\09_OneNote\image\20220523proto0233.642ec42d.png)

> - 所有原型链的终点都是 Object.prototype
> - `Objec.prototype` 指向的原型对象同样拥有原型`Object.prototype.__proto__，不过它的原型是 null` ，而 `null` 则没有原型

### ③ 原型链查找

详细解读

- 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果这个对象本身没有这个属性时，它就会去他的`__proto__隐式原型`上去找（即它的构造函数的 prototype）。
- 如果还找不到,就去原型的原型（`即构造函数的prototype的__proto__`）上去找，....一直找到最顶层（`Object.prototype`）为止。
- 如果还没有找到，则返回 undefined。

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238);"><summary style="outline: none; cursor: pointer; color: rgb(62, 175, 124);">点击查看源代码</summary><div class="language-html extra-class" style="position: relative; background-color: rgb(40, 44, 52); border-radius: 6px;"><pre class="language-html" style="color: rgb(204, 204, 204); background: transparent; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; font-size: 1em; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.4; tab-size: 4; hyphens: none; padding: 1.25rem 1.5rem; margin: 0.85rem 0px; overflow: auto; border-radius: 6px; position: relative; z-index: 1;"><code style="font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; color: rgb(255, 255, 255); padding: 0px; margin: 0px; font-size: 0.85em; background-color: transparent; border-radius: 0px;"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token script"><span class="token language-javascript"><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function-variable function" style="color: rgb(240, 141, 73);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token parameter"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token parameter"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function-variable function" style="color: rgb(240, 141, 73);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token template-string"><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token interpolation-punctuation punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token template-punctuation string" style="color: rgb(126, 198, 153);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span></span></span><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span></code></pre></div></details>

### ④ 重写原型带来的问题

- 在已经创建了实例的情况下重写原型，会切断现有实例与新原型之间的联系
- 如果要重写原型，一定要在重写原型后，再创建实例。

```html
<script>
  function Person(name) {
    this.name = name;
  }
  let p1 = new Person("小明");
  Person.prototype.eat = function () {
    console.log(`${this.name}在吃饭`);
  };
  // 重写原型
  Person.prototype = {
    name: "小明",
    sayHello() {
      console.log(`大家好，我是${this.name}`);
    },
  };
  p1.eat(); // 小明在吃饭
  p1.sayHello(); // p1.sayHello is not a function
</script>
```

> - 在这个例子中，Person 的实例在重写原型对象之前创建的，在调用 p1.eat()时会输入正确的信息。
> - 但是在调用 p1.sayHello 时候，会报错。是因为 p1 指向的原型还是最初的原型，而这个最初的原型上并没有 sayHello 这个方法，而且 eat 这个方法。

- 重写原型对象，会导致原型对象的 `constructor` 属性指向 `Object` ，导致原型链关系混乱，所以我们应该在重写原型对象的时候指定 `constructor`( 指定后`instanceof` 仍然会返回正确的值)

```js
function Person() {}
Person.prototype = {}; //重写原型,{}是一个对象实例，对象实例的原型指向的是Object.prototype,而Object.prototype中的constructor指向的是Object
console.log(Person.prototype.constructor === Object); //true
```

重写原型对象时，单独指定 constructor

```html
<script>
  function Person() {}
  //重写原型,在prototype中需要重新指定constructor的值
  Person.prototype = {
    constructor: Person,
  };
  console.log(Person.prototype.constructor === Person); //true
</script>
```

### ⑤ Object.create

```
Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__
```

**语法：**

```html
Object.create(proto[,propertiesObject])
```

- proto 新创建对象的原型对象
- propertiesObject 可选。需要传入一个对象，将为新创建的对象添加指定的属性值和对应的属性描述符。

**手写 create 方法**

```html
<script>
  Object.create = function (o) {
    function Fn() {}
    Fn.prototype = o;
    return new Fn();
  };
</script>
```

**用 Object.create 实现类式继承**

```js
// Shape - 父类(superclass)
function Shape() {
  this.x = 0;
  this.y = 0;
}

// 父类的方法
Shape.prototype.move = function (x, y) {
  this.x += x;
  this.y += y;
  console.info("Shape moved.");
};

// Rectangle - 子类(subclass)
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// 子类续承父类
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

var rect = new Rectangle();

console.log(rect instanceof Rectangle); // true
console.log(rect instanceof Shape); // true
rect.move(1, 1); // Outputs, 'Shape moved.'
```

### ⑥ instanceof 操作符

- instanceof 用来判断两个对象是否属于实例关系，通过这种关系来判断对象是否属于某一类型。（但不能判断对象具体属于哪种类型）
- instanceof 可以准确判断引用数据类型，它的原理是**检测构造函数的 prototype 属性** 是否在某个 **实例对象的原型链上**

```html
<script>
  function Person() {}
  let p1 = new Person();
  console.log(p1 instanceof Person); //true
  console.log(p1 instanceof Object); //true
</script>
<script>
  let arr = [1, 2, 3];
  console.log(arr instanceof Array);
  let date = new Date();
  console.log(date instanceof Date);
</script>
```

### ⑦ in 操作符

用来判断该属性是否在实例或原型上，不管该属性是在实例上还是原型上，只要能找到就返回 true

```html
<script>
  function Person() {}
  Person.prototype.name = "张三";
  let p1 = new Person();
  p1.age = 23;
  console.log("name" in p1); //true 在原型Person.prototype
  console.log("age" in p1); // true 来自实例
  console.log("toString" in p1); //在原型Object的.prototype上
</script>
```

### ⑧ hasOwnProperty

- 用来判断某个属性是否是实例自身的属性，如果是返回 true，不是则返回 false
- hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数

```js
对象实例.hasOwnProperty(属性名);
<script>
  function Person() {}
  Person.prototype.name = "张三";
  let p1 = new Person();
  p1.age = 23;
  console.log(p1.hasOwnProperty("name")); //false 在原型上
  console.log(p1.hasOwnProperty("age")); // true 来自实例
  console.log(p1.hasOwnProperty("toString")); //false 在原型上
</script>
```

**案例：如何判断某个属性是否是原型上的属性**

- 只要属性在原型或实例身上，in 操作符就会返回 true。而 hasOwnProperty()只有属性存在于实例上时才返回 true。
- 因此，只要 in 操作符返回 true，同是 hasOwnProperty 返回 false，就说明该 属性就是一个原型属性。

```js
function hasPrototypeProperty(obj, name) {
  return name in obj && !obj.hasOwnProPerty(name);
}
// hasOwnProperty 是 Object 原型上的方法
console.log(Object.prototype.hasOwnProperty("hasOwnProperty")); // true
```

### ⑨ for...in

以任意顺序遍历一个对象的可枚举属性（**除 Symbol 类型的属性**）

```js
for (let key in object) {
  // key 是一个变量，每次循环时会将object的一个属性的键值给变量key,直到对象中所有属性都遍历完
  // 要执行的代码
}
```

以下对象中的 Symbol 创建的属性不会被枚举出来

```html
<script>
  var s = Symbol("不可遍历属性");
  let obj = {
    name: "张三",
    age: 23,
    [s]: 2,
  };
  for (let key in obj) {
    console.log(key); // name age
  }
</script>
```

**一般情况下**，for in 循环只会遍历我们自定义的属性，原型上默认的属性不会遍历出来。
例如：`Object.prototype.toString()`、`Object.prototype.hasOwnProperty()`是不会被遍历出来的。

**但在实际应用中**，如果是在原型中新增属性或者方法，for…in 会将原型中新增的属性和方法遍历出来。

```html
<script>
  Object.prototype.score = 100;
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  Person.prototype.sayHello = function () {
    console.log(`大家好`);
  };
  const p1 = new Person("小明", 23); //自身属性只有name  age
  for (let key in p1) {
    console.log(key); //  name age sayHello score
  }
</script>
```

如果不想过滤原型中的属性，可以用 hasOwnProperty 来做判断。

### ⑩ Object.keys() 、Object.values()、Object.entries( )

详细解读

以上三个方法，都只会枚举**对象自身可枚举的属性，不会枚举原型上**的。同时也**不会枚举 Sysmbol 类型**属性。

- Object.keys()方法可以将一个对象作为参数，然后把这个对象[key，value]对中的 key 值以数组的形式遍历出来。

```js
Object.keys(obj);
```

- Object.values()方法可以将一个对象作为参数，然后把这个对象[key，value]对中的 value 值以数组的形式遍历出来。

```js
Object.values(obj);
```

- Object.entries()方法可以将对象作为参数，返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 `for...in`循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）

```js
Object.entries(obj);
```

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238);"><summary style="outline: none; cursor: pointer; color: rgb(62, 175, 124);">点击查看源代码，案例演示</summary><div class="language-html extra-class" style="position: relative; background-color: rgb(40, 44, 52); border-radius: 6px;"><pre class="language-html" style="color: rgb(204, 204, 204); background: transparent; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; font-size: 1em; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.4; tab-size: 4; hyphens: none; padding: 1.25rem 1.5rem; margin: 0.85rem 0px; overflow: auto; border-radius: 6px; position: relative; z-index: 1;"><code style="font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; color: rgb(255, 255, 255); padding: 0px; margin: 0px; font-size: 0.85em; background-color: transparent; border-radius: 0px;"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token script"><span class="token language-javascript"><span class="token class-name" style="color: rgb(248, 197, 85);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token number" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token literal-property property" style="color: rgb(248, 197, 85);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token literal-property property" style="color: rgb(248, 197, 85);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token string" style="color: rgb(126, 198, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token keyword" style="color: rgb(204, 153, 205);"></span><span class="token operator" style="color: rgb(103, 205, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token function" style="color: rgb(240, 141, 73);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span><span class="token comment" style="color: rgb(153, 153, 153);"></span></span></span><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token tag" style="color: rgb(226, 119, 122);"><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span><span class="token punctuation" style="color: rgb(204, 204, 204);"></span></span></code></pre></div></details>

### ⑪、getOwnPropertyNames( )

方法返回一个由指定对象的所有**自身属性的属性名**（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。

```html
<script>
  Object.prototype.name = "数组";
  let arr = [1, 2, 3];
  let arr2 = Object.getOwnPropertyNames(arr);
  console.log(arr2); //['0','1','2','length']
  console.log(Object.keys(arr)); //['0','1','2']

  for (let key in arr) {
    console.log(key); // 0 ,1,2,name
  }
</script>
```

### 总结：可枚举对象中属性的范围

| 可枚举方法                 | 自身可枚举属性 | 自身不可枚举 | Sysmbol 类型 | 原型上属性                                    |
| :------------------------- | :------------- | :----------- | :----------- | :-------------------------------------------- |
| for...in                   | ✔              | ✘            | ✘            | ✔（自定义原型属性可枚举，默认原型上的不可以） |
| Object.keys                | ✔              | ✘            | ✘            | ✘                                             |
| Object.values              | ✔              | ✘            | ✘            | ✘                                             |
| Object.entries             | ✔              | ✘            | ✘            | ✘                                             |
| Object.getOwnPropertyNames | ✔              | ✔            | ✘            | ✘                                             |

### 2、原型链的终点是什么？（货拉拉）



原型链的终点是 null ，因为 `Object.prototype.__proto__` 指向 null

### 3、说说 [] 的原型链 ？（腾讯）



- `[].__proto__` 指向 Array.prototype
- `Array.prototype.__proto__` 指向 `Object.prototype`
- `Object.protytype.__proto__` 的最终指向为 null

```js
let arr = [1, 2, 3];
console.log(arr.__proto__ === Array.prototype); // true  所有数组都是由Array构造出来
console.log(Array.prototype.__proto__ === Object.prototype); // true  Array构造函数的是由 Object构造出来的。
console.log(Object.prototype.__proto__); // null Objec.prototype 指向的原型对象同样拥有原型，不过它的原型是 null ，而 null 则没有原型
```

**[] 的原型链结构图**

![202205.23arrprototype](E:\coder\09_OneNote\image\202205.23arrprototype.bc922d2b.png)

# 什么是继承，JS 原型链实现继承

以下我们先使用 UML 类图来表示类的属性和方法，用以举例说明

- UML（统一建模语言）是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。
- UML 是面向对象设计的建模工具，独立于任何具体程序设计语言。

（1）以下两个无关的类：我们发现，People 类 和 Car 类 没有任何关系

![image-20220109132528373](E:\coder\09_OneNote\image\image-20220109132528373.c18910c1.png)

（2）People 类和 Student 类的关系：我们发现，Student 是一种 People

![image-20220109134146856](E:\coder\09_OneNote\image\image-20220109134146856.007dbee2.png)

> - People 类拥有的属性和方法 Student 类都有，Student 类还扩展了一些属性和方法
> - Student “是一种” People，两类之间是 “is a kind of ” 关系
> - 这就是 继承 关系：Student 类继承自 People 类

## 1、什么是继承 ？

TIP

- 继承描述了两个类之间的 “ is a kind of ” 关系
  - 比如：学生“是一种”人。所以，人类和学生类之间就构成继承关系
- People 是 "父类" （或 "超类"、”基类“）Student 是 ”子类“ (或 ”派生类“)
- 子类丰富了父类，让类描述得更具体、更细化

![image-20220109145240276](E:\coder\09_OneNote\image\image-20220109145240276.6ccbc898.png)

> - 在 UML 图示中使用**白色的空心箭头**来表示类和类之间的**继承关系**
> - 箭头的方向是由 子类指向父类
> - 这样的表达方式就是继承

### 更多的继承关系举例

| 父类        | 子类                     |
| :---------- | :----------------------- |
| People      | Student、Teacher         |
| Vehicle     | Car、Truck、Motorcycle   |
| Appliance   | Television、Refrigerator |
| Publication | Book、Magazine           |

## 2、JavaScript 中如何实现继承

TIP

- 实现继承的关键在于：子类必须拥有父类的**全部属性和方法**，同时子类还应该能定义自己特有的属性和方法
- **使用 JavaScript 特有的原型链特性来实现继承，是普遍的做法**
- 在`ES6`中，将介绍新的实现继承的方法

## 3、通过原型链实现继承

![image-20220109160201709](E:\coder\09_OneNote\image\image-20220109160201709.2355d950.png)

```js
// 父类，人类
function People(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}

People.prototype.sayHello = function () {
  console.log(
    "大家好，我是" +
      this.name +
      "，我今年" +
      this.age +
      "岁了，我是" +
      this.sex +
      "生哦"
  );
};

People.prototype.sleep = function () {
  console.log(this.name + "开始睡觉了，zzzzzzzzzzzzz");
};

// 子类，学生类
function Student(name, age, sex, scholl, studentNumber) {
  this.name = name;
  this.age = age;
  this.sex = sex;
  this.scholl = scholl;
  this.studentNumber = studentNumber;
}

// 关键语句，实现继承
Student.prototype = new People();

Student.prototype.study = function () {
  console.log(this.name + "正在学习 ！");
};
Student.prototype.exam = function () {
  console.log(this.name + "正在考试，加油加油 ！");
};

// 重写（override）父类的sayHello方法
Student.prototype.sayHello = function () {
  console.log(
    "敬礼 ！！！大家好，我是" +
      this.name +
      "，我今年" +
      this.age +
      "岁了，我是" +
      this.sex +
      "生哦"
  );
};

// 实例化
var cuihua = new Student("翠花", 18, "女", "高新中学", 20800);

cuihua.sayHello();
cuihua.study();
cuihua.exam();
cuihua.sleep();

var laoliu = new People("老刘", 38, "男");

laoliu.sayHello();
```

### 输出结果：

![image-20220517232940175](E:\coder\09_OneNote\image\image-20220517232940175.a74e2585.png)

# JS 变量交换的 5 种方法

## 方法一：算术运算法

实现原理：

把 a、b 看做数轴上的点，围绕两点间的距离来进行计算。

```js
var a = 8;
var b = 6;

a = b - a;
b = b - a;
a = b + a;

console.log("a：" + a + " ，b：" + b); // 输出 a：6 ，b：8 交换成功
```

具体过程：

- **第一句**：`“a=b-a”`求出 ab 两点的距离，并且将其保存在 a 中
- **第二句**：`“b=b-a”`求出 a 到原点的距离（b 到原点的距离与 ab 两点距离之差），并且将其保存在 b 中
- **第三句**：`“a=b+a”`求出 b 到原点的距离（a 到原点距离与 ab 两点距离之和），并且将其保存在 a 中

完成交换 ！

## 方法二：借助数组特性交换

实现原理：

借助数组的下标及运算符的优先级实现

```js
var a = 1,
  b = 2;

a = [a, b]; // 让 a 变成数组
b = a[0]; // 先取出 b
a = a[1]; // 再覆盖 a

console.log("a：" + a + " ，b：" + b); // 输出 a：2 ，b：1 完成交换
```

## 方法三：位运算

代码实现

```js
var a = 1, // 二进制：0001
  b = 2; // 二进制 0010

a ^= b; // a = a ^ b = 1 ^ 2 = 3
b ^= a; // b = b ^ (a ^ b) = 2 ^ (1 ^ 2) = 1
a ^= b;

console.log("a：" + a + " ，b：" + b); // 输出 a：2 ，b：1 完成交换
```

**实现原理：**

- `^`运算符跟`|`类似，但有一点不同的是如果两个操作位都为 1 的话，结果产生 0
- 1 的二进制表示为 `0 0 0 0 0 0 1`
- 3 的二进制表示为 `0 0 0 0 0 1 1`
- 所以 `1 ^ 3`的结果为`2`

## 方法四：ES6 的解构

用解构的语法特性，一次性解决，简单粗暴 !

- **更重要的一点**：解构语法还适用于其他类型的变量进行互换。
- 所以，用解构可以很 easy 地进行互换。

```js
let a = 1,
  b = 2;

[a, b] = [b, a];

console.log("a：" + a + " ，b：" + b); // 输出 a：2 ，b：1 交换完成
```

## 方法五：借助对象的键值对

实现原理：

把 a 先变成了一个对象，这个对象保存着应该交换后的键值对，最后赋值搞定

```js
var a = 1,
  b = 2;

a = { a: b, b: a };
b = a.b;
a = a.a;

console.log("a：" + a + " ，b：" + b); // 输出 a：2 ，b：1 完成交换
```

# 反转数组最佳实践

如何在不改变原始数组的情况下反转数组

`reverse()` 方法颠倒了数组中元素的顺序，但它改变了原始数组。

```js
// 让我们举一个简单的例子来演示这个案例：
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reverse();

console.log(newArray); // [ 5, 4, 3, 2, 1]
console.log(originalArray); // [ 5, 4, 3, 2, 1]
```

你会发现，reverse() 方法已经改变了原始数组，因此直接使用该方法无法实现

### 很少有解决方案不会改变原始数组，让我们来看看

## 1、使用切片和反向方法

TIP

在这种情况下，只需调用 `slice()` 数组上的方法来创建浅拷贝，然后 `reverse()` 在拷贝上调用方法

```js
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.slice().reverse(); // slice 切片一个数组将产生一个新副本

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
```

## 2、使用扩展和反向方法

TIP

在这种情况下，让我们使用扩展语法 (...) 创建数组的副本，然后 `reverse()` 在副本上调用方法

```js
const originalArray = [1, 2, 3, 4, 5];
const newArray = [...originalArray].reverse();

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
```

## 3、使用 reduce 和 spread 方法

TIP

这里对数组元素执行 reducer 函数，并使用 spread 语法将累积的数组附加到右侧

```js
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reduce((accumulator, value) => {
  return [value, ...accumulator];
}, []);

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
```

## 4、使用 reduceRight 和 spread 方法

TIP

这里对数组元素执行一个右 reducer 函数（即 reduce 方法的相反方向），并使用 spread 语法将累加的数组追加到左侧

```js
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reduceRight((accumulator, value) => {
  return [...accumulator, value];
}, []);

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
```

## 5、使用 reduceRight 和 push 方法

TIP

这里对数组元素执行一个右 reducer 函数（即 reduce 方法的相反方向），并将迭代后的值压入累加器

```js
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reduceRight((accumulator, value) => {
  accumulator.push(value);
  return accumulator;
}, []);

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
```

# 深入 JS 递归、深浅克隆

## 1、谈谈你对递归的简单理解 ？

以下图片：

- 画的一双手在画画，他画的是正在画画的双手 ....
- 每一次画作都跟前一次是相同的，形成了层层的嵌套，就越来越小
- 并且，**嵌套的内容就是它本身，在 JS 中就称之为 递归**

![image-20211223215608236](E:\coder\09_OneNote\image\image-20211223215608236.b8aa53d3.png)

## 2、对递归的深入理解和定义

定义

- 函数的内部语句可以**调用这个函数自身**，从而发起对函数的一次迭代
- 在新的迭代中，又会执行调用函数自身的语句，从而又产生一次迭代
- 当函数执行到某一次时，不再进行新的迭代，函数被一层一层返回，函数被递归。
- 递归是一种较为 **高级的编程技巧**，它把一个大型复杂的问题，层层转化为一个与原问题相似的，但规模较小的问题来求解。

## 3、举例说明，什么是递归 ？

使用 5 的阶乘来举例，了解什么是递归？


![image-20211223222447469](E:\coder\09_OneNote\image\image-20211223222447469.75c30cbb.png)

- 边界条件：确定递归到何时终止，也称之为**递归出口**
- 递归模式：大问题是如何分解为小问题的，也称为**递归体**

## 4、书写一个函数

这个函数内部自己会调用自己，从而形成递归

```js
function factorial(n) {
  // 函数的功能是计算n的阶乘，n的阶乘是 n*(n-1)的阶乘
  // n! = n * (n-1)!

  if (n == 1) return 1;
  // 如果询问的不是1的阶乘，就返回 n * (n-1)
  return n * factorial(n - 1);

  // 三目运算符
  // return n == 1 ? 1 : n * factorial(n - 1);
}

// 调用函数
var result = factorial(5);
// 输出结果
console.log(result);
```

**递归，简单理解就是函数内部调用函数自身，达到某个条件之后，停止调用。**

## 5、递归常规算法题

斐波那契数列

- 数列：1、1、2、3、5、8、13、21 你找到规律了吗 ？
- 规律：数列下标为 0 和 1 的项的值都是 1，从下标为 2 的项开始，每项等于前面两项的和

```js
// 编写一个函数，这个函数的功能是返回斐波那契数列中下标为n的那项的值
function fib(n) {
  // 数列的下标为0的项和下标为1的项值是1
  if (n == 0 || n == 1) return 1;
  // 斐波那契数列的本质特征就是每一项，等于前面两项的和
  return fib(n - 1) + fib(n - 2);
}

// 书写一个循环语句，计算斐波那契数列的前15项
for (var i = 0; i < 15; i++) {
  console.log(fib(i));
}
```

### 输出结果：

![image-20211224125244398](E:\coder\09_OneNote\image\image-20211224125244398.d5a6d4d9.png)

## 6、实现浅克隆

TIP

- 使用 `var arr2 = arr1` 这样的语句不能实现数组的克隆
- 浅克隆：准备一个空的结果数组，然后使用 for 循环遍历原数组，将遍历到的项都推入结果数组
- 浅克隆**只克隆数组的一层**，如果数组是多维数组，则克隆的项会 **"藕断丝连"**

```js
// 通过以下方式实现浅克隆
// 准备原数组
var arr1 = [22, 33, 55, 11, 66, [77, 88, 99]];
// 准备一个结果数组
var result = [];

// 遍历原数组，将遍历到的项都推入到结果数组中
for (var i = 0; i < arr1.length; i++) {
  result.push(arr1[i]);
}

// 输出结果数组
console.log(result); // [22, 33, 55, 11, 66]
// 测试是否实现了浅克隆，就是说本质上是内存中的不同数组了
console.log(arr1 == result); // false

// arr1.push(88);
// console.log(result); // result数组是不会受影响的，因为它们被分开了

// 测试这样的克隆是浅克隆，"藕断丝连"
arr1[5].push(100);
console.log(result); // [22, 33, 55, 11, 66, [77, 88, 99, 100]]
```

## 7、使用递归实现深克隆

TIP

使用 **递归思想**，整体思路和浅克隆类似，但稍微进行一些改动：

- 如果遍历到项是基本类型值，则直接推入结果数组；
- 如果遍历到的项是又是数组，则重复执行浅克隆的操作。

```js
// 原数组
var arr1 = [22, 11, 33, 55, [88, 66, [97, 61], 99]];

// 函数，这个函数会被递归（暂时不考虑对象，等以后学习了再讲）
function deepClone(arr) {
  // 结果数组，”每一层“ 都有一个结果数组
  var result = [];
  // 遍历数组的每一项
  for (var i = 0; i < arr.length; i++) {
    // 类型判断，如果遍历到的项是数组
    if (Array.isArray(arr[i])) {
      // 递归
      result.push(deepClone(arr[i]));
    } else {
      // 如果遍历到项不是数组，是基本类型值，就直接推入到结果数组中
      // 相当于是递归的出口
      result.push(arr[i]);
    }
  }
  // 返回结果数组
  return result;
}

// 测试一下
var arr2 = deepClone(arr1);
console.log(arr2);

// 测试是否藕断丝连
console.log(arr1[4] == arr2[4]); // false

arr1[4].push(88888);
console.log(arr2); // 数组的项么有被改变，深克隆成功

// 再测试
console.log(arr1[4][2] == arr2[4][2]);
arr1[4][2].push(56789);
console.log(arr1); // arr1被推入
console.log(arr2); // arr2 没有被推入，深克隆成功
```

# JS 中闭包的用途和最佳实践

本节内容围绕以下几方面展开

- 从什么是闭包 ？
- 闭包的用途，闭包的应用场景，缺陷或危害
- 以及常见闭包面试题

## 1、先通过一道题目，感受下闭包现象

```js
// 创建一个函数
function fun() {
  // 定义局部变量
  var name = "arry老师";
  // 返回一个局部函数
  return function () {
    console.log(name);
  };
}

// 调用外部函数，就能得到内部函数，用变量inn来接收
var inn = fun();

// 定义一个全局变量
var name = "icoding";

// 执行inn函数，就相当于在fun函数的外部执行了内部函数
inn(); // 输出 arry老师 成功了

// 虽然定义了全局变量，但依然输出了内部函数变量的值，这种现象就是闭包现象
```

## 2、什么是闭包 ？

TIP

- JavaScript 中函数会产生闭包（closure）
- 闭包 是 **函数本身** 和 **该函数声明时所处的环境状态**的组合
- 下图是模拟闭包的示意图，来辅助我们**对抽象的闭包具象化的理解**

![image-20211224231948096](E:\coder\09_OneNote\image\image-20211224231948096.0fa606a7.png)

**闭包的特性**

- **函数能够"记忆住"其定义时所处的环境**
- 即使函数不在其定义的环境中被调用，也能访问定义时所处环境的变量

```js
// 我们再来观察闭包的特性
function fun() {
  // 定义局部变量
  var name = "arry老师";
  // 定义局部函数，该函数本身也是一个闭包，是由它所处的环境决定的
  function innerFun() {
    console.log(name);
  }
  // 返回了内部函数
  return innerFun;
}

var inn = fun();
// 内部函数被移动到了外部执行
inn();

// 输出 arry老师，依然输出了内部函数变量的值
```

## 3、仔细观察闭包现象你会发现

TIP

- 在 JavaScript 中，每次创建函数时都会创建闭包。
- 但是，闭包特性 往往需要将函数"换一个地方" 执行，才能被观察出来

**闭包是非常实用的**

- 闭包很有用，因为它允许我们将数据与操作该数据的函数关联起来。这与 "面向对象编程" 有少许相似之处
- 闭包的功能：记忆性、模拟私有变量

## 4、闭包的第一个用途：记忆性

TIP

当闭包产生时，函数所处环境的状态 会始终保持在内存中，不会在外层函数调用后被自动清除，这就是闭包的 记忆性。

**我们使用闭包的记忆性来实现以下业务：**

- 创建提问检测函数 checkTemp(n)，可以检查体温 n 是否正常，函数会被返回布尔值，体温正常会返回`true`，体温不正常会返回`false`
- 但，不同的小区有不同的体温检测标准：
- 比如：A 小区体温合格线是 37.3℃，而 B 小区体温合格线是 37.0℃，应该怎样编程呢 ？

```js
// 闭包的记忆性（同时这样的函数也叫：高阶函数或偏函数，未来会学习）
// 形参 standardTemp 表示标准线体温
function createCheckTemp(standardTemp) {
  // 定义检测体温函数checkTemp() , 形参n表示用户的体温
  function checkTemp(n) {
    // 如果用户的体温小于等于标准线体温
    if (n <= standardTemp) {
      console.log("你的体温正常");
    } else {
      console.log("你的体温偏高");
    }
  }
  // 返回checkTemp函数
  return checkTemp;
}

// A小区，创建一个checkTemp函数，它以37.3度为标准线
// 当A小区检测体温调用createCheckTemp函数时，给形式参数standardTemp传入的值是 37.3
// 这时，这个checkTemp函数就能一直记忆住它的值是 37.3
// 为什么呢？因为这个形参standardTemp对于函数checkTemp来说，就是checkTemp的闭包
// 换句话说：对于checkTemp来说，它的闭包就是checkTemp本身和形式参数standardTemp，因为我们知道是函数和它所处的环境的组合，因此checkTemp就会一直记忆住传入的值，不会因为createCheckTemp函数执行完毕后，就忘记这个数字了
var checkTemp_A = createCheckTemp(37.3);

// B小区，再创建一个checkTemp函数，它以37.0度为标准线
var checkTemp_B = createCheckTemp(37.0);

checkTemp_A(37.1); // 你的体温正常
checkTemp_A(37.8); // 你的体温偏高

checkTemp_B(36.5); // 你的体温正常
checkTemp_B(37.1); // 你的体温偏高

// 根据以上函数的调用，我们可以看出只需传入一次A小区和B小区体温的标准线，checkTemp函数就会记忆住这个值
// 当用户输入体温后，即可进行判断，A和B小区是不会紊乱的，由此可见闭包是具有记忆性的
```

## 5、闭包的第二个用途：模拟私有变量

TIP

- 题目：请定义一个变量 a，`要求是能保证这个a只能被进行指定操作`（如：加 1、乘 2），而不能进行其他操作，应该怎么编程呢 ？
- 本质上这个题目的要求就是`要让变量a变得安全，即让变量变得私有化`
- 在 Java、C++等语言中，有私有属性的概念，`但是JavaScript中只能用闭包来模拟`。

```js
// 封装一个函数，这个函数的功能就是私有化变量
function fun() {
  // 定义一个局部变量 a
  var a = 0;

  // 返回一个对象
  return {
    getA: function () {
      return a;
    },
    add: function () {
      a++;
    },
    pow: function () {
      a *= 2;
    },
  };
}

var obj = fun();
// 如果想在fun函数外边使用变量a，唯一的方法就是调用getA()方法
console.log(obj.getA()); // 0
// 如果需要变量+1只能调用add方法
obj.add();
obj.add();
obj.add();
console.log(obj.getA()); // 调用三次obj.add(), 输出 3
obj.pow();
obj.pow();
obj.pow();
console.log(obj.getA()); // 调用三次obj.pow() ,输出 24

// 这时候，你会发现你在函数的外部是不能对变量a进行除已经定义过函数的其他操作（比如：对a进行 -1 除2这些操作，因为我们根本就没有定义过这些函数）
// 所以，这个案例就很好的说明了一个事实，就是可以用闭包来模拟私有变量
```

## 6、使用闭包的注意点，缺点或危害

TIP

- **不能滥用闭包**，否则会造成网页的性能问题，严重时可能会导致**内存泄漏**
- 所谓内存泄漏是指程序中已动态分配的内存由于某种原因未释放或无法释放
- 当然，所谓的内存泄漏**是在很多低级别的浏览器**（比如 IE 中）中才会出现，**高版本的浏览器基本不存在**
- 这也是面试题中常考的题目

## 7、闭包的经典面试题，以下代码的输出结果 ？

```js
function addCount() {
  var count = 0;
  return function () {
    count = count + 1;
    console.log(count);
  };
}

// fun1 和 fun2 是互不影响的，因此count变量都是0，最终各自都输出1
var fun1 = addCount();
var fun2 = addCount();
fun1(); // 1
fun2(); // 1

// 第二次调用，因为fun1 和 fun2是互不影响的，再次调用时由于闭包是有记忆性的，所以会在上一次的结果上再加1，因此输出2
fun2(); // 2
fun1(); // 2
```

# JS 防抖与节流应用场景和最佳实践

防抖和节流的作用：

- 都是在高频事件中防止函数被多次调用，是一种性能优化的方案。

**区别在于**：

- 防抖函数只会在高频事件结束后 n 毫秒调用一次函数
- 节流函数会在高频事件触发过程当中每隔 n 毫秒调用一次函数。

## 1、应用场景

常见的应用场景都是使用高频事件来调用函数的过程当中

- 比如：应用于 window 对象的 resize、scroll 事件，拖拽时的 mousemove 事件
- 文字输入、自动完成的 keyup 事件。

## 2、防抖的应用场景

场景

- scroll 事件滚动触发事件
- 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。
- 表单验证
- 按钮提交事件。
- 浏览器窗口缩放，resize 事件（如窗口停止改变大小之后重新计算布局）等。

## 3、节流的应用场景

场景

- DOM 元素的拖拽功能实现（mousemove）
- 搜索联想（keyup）
- 计算鼠标移动的距离（mousemove）
- Canvas 模拟画板功能（mousemove）
- 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）
- 监听滚动事件判断是否到页面底部自动加载更多

## 4、封装 防抖函数

TIP

触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。

```js
// 防抖函数
function debounce(func, wait) {
  let timeout = null;
  return function () {
    let context = this;
    let args = arguments;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}
```

## 5、封装 节流函数

TIP

规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效

```js
// 节流函数
function throttle(func, wait) {
  let timeout = null;
  return function () {
    let context = this;
    let args = arguments;
    if (!timeout) {
      timeout = setTimeout(() => {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

## 6、项目实际应用

```html
<head>
  <style>
    div {
      height: 150px;
      line-height: 150px;
      text-align: center;
      color: #fff;
      background-color: skyblue;
      font-size: 80px;
    }
    h2 {
      margin: 10px 0;
    }
    p {
      color: #666;
      margin: 20px 0;
    }
    p.title {
      font-size: 17px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <p class="title">
    说明：鼠标在以下元素不断移动，将会不断执行一个数值累加事件，但中间分别加入了防抖和节流函数。
  </p>
  <h2>防抖</h2>
  <p>在鼠标停止移动后300ms执行一次数值累加事件。</p>
  <div id="content">0</div>
  <h2>节流</h2>
  <p>在鼠标移动过程中，每300ms执行一次数值累加事件。</p>
  <div id="content2">0</div>
  <script>
    // 防抖函数
    function debounce(func, wait) {
      let timeout = null;
      return function () {
        let context = this;
        let args = arguments;
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(() => {
          func.apply(context, args);
        }, wait);
      };
    }

    // 测试 debounce 防抖函数
    let num = 1;
    let content = document.getElementById("content");
    function count() {
      content.innerHTML = num++;
    }
    content.onmousemove = debounce(count, 300);

    // 节流函数
    function throttle(func, wait) {
      let timeout = null;
      return function () {
        let context = this;
        let args = arguments;
        if (!timeout) {
          timeout = setTimeout(() => {
            timeout = null;
            func.apply(context, args);
          }, wait);
        }
      };
    }

    // 测试 throttle 节流函数
    let num2 = 1;
    let content2 = document.getElementById("content2");
    function count2() {
      content2.innerHTML = num2++;
    }
    content2.onmousemove = throttle(count2, 300);
  </script>
</body>
```

### 代码效果演示：

![image-20220407051123329](E:\coder\09_OneNote\image\image-20220407051123329.d9d48d01.png)

# TypeScript 面试题

关于

- TypeScript 面试题过程是根据自身项目实践以及查阅官方文档等最终的得出结论。
- 仅供学习参考，评论区感谢补充和纠错 ！

### 1、为什么越来越多的企业选择使用 TypeScript ？





随着 JavaScript 项目规模的扩大，它们变得难以维护，这有几个原因。

- 首先，JavaScript 从未设计用于构建大型应用程序，它最初的目的是为网页提供小型脚本功能。
- 直到现在，它还没有提供用于构建大型项目的工具和结构，例如类、模块和接口。
- 此外，JavaScript 是动态类型的。它不支持诸如 IntelliSense 之类的功能。

![image-20220325211448015](E:\coder\09_OneNote\image\image-20220325211448015-16526951579061.0adc3670.png)

TypeScript 文件使用`.ts 扩展名`，而 JavaScript 文件使用`.js 扩展名`

- 由于 TypeScript 是 JavaScript 的超集，所有有效的 JavaScript 代码都是有效的 TypeScript 代码，将 .js 文件重命名为 .ts 不会改变任何内容
- TypeScript 添加了可选的静态类型和语言特性，例如类和模块
- TypeScript 纯粹是一个编译时工具，编译后，我们将得到简单、普通的 JavaScript，TypeScript 设计目标是为开发大型应用而生的

```js
// 下边一个标准 TypeScript 程序的示例，该程序将两个数字相加并返回结果。
// 注意参数和返回类型是如何用它们的类型注释的。
function add(a: number, b: number): number {
  const sum = a + b;
  return sum;
}

// 当使用tsc命令编译TypeScript文件时，Typescript编译器会生成普通的JavaScript
// 以下代码，是编译器将为上述代码片段生成的内容
function add(a, b) {
  const sum = a + b;
  return sum;
}
```

### 2、TypeScript 中的原始类型有哪些 ？





TypeScript 具有三种常用的基本类型：字符串、数字和布尔值，这些对应于 JavaScript 中类似命名的类型。

- **string**：表示文本值，例如“javascript”、“typescript”等
- **number**：表示数值，如 1、2、25、36 等
- **boolean**：表示一个变量，它可以具有“真”或“假”值

![image-20220325215558108](E:\coder\09_OneNote\image\image-20220325215558108-16526952042623.cfc77cd0.png)

### 3、说说数组在 TypeScript 中是如何工作的 ？

- 我们使用数组来存储相同类型的值，数组是有序和索引的值集合
- 索引从 0 开始，即第一个元素的索引为 0，第二个元素的索引为 1，依此类推

```js
// 这是在 TypeScript 中声明和初始化数组的语法
let values: number[] = [];
values[0] = 10;
values[1] = 20;
values[2] = 30;

// 还可以使用以下简写语法创建数组
let values: number[] = [15, 20, 25, 30];

// TypeScript 提供了另一种语法来指定 Array 类型
let values: Array<number> = [15, 20, 25, 30];
```

### 4、什么是 any 类型，何时使用 ？



- 有时你想将值存储在变量中，但事先不知道该变量的类型
- 当你没有明确提供类型时，TypeScript 假定变量是 any 类型，并且编译器无法从周围的上下文中推断出类型

例如，该值来自 API 调用或用户输入。any 类型 允许你将任何类型的值分配给 any 类型的变量

```js
let person: any = "Foo";

// 以下是一个演示任何类型用法的示例

// json可能来自第三方API
const employeeData: string = `{"name": "arry老师", "salary": 60000}`;

// 解析JSON以构建employee对象
const employee: any = JSON.parse(employeeData);

console.log(employee.name);
console.log(employee.salary);
```

### 5、什么是 void，什么时候使用 void 类型 ？



- `void` 表示变量没有类型，它充当与任何相反的类型，它在不返回值的函数中特别有用
- 如果变量是 void 类型，则只能将 `null 或 undefined 值`分配给该变量。

```js
function notify(): void {
  alert("Hello World !");
}
```

### 6、TypeScript 中声明变量有哪些不同的关键字？

```js
// var：声明一个函数范围或全局变量，您可以选择在声明期间设置其值
// 它的行为和作用域规则类似于 JavaScript 中的 var 关键字，如：
var foo = "bar";

// let：声明一个块范围的局部变量，与 var 类似，你可以选择在声明期间设置变量的值。如：
let a = 5;
if (true) {
  let a = 10;
  console.log(a); // 10
}
console.log(a); // 5

// const：声明一个块范围的常量值，初始化后不能更改。如：
const a = 5;
if (true) {
  a = 10; // 错误：无法分配给“a”，因为它是常量
}
```

### 7、如何书写带有类型注释的函数 ？



- 函数是执行特定代码的代码块
- 函数可以有选择地接受一个或多个参数，处理它们，并有选择地返回一个值

```js
// 这是创建和调用函数的 TypeScript 语法
function greet(name: string): string {
  return `Hello, ${name}`;
}

let greeting = greet("arry老师");
console.log(greeting); // "Hello, arry老师"
```

### 8、如何在 TypeScript 中创建对象 ？



- 对象是类似字典的 keys 和 values 的集合，key 必须是唯一的。
- 它们类似于数组，有时也称为关联数组
- 但是，数组使用数字来索引值，而对象允许使用任何其他类型作为键

```js
// 在 TypeScript 中，Object 类型指的是任何具有属性的值,它可以通过简单地列出属性及其类型来定义，如：
let pt: { x: number, y: number } = {
  x: 10,
  y: 20,
};
```

### 9、如何在 TypeScript 中指定可选属性 ？



- 通过添加 `？`，对象类型可以具有零个或多个可选属性，在属性名称之后

```js
let pt: { x: number, y: number, z?: number } = {
  x: 10,
  y: 20,
};
console.log(pt);
```

在上面的例子中，因为属性 'z' 被标记为可选，如果我们在初始化期间不提供它，编译器不会报错

### 10、说说枚举在 TypeScript 中是如何工作的 ？

- 枚举允许我们创建命名常量，这是一种为数字常量值赋予更友好名称的简单方法
- 枚举由关键字 enum 定义，后跟其名称和成员

```js
// 该示例定义了一个包含四个值的枚举 Team

enum Team {
Alpha,
Beta,
Gamma,
Delta
}
let t: Team = Team.Delta;

// 默认情况下，枚举从 0 开始编号，可以通过将值显式分配给其成员来覆盖默认编号

// TypeScript 还允许你使用字符串值创建枚举
enum Author {
  arry = "arry老师",
  andy = "andy老师"
};
```

### 11、什么是参数解构 ？

- 参数解构，允许函数将作为参数提供的对象结构到一个或多个局部变量中

```js
function multiply({ a, b, c }: { a: number, b: number, c: number }) {
  console.log(a * b * c);
}

multiply({ a: 1, b: 2, c: 3 });

// 通过使用接口或命名类型，可以简化上述代码，如下所示：
type ABC = { a: number, b: number, c: number };

function multiply({ a, b, c }: ABC) {
  console.log(a * b * c);
}

multiply({ a: 1, b: 2, c: 3 });
```

### 12、说说 TypeScript 中 for 循环的不同变体

- TypeScript 提供了以下三种循环集合的方法

```js
// 'for' 循环
let values = [10, "foo", true];

for (let i = 0; i < values.length; i++) {
  console.log(values[i]); // 10, "foo", true
}

// 'forEach' 函数
let values = [10, "foo", true];
values.forEach((val) => {
  console.log(val); // 10, "foo", true
});

// 'for..of' 声明
let values = [10, "foo", true];
for (let val of values) {
  console.log(val); // 10, "foo", true
}
```

### 13、TypeScript 中控制成员可见性有几种方法 ？

TypeScript 提供了三个关键字来控制类成员的可见性

- **`public`**：您可以在 class 外的任何地方访问公共成员。默认情况下，所有类成员都是公共的。
- **`protected`**：受保护的成员仅对包含该成员的类的子类可见。不扩展容器类的外部代码无法访问受保护的成员。
- **`private`**：私有成员仅在类内部可见，没有外部代码可以访问类的私有成员。

### 14、TypeScript 支持静态类吗 ？为什么 ？

TypeScript 不支持静态类，

- 这与流行的 C# 和 Java 等面向对象的编程语言不同。
- 这些语言需要静态类，因为所有代码，即数据和函数，都需要在一个类中并且不能独立存在。静态类提供了一种方法来允许这些功能，而无需将它们与任何对象相关联。

在 TypeScript 中，你可以将任何数据和函数创建为简单对象，而无需创建包含类。

- 因此，TypeScript 不需要静态类，单例类只是 TypeScript 中的一个简单对象。