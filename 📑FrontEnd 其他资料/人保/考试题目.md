# 2022/11/23 补考总结

Js：5，6道；es：2，3道，动画：2道；css：引入样式2道；nginx，docker，zuul，Devops3，4道；Vue生命周期、数据渲染1道；时间复杂度2道；环境部署

## 单选

### 下面这段程序的显示结果是？

```js
var x = new Boolean(false);
if (x) {
  alert('hi'); 
}
var y = Boolean(0);
if (y) {
  alert('hello');  
}
```

```
A.Hi
B.hi hello
C.Hello
D.不显示
```

当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。

如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。

### 以下排序算法中，时间复杂度为0(N)的为（）

```A
A.直接插入
B.快速排序
C.冒泡排序
D.希尔排序
```

这道题要求选择时间复杂度为O(N)的排序算法。

选项A. 直接插入排序的时间复杂度为O(N^2)，因为在最坏情况下，每个元素需要依次与已排序序列中的元素比较和移动位置。

选项B. 快速排序的平均时间复杂度为O(NlogN)，最坏情况下为O(N^2)。因此，它不符合题目要求。

选项C. 冒泡排序的时间复杂度为O(N^2)，因为每个元素都需要与其他元素进行比较和交换位置。

选项D. 希尔排序的平均时间复杂度为O(NlogN)或者更好，最坏情况下为O(N^2)。因此，它也不符合题目要求。

### Generator函数的yield关键字的作用是：

```B
A.退出函数
B.暂停执行，等待 next() 方法调用
C.停止执行
D.停正执行，可自行恢复执行
```

### 关于 AlertDialog 描述错误的是

```B
A.show() 方法创建并显示对话框
B.AlertDialog.Builder 的 create() 和 show() 方法都返回 AlertDialog 对象
C.AlertDialog 不能直接用 new 关键字构建对象，而必须使用其内部类 Builder
D.create() 方法创建并显示对话框
```

AlertDialog 是一个用于显示警告或提示信息的对话框组件，常用于 Android 应用程序开发中。它是 Android 系统提供的一种内置对话框类型，可以用于显示消息、确认用户操作、获取用户输入等功能。

AlertDialog 可以包含标题、消息内容、按钮以及其他可选的交互元素。通过创建 AlertDialog 实例并设置相应的属性，可以自定义对话框的外观和行为。

以下是使用 AlertDialog 的一般步骤：

1. 创建 AlertDialog.Builder 对象：通过实例化 AlertDialog.Builder 类来创建一个 AlertDialog 对象的构建器。

2. 设置对话框属性：使用构建器对象的方法来设置对话框的标题、消息内容、图标、按钮等属性。

3. 设置按钮点击监听器：为对话框上的按钮设置点击事件的监听器，以响应用户的操作。

4. 创建和显示对话框：调用构建器的 `create()` 方法来创建 AlertDialog 对象，然后调用 `show()` 方法显示对话框。

通过这些步骤，可以创建一个自定义的 AlertDialog 对话框来满足应用程序的需求，并与用户进行交互。

### [1,2,[3,[4,5]]].flat 的结果

```js
[1,2,[3,[4,5]]].flat // [1,2,3,[4,5]]
```

### 要运用css3动画，你需要运用什么规则？

```A
A.keyframes
B.Animation
C.Flash
D.transition
```

### HTML5中不再支持哪些元素？

1. `<applet>`：用于嵌入 Java Applet 的元素。现在应该使用更现代的技术，如JavaScript和HTML5的Canvas或WebGL。
2. `<acronym>`：用于定义首字母缩略词。现在应该使用更语义化的标签，如 `<abbr>`。
3. `<basefont>`：用于设置基本字体大小和颜色。现在应该使用 CSS 来控制字体样式。
4. `<big>`：用于定义大号文本。现在应该使用 CSS 来控制文本的大小。
5. `<center>`：用于居中对齐内容。现在应该使用 CSS 来实现布局和对齐。
6. `<font>`：用于设置字体相关属性。现在应该使用 CSS 来控制字体样式。⭐
7. `<frame>` 和 `<frameset>`：用于创建网页框架。现在应该使用更现代的布局技术，如 `<div>` 元素和 CSS。⭐
8. `<strike>` 和 `<s>`：用于定义删除线文本。现在应该使用 CSS 来控制文本的样式。
9. `<tt>`：用于定义打字机文本。现在应该使用 CSS 来控制文本的样式。

### 不属于补间动画：FrameAnimation

FrameAnimation 是通过连续切换一系列静态帧图像来创建动画效果。FrameAnimation 通常使用 GIF 或精灵图（Sprite Sheet）的形式来实现。

CSS 补间动画（CSS Transitions）是一种在浏览器中使用 CSS 属性进行动画过渡的技术。以下是一些常见的 CSS 补间动画属性：

1. `transition-property`：指定要应用过渡效果的 CSS 属性名称。
2. `transition-duration`：指定过渡的持续时间。
3. `transition-timing-function`：指定过渡的时间函数，控制动画的加速和减速效果。
4. `transition-delay`：指定过渡的延迟时间。
5. `transition`：可以用于简写上述四个过渡属性的属性缩写形式。

通过组合使用这些属性，可以创建各种类型的 CSS 补间动画效果，包括：

- 淡入淡出效果（Opacity）
- 缩放效果（Scale）
- 旋转效果（Rotate）
- 移动效果（Translate）
- 渐变效果（Color）
- 边框效果（Border）

这些属性和效果可以通过设置不同的起始状态和结束状态，配合适当的过渡属性值，来实现平滑的动画过渡效果。通过 CSS 补间动画，可以在不使用 JavaScript 或其他动画框架的情况下，使用纯 CSS 实现动画效果。

### Web诞生在哪个时期

Web（万维网）诞生于 1990 年代初期（二十世纪九十年代）。

Web 的起源可以追溯到 1989 年，由英国科学家蒂姆·伯纳斯-李（Tim Berners-Lee）提出的构想。他在 CERN（欧洲核子研究组织）工作期间，提出了一种基于超文本和互联网的信息共享系统的概念，这就是 Web 的雏形。

在 1990 年，蒂姆·伯纳斯-李发明了第一个 Web 服务器和客户端浏览器，并创建了第一个 Web 页面。他使用了 HTML（超文本标记语言）来描述和组织页面内容，并使用了 HTTP（超文本传输协议）来进行页面的传输和交互。

随着时间的推移和技术的发展，Web 在 1990 年代逐渐普及。万维网的发展对互联网的普及和信息共享产生了深远的影响，开启了一个全新的数字时代。

### 在 Vue 组件的生命周期中，数据渲染并上树的过程发生在哪里？

在 Vue 组件的生命周期中，数据渲染并上树的过程发生在 `mounted` 钩子函数期间。

下面是有关 Vue 组件生命周期中的三个钩子函数的说明：

1. `beforeCreate` 钩子函数在组件实例被创建之初被调用。在这个阶段，组件实例已经被初始化，但是数据观测（data observation）和事件机制尚未设置。因此，在 `beforeCreate` 钩子函数中，无法访问到组件的 `data` 数据和其他实例属性。

2. `beforeMount` 钩子函数在组件挂载之前被调用。在这个阶段，模板已经编译完成，但是尚未将组件实例挂载到 DOM 上。因此，在 `beforeMount` 钩子函数中，你可以访问到组件的模板内容，但是无法访问到挂载后的 DOM 元素。

3. `mounted` 钩子函数在组件挂载到 DOM 后被调用。在这个阶段，组件已经挂载到 DOM 上，可以访问到组件的挂载后的 DOM 元素。同时，组件的数据已经被渲染到 DOM 中，可以进行相关的操作和交互。

因此，在 `mounted` 钩子函数期间，数据已经完成渲染并成功上树，此时可以进行 DOM 操作、请求数据、订阅事件等。

### zuul拦截器

Zuul 拦截器是在 Netflix 的开源网关框架 Zuul 中使用的组件，用于实现对进入网关的请求和出去的响应进行拦截和处理的机制。

Zuul 是一个基于 JVM 的动态路由和过滤器网关，用于在微服务架构中提供请求路由、负载均衡、安全认证、限流等功能。而 Zuul 拦截器则是 Zuul 网关的核心功能之一，用于对请求和响应进行拦截和处理。

通过编写自定义的 Zuul 拦截器，你可以在请求经过网关之前或响应返回给客户端之前，执行一些额外的逻辑操作。拦截器可以用于鉴权、认证、请求转发、日志记录、请求修改等各种场景。你可以根据自己的需求定义和配置多个拦截器，它们按照定义的顺序依次执行。

⭐⭐⭐以下是 Zuul 网关的一些常见拦截器类型：

1. 前置拦截器（Pre Filter）：在请求路由到目标服务之前执行的拦截器。可以用于鉴权、认证、请求转发等前置处理逻辑。

2. 路由拦截器（Route Filter）：用于执行实际的路由逻辑，将请求发送到目标服务。可以进行负载均衡、请求重试等处理。

3. 后置拦截器（Post Filter）：在目标服务响应返回给客户端之前执行的拦截器。可以对响应进行修改、日志记录等后置处理操作。

4. 错误拦截器（Error Filter）：用于处理路由过程中产生的错误，例如目标服务不可用、超时等。可以进行统一的错误处理、日志记录等操作。

### 读取文件内容的首要方法

```D
A.openFileOutput
B.Read
C.Write
D.openFileInput
```

解析题目：题目要求找出读取文件内容的首要方法。

正确答案是 D. `openFileInput`。

`openFileInput` 方法是 Android 中用于读取应用内部存储目录下的文件内容的方法。通过该方法打开文件输入流后，可以使用读取流的方式读取文件内容。

A. `openFileOutput` 是用于写入文件内容的方法，而非读取文件内容。

B. `Read` 不是 Android 中的文件读取方法，可能是一个错误选项。

C. `Write` 也不是 Android 中的文件读取方法，可能是一个错误选项。

因此，D. `openFileInput` 是读取文件内容的首要方法。

### 以下不属于把CSS样式表与HTML网页关联的方法

```A
A.在HTML文档的＜!--…--＞标签内定义CSS样式
B.用＜link＞标签链接网上可访问的CSS样式表文件
C.在HTML文档的＜head＞标签内定义CSS样式
D.用＠import引入样式表文件
```

### 使用nginx将http请求转发请求到后端服务，后端服务不可用的时候会返回什么状态码？

```D
A.400
B.404
C.500
D.502
```

在使用 Nginx 将 HTTP 请求转发到后端服务时，如果后端服务不可用，Nginx 会返回 D. 502 Bad Gateway 状态码。

A. 400 Bad Request：表示客户端发送的请求存在语法错误或不合理。

B. 404 Not Found：表示客户端请求的资源在服务器上未找到。

C. 500 Internal Server Error：表示服务器在处理请求时遇到了内部错误。

D. 502 Bad Gateway：表示代理服务器（即 Nginx）作为网关或代理，无法从上游服务器（即后端服务）获得有效的响应。这通常意味着后端服务无法正常响应请求，可能是由于后端服务故障、宕机、网络连接问题等原因导致。

通过返回 502 Bad Gateway 状态码，Nginx 向客户端指示请求的后端服务不可用，并且客户端可以根据此状态码进行相应的处理，例如进行错误处理、重试请求等。

### 如下代码输出的结果是什么

```
console.log(1+ "2"+"2");
console.log(1+ +"2"+"2");
console.log("A"- "B"+"2");
console.log("A"- "B"+2);
```

```
A.122 122 NaN NaN
B.122 32 NaN NaN2
C.122 32 NaN2 NaN
D.122 32 NaN2 NaN2
```

### [...a,b]，a，b的值？

注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

### Docker启动流程

Docker 是一种开源的容器化平台，用于构建、部署和运行应用程序。它利用容器化技术将应用程序及其依赖项打包到一个独立的、可移植的容器中，提供了一种轻量级、快速部署的解决方案。

Docker 的启动流程如下：

1. 编写 Dockerfile：Dockerfile 是一个文本文件，用于定义 Docker 镜像的构建过程。在 Dockerfile 中，你可以指定所需的基础镜像、安装依赖、配置环境、拷贝文件等操作。

2. 构建镜像：使用 Docker 命令行工具执行 `docker build` 命令，根据 Dockerfile 构建 Docker 镜像。该命令会根据指定的 Dockerfile 执行每一条指令，生成一个包含应用程序及其运行环境的镜像。

3. 运行容器：使用 `docker run` 命令启动容器，基于构建好的镜像创建一个运行实例。在运行容器时，可以指定端口映射、挂载数据卷、设置环境变量等配置。

4. 应用程序运行：容器启动后，Docker 会在容器中运行应用程序，并提供访问接口。应用程序可以在容器内部以与在物理机或虚拟机上运行时相同的方式运行。

总结起来，Docker 的启动流程包括编写 Dockerfile 定义镜像构建过程，使用 Docker 构建镜像，运行容器并启动应用程序。通过容器化的方式，应用程序可以在各种环境中以一致的方式运行，并且容器之间相互隔离，提供更高的可移植性、可靠性和效率。

### Vue-router路由信息保存在哪里？

在 Vue.js 中，Vue Router 的路由信息保存在路由器实例的 `routes` 属性中。`routes` 是一个数组，包含了定义的所有路由配置信息。

每个路由配置对象包含了路由的路径、组件、元数据等信息。下面是一个示例：

```javascript
import { createApp } from 'vue';
import { createRouter, createWebHistory } from 'vue-router';
import Home from './components/Home.vue';
import About from './components/About.vue';

const router = createRouter({
  history: createWebHistory(),
  routes: [
    { path: '/', component: Home },
    { path: '/about', component: About }
  ]
});

const app = createApp(App);
app.use(router);
app.mount('#app');

```

在上述示例中，`routes` 数组包含了两个路由配置，分别是根路由 `'/'` 和关于页路由 `'/about'`。每个路由配置包括了路径（`path`）和对应的组件（`component`）。

通过 `createRouter` 函数创建的 `router` 对象中包含了 `routes` 数组以及其他路由相关的属性和方法，用于管理和控制路由的跳转、导航等操作。

## 多选

### 以下哪三种使用CSS来格式化网页的方式

```
A.在HEAD中引用
B.作为标记来引用
C.在BODY中引用
D.作为文件来引用。
```

### 当用户打开一个网页时，想一直停留在当前打开的页面，禁止页面前进和后退，以下==不正确==的是

```BC
A.window.history.forward(1)；
B.window.history.back(1)
C.window.history.go(-1)
D.window. history.forward(-1);
```

B选项`window.history.back(1)`是用于返回到前一个页面。 C选项`window.history.go(-1)`也是用于返回到前一个页面。

A选项`window.history.forward(1)`用于前进到下一个页面。 D选项`window.history.forward(-1)`虽然参数是负数，但仍然是用于前进到下一个页面，因为`forward()`方法的参数是一个整数，表示前进或后退的步数。`window.history.forward()` 方法不接受负数参数。

### 下面哪些是线程安全的

```AB
A.Vector
B.ConcurrentHashMap
C.Arraylist
D.LinkedList
```

A. Vector
B. ConcurrentHashMap

选项 A. Vector 和选项 B. ConcurrentHashMap 是线程安全的数据结构。

Vector 是一个动态数组，它提供了同步方法来确保在多线程环境下的线程安全性。它的方法使用了同步锁来保证线程之间的互斥访问，因此可以安全地在多个线程中使用。

ConcurrentHashMap 是 Java 中的一个线程安全的哈希表实现。它采用了锁分段技术，将数据分成多个段（Segment），每个段维护自己的锁。这种设计允许多个线程同时读取和写入不同的段，从而提高并发性能。

选项 C. ArrayList 和选项 D. LinkedList 都不是线程安全的。它们没有内置的同步机制，因此在多线程环境下同时修改它们可能会导致数据不一致或并发访问异常。

如果需要在多线程环境下使用 ArrayList 或 LinkedList，可以通过使用外部同步手段（如使用 Collections.synchronizedList 方法）来实现线程安全。

### 以下选项中，不属于分布式源代码控制工具的是:

```
A.GitLab
B.GitHub
C.SVN
D.CVS
```

不属于分布式源代码控制工具的选项是 C. SVN（Subversion）和 D. CVS（Concurrent Versions System）。

A. GitLab 和 B. GitHub 都是常见的分布式源代码控制工具，用于版本控制和协作开发。

C. SVN 是集中式源代码控制工具，与分布式控制工具相比，它的工作方式略有不同。

D. CVS 也是集中式源代码控制工具，它在早期被广泛使用，但目前已经被更现代的工具所取代。

### nginx的常见使用

```AD
A.作为Web服务器
B.作为java服务器
C.正向代理
D.反向代理
```

ChatGPT给的答案：Nginx 是一个常见的开源软件，主要用于以下用途：

A. 作为Web服务器：Nginx 可以作为静态或动态内容的 HTTP 服务器，处理客户端的请求，并向客户端提供网页、图像、视频等内容。

C. 正向代理：Nginx 可以作为正向代理服务器，通过中间人的方式转发客户端请求，并将响应返回给客户端，隐藏了真实的服务器。

D. 反向代理：Nginx 也可以作为反向代理服务器，接收客户端的请求，并将请求转发给后端的服务器，然后将后端服务器的响应返回给客户端。

B 选项 "作为java服务器" 不是 Nginx 的常见使用方式，因为 Nginx 本身并不直接支持 Java 应用程序的执行。Java 应用程序通常需要使用 Java Servlet 容器（如 Tomcat、Jetty）来运行。

因此，正确的选项是 A 、C 和 D。

### 添加样式的方式

```ABCD
A.外部引用式：即将样式单独放到一个文件夹中，然后用link标签引入页面的形式。如:link rel="stylesheet" type
B.嵌入式：即用<style>.classname{width:100px;}</style>标签括起来写在页面中的样式
C.导入样式：@import url(css/style.css)
D.内联式：即直接加在标签上的样式如：<div style="width.100px:"></div>
```

### 下列哪些属于ECMAScript包含的数据类型

```ABD
A.Object
B.NulL
C.Double
D.Undefined
```

ECMAScript 是 JavaScript 的规范标准，它定义了一种基本的数据类型集合。根据 ECMAScript 的规范，包含的数据类型有：

A. Object：对象是 ECMAScript 中最常见的数据类型，它可以表示复杂的数据结构。

B. Null：null 是表示空值或者空对象引用的特殊值。

C. Double 并不是 ECMAScript 包含的数据类型。它通常用于表示双精度浮点数（即双精度小数）的数据类型。ECMAScript 中的数字类型是 Number，用于表示整数和浮点数。

D. Undefined：undefined 是表示未定义值的特殊值，当变量声明但没有赋值时，会被默认设置为 undefined。

### Docker组件都有哪些

```ABCD
A.仓库
B.镜像
C.容器
D.dockfile
```

A. 仓库（Registry）：Docker 仓库是用于存储和分享 Docker 镜像的中央存储库。其中最常见的是 Docker Hub，它是一个公共的 Docker 仓库，包含了大量的官方和社区维护的镜像。

B. 镜像（Image）：Docker 镜像是一个只读的模板，用于创建 Docker 容器。它包含了运行应用程序所需的所有文件、依赖和配置。镜像可以通过构建（Build）或者拉取（Pull）的方式获取。

C. 容器（Container）：Docker 容器是基于 Docker 镜像创建的运行实例。每个容器都是独立的、可移植的单元，包含了应用程序及其所有依赖项。容器可以被启动、停止、删除等操作，同时也可以与其他容器或宿主机进行通信。

D. Dockerfile：Dockerfile 是一个文本文件，用于定义和构建 Docker 镜像的自动化脚本。它包含了一系列指令，用于描述如何从一个基础镜像构建新的镜像，并设置各种配置选项、添加文件、运行命令等。

因此，正确答案是 A. 仓库，B. 镜像，C. 容器，D. Dockerfile。其中 A、B、C、D 是核心组件。

### 以下哪些手段对优化前端页面展现速度有益

```ABCD
A.GziP
B.优化资源加载顺序
C.减少HTTP请求
D.使用浏览器缓存策略
```

A. Gzip：使用 Gzip 压缩可以减小前端资源（如 CSS、JavaScript 文件）的大小，从而加快下载速度。

B. 优化资源加载顺序：通过合理安排资源加载顺序，例如将关键资源放在首位、异步加载非关键资源等，可以提高页面的展现速度。

C. 减少 HTTP 请求：减少页面中的 HTTP 请求次数可以显著提升页面加载速度。这可以通过合并和压缩文件、使用 CSS 精灵图、使用字体图标等方式实现。

D. 使用浏览器缓存策略：利用浏览器缓存可以减少对服务器的请求，从而加快页面加载速度。合理设置缓存头和缓存策略，使得页面资源能够在浏览器端进行缓存，提高页面的响应速度。

因此，正确答案是 A. Gzip、B. 优化资源加载顺序、C. 减少 HTTP 请求和 D. 使用浏览器缓存策略。

## 判断

```
1.使用Nginx作为正向代理，支持代理HTTP站点和HTTPS站点。

2.JavaScript 语言的对象继承是通过接口继承实现的。

3.脚手架是一种创建项目初始文件的工具。

4.在JavaScript中介者模式中，消息统一由中介者对象发布，所有订阅者对象间接被中介者管理。
```

1. 正确。Nginx 可以作为正向代理，支持代理 HTTP 和 HTTPS 站点。通过配置适当的代理规则，Nginx 可以接收客户端请求并转发到目标站点，实现代理功能。

2. 错误。JavaScript 语言的对象继承是通过原型链继承实现的，而不是通过接口继承。JavaScript 中的对象可以通过原型链关系，继承其他对象的属性和方法。

3. 正确。脚手架是一种用于创建项目初始文件和目录结构的工具。它可以提供项目的基本框架和配置，使开发人员可以快速开始开发，避免重复的初始化工作。

4. 正确。在 JavaScript 中的中介者模式，也称为发布-订阅模式或事件模式，中介者对象充当了消息的发布者和订阅者之间的调度者。消息的发布者不直接与订阅者进行通信，而是通过中介者来发布消息，中介者负责将消息传递给相关的订阅者对象，实现对象间的解耦和集中管理。

# 2022/11/22 补考总结

这次考试相比前几次相对容易，没有新增知识点，主体以nginx（15+），JavaScript，html，css三者结合（10-15），剩下部分判断大部分是测试，ios/android(1-2),未出现设计模式相关考题。

前端题有十七道，nginx大概有7道，正则有1道,构建有3道，ativity 1道，Devops，AsyncTask，LAMP，度量指标，变更追溯，测试，sql语句。

## 单选

### 在Android工程中新建了一个activity，需要在哪个xml文件中声明一下

```D
A.layout.xml
B.Main.xml
C.String.xml
D.AndroidMainifest.xml
```

在 Android 工程中新建一个 Activity，需要在 D. AndroidManifest.xml 文件中进行声明。

AndroidManifest.xml 是 Android 应用程序的清单文件，它包含了应用程序的元数据和配置信息，包括应用程序的组件（如 Activity、Service、BroadcastReceiver）声明、权限声明、应用程序的名称、图标等信息。

在 AndroidManifest.xml 中，可以使用 `<activity>` 元素来声明新建的 Activity。在 `<activity>` 元素中，需要指定 Activity 的名称、标签、主题等属性。这样，Android 系统才能够正确识别和启动这个新建的 Activity。

### 下面哪一个不属于js的六种基本数据类型？

```C
A.Null
B.Undefined
C.Object
D.String
```

### 下列不属于service生命周期的方法是？

```D
A.onCreate
B.onBind
C.onDestroy
D.onStop
```

在 Android 中，Service 是一种用于执行长时间运行操作或在后台处理任务的组件。Service 具有以下生命周期方法：

1. onCreate(): 当 Service 被创建时调用。在该方法中，可以进行初始化操作和准备资源的加载。

2. onStartCommand(Intent intent, int flags, int startId): 当调用 startService() 方法启动 Service 时调用。在该方法中，可以处理需要在后台执行的任务。返回值用于指定 Service 的行为，例如在被系统杀死后如何重启等。

3. onBind(Intent intent): 当调用 bindService() 方法绑定 Service 时调用。在该方法中，可以返回一个 IBinder 接口的实现，用于客户端与 Service 进行通信。

4. onUnbind(Intent intent): 当调用 unbindService() 方法解绑 Service 时调用。在该方法中，可以进行资源释放和清理操作。

5. onDestroy(): 当 Service 被销毁时调用。在该方法中，可以释放所有资源，停止后台任务等。

需要注意的是，Service 的生命周期是由客户端的操作（如启动、绑定、解绑等）以及系统的资源情况来决定的。系统可能会根据需要销毁或重新创建 Service。

这些生命周期方法提供了在 Service 的不同阶段执行逻辑和资源管理的机会，以便开发者可以控制和优化 Service 的行为和性能。

### 执行结果

```js
Var i=2，
for（var i=0,i<10,i++）{};
console.log(i) // 10
```

输出结果为 10。在 `for` 循环中重新定义了变量 `i`，因此会影响到外部定义的同名变量。这种变量声明会提升到函数或全局作用域的顶部，所以外部的 `var i=2` 实际上被覆盖了。如果想要避免这种情况，可以使用 `let` 或 `const` 关键字来声明变量，以创建块级作用域。

### 程序输出

```js
var a="undefined";
var b="false";
var c="";
function assert(aVar){
  if(aVar)     
    alert(true);
  else  
    alert(false);
}
assert(a);
assert(b);
assert(c);
```

```B
A.true，true，true
B.true，true，false
C.false，false，true
D.false，false，false
```

### 下列代码中hasOwnProperty的作用是？

```
var obj={}
obj.hasOwnProperty("val")
```

```B
A.判断obj对象是否具有val的值
B.判断obj对象是否具有val属性
C.判断obj的原型对象是否具有val的属性
D.判断obj的原型对象是否具有val的值
```

`hasOwnProperty()` 是 JavaScript 中的一个对象方法，用于检查对象是否具有指定的属性。

### 块级元素有哪些？

在 HTML 中，常见的块级元素包括：

1. `<div>`：定义一个文档区块。

2. `<p>`：定义段落。

3. `<h1>` - `<h6>`：定义标题，其中 `<h1>` 是最高级别的标题，而 `<h6>` 是最低级别的标题。

4. `<ul>`：定义无序列表。

5. `<ol>`：定义有序列表。

6. `<li>`：定义列表项，在无序列表或有序列表中使用。

7. `<table>`：定义表格。

8. `<form>`：定义表单。

9. `<header>`：定义页面或区块的页眉。

10. `<footer>`：定义页面或区块的页脚。

11. `<section>`：定义文档中的节（section）。

12. `<article>`：定义独立的文章内容。

13. `<nav>`：定义导航链接的容器。

14. `<aside>`：定义页面的侧边栏内容。

15. `<blockquote>`：定义块引用。

这只是块级元素的一些常见示例，还有其他的块级元素。块级元素通常会在页面上==显示为一个独立的块，并会独占一行或一块空间。==

### BOM 的核心对象是？

```C
A.Location
B.History
C.Window
D.Screen
```

1. Location（位置）对象提供了与当前窗口加载的文档相关的信息和操作。它包含了 URL、主机名、路径、查询参数等信息，可以用于获取和修改当前窗口的 URL 地址。

2. History（历史）对象用于管理浏览器窗口的浏览历史记录。它提供了向前和向后导航、加载指定页面、获取当前历史记录状态等功能。

3. Window（窗口）对象是 BOM 的核心对象，代表了一个浏览器窗口或一个框架。它提供了许多方法和属性，用于控制和操作浏览器窗口，包括打开和关闭窗口、弹出对话框、定时器、框架之间的通信等。

4. Screen（屏幕）对象提供了关于用户屏幕的信息，如屏幕尺寸、颜色深度等。它可以用于根据屏幕大小进行布局调整或提供与屏幕相关的功能。

### html5中不在支持下面那个元素

```D
A.P
B.Ins
C.Menu
D.Font
```

A. P（段落）是HTML标签中的一个元素，用于定义段落文本。

B. Ins（插入）是HTML标签中的一个元素，用于表示插入的文本，通常会带有下划线或其他样式来标识新添加的内容。

C. Menu（菜单）是HTML标签中的一个元素，用于定义菜单列表。

D. Font（字体）是HTML标签中的一个元素，用于指定文本的字体样式，包括字体类型、大小、颜色等。

### 哪些方法不可用于显示指定目标组件（Android）

```C
A.setClass（）
B.setComponent()
C.getClassName()
D.setClassName()
```

A. setClass() 方法：这个方法并不常见，可能是指在特定框架或库中使用的自定义方法，因此无法确定其功能和可用性。

B. setComponent() 方法：这个方法可能是拼写错误，正确的拼写应该是 setComponent()。然而，没有一个常见的标准方法名为 setComponent()，用于显示指定目标组件。

C. getClassName() 方法：这个方法用于获取对象的类名，但它与显示指定目标组件无关。通常，用于显示指定目标组件的方法可能会涉及到查找、选择、设置或更新组件的属性、样式、位置等。

D. setClassName() 方法：这个方法用于设置对象的类名，但它与显示指定目标组件也无关。类名通常用于为组件应用特定的样式或选择器。

### 执行Array.from(‘hello’)后，字符串变为

```A
A.['h', 'e', 'l', 'l', 'o']
B.['hello']
C.Hello''
D.['h']
```

Array.from() 是 JavaScript 中的一个静态方法，用于从可迭代对象（iterable）或类数组对象创建一个新的数组实例。可以通过指定映射函数对元素进行转换或处理。

语法：`Array.from(iterable, mapFn, thisArg)`

参数：

`iterable`：必需，一个可迭代对象或类数组对象，用于转换成数组。

`mapFn`（可选）：一个映射函数，用于对数组中的每个元素进行转换或处理。

`thisArg`（可选）：执行 mapFn 时的 this 值。

返回值：一个新的数组实例，其中包含从可迭代对象或类数组对象转换而来的元素。

示例用法：
1. 从字符串创建数组：
   ```javascript
   const str = 'hello';
   const arr = Array.from(str);
   console.log(arr); // ['h', 'e', 'l', 'l', 'o']
   ```

2. 从类数组对象创建数组：
   ```javascript
   const nodeList = document.querySelectorAll('p');
   const arr = Array.from(nodeList);
   console.log(arr); // [p1, p2, p3, ...]（包含所有选中的 <p> 元素）
   ```

3. 使用映射函数进行转换：
   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const squared = Array.from(numbers, x => x * x);
   console.log(squared); // [1, 4, 9, 16, 25]
   ```

### vue.js中用于在表单元素创建双向绑定的指令是？

```B
A.v-if
B.v-model
C.v-bind
D.v-binding
```

A. v-if 是用于条件性地渲染元素的指令，它根据指定的表达式的真假来决定是否渲染该元素。

B. v-model 是用于在表单元素（如 input、select、textarea）和 Vue.js 实例的数据之间创建双向数据绑定的指令。它将表单元素的值与 Vue.js 数据对象的属性进行关联，实现数据的同步更新。

C. v-bind 是用于绑定 HTML 特性的指令，它可以动态地将指定的属性绑定到 Vue.js 实例的数据或计算属性上。

D. v-binding 并不是 Vue.js 中的有效指令。

### 下列全部属于css单位是？

```D
A.pt sp px
B.Px dp %
C.Sp dp %
D.% px em
```

- pt（point）：用于打印的绝对长度单位，通常用于印刷和排版领域。
- sp（scalable point）：类似于 pt 单位，但会根据用户设置的字体大小进行缩放，主要用于屏幕上的文本显示。
- px（pixel）：像素单位，相对于显示设备上的一个物理像素。
- dp（density-independent pixel）：密度无关像素，用于在 Android 开发中表示长度，与像素密度相关，适应不同屏幕密度的设备。
- %（百分比）：相对于父元素的尺寸进行计算的相对单位。
- em：相对长度单位，相对于当前元素的字体大小，也可以继承父元素的字体大小。

### margin属性设置边距的顺序是？

```C
A.左右上下
B.上下左右
C.上右下左
D.下右上左
```

```css
margin: 10px 20px; /* 上下为10像素，左右为20像素 */
margin: 10px 20px 30px; /* 上为10像素，左右为20像素，下为30像素 */
margin: 10px 20px 30px 40px; /* 上为10像素，右为20像素，下为30像素，左为40像素 */
```

### math.clz32()的返回值？

```A
A.32
B.0
C.NAN
D.Undefined
```

`Math.clz32()` 是 JavaScript 中的一个静态方法，用于返回一个数的 32 位二进制表示中的==前置零的数量==。返回值范围是 0 到 32。

示例用法：
```javascript
console.log(Math.clz32(1));     // 31  (二进制表示：00000000000000000000000000000001，前导零的数量：31)
console.log(Math.clz32(100));   // 25  (二进制表示：00000000000000000000000001100100，前导零的数量：25)
console.log(Math.clz32(1000));  // 22  (二进制表示：00000000000000000000001111101000，前导零的数量：22)
console.log(Math.clz32(10000)); // 19  (二进制表示：00000000000000000011000011010000，前导零的数量：19)
console.log(Math.clz32(0));     // 32  (二进制表示：00000000000000000000000000000000，前导零的数量：32)
```

### DOM事件流将事件分为哪几个阶段？

```A
A.捕获阶段 目标阶段 冒泡阶段
B.冒泡阶段 目标阶段 捕获阶段
C.捕获阶段 目标阶段 触发阶段
D.捕获阶段 冒泡阶段 触发阶段
```

### HTML5中不支持的视频有

```D
A.Ogg
B.Mp4
C.Webm
D.Flv
```

HTML5 中支持的常见视频格式：

1. MP4（MPEG-4 Part 14）：这是一种常见的视频容器格式，广泛支持并被大多数现代浏览器所支持。

2. WebM：这是一种开放的多媒体容器格式，支持高质量的视频和音频编码。它是由Google推出的，并得到了现代浏览器的广泛支持。

3. Ogg：这是一种免费开放的媒体容器格式，支持音频和视频编码。Ogg Vorbis 是一种常见的音频编码格式，Ogg Theora 是一种常见的视频编码格式。

请注意，尽管 HTML5 支持这些视频格式，但具体支持哪种格式取决于用户的浏览器和操作系统。因此，在使用视频时，建议提供多个格式的视频源以确保在各种浏览器和设备上的兼容性。

## 多选

### oocss的基本原则有哪些？

```BD
A. 分离容器和内容
B. 分离结构和外观
C. 分离容器和外观
D. 分离结构和内容
```

OOCSS（Object-Oriented CSS，面向对象的 CSS）是一种组织和编写可重用、可扩展的 CSS 的方法论。它强调将样式抽象为可重复使用的组件和对象，以提高代码的可维护性和可扩展性。OOCSS 的基本原则包括：

1. 分离结构和样式：将 HTML 结构与样式分离，避免将样式信息直接嵌入到 HTML 标签中，而是使用类名或选择器来定义样式。

2. 拆分样式和内容：将样式定义为独立的类或对象，而不是与特定的 HTML 内容耦合。样式应该可重用于不同的 HTML 结构，增加样式的灵活性和复用性。

3. 使用模块化和可重用的组件：将样式抽象为可重复使用的组件或对象。通过定义一致的样式模块，可以在不同的页面和应用中重复使用，并减少代码的冗余。

4. 保持样式的通用性：避免使用具体的、与特定上下文相关的样式，而是使用更通用的样式定义。这样可以使样式更具灵活性，适应不同的上下文和布局。

5. 使用层叠和继承：通过层叠和继承的方式来构建样式。通过继承和扩展基础样式，可以减少重复的样式定义，并保持一致性和可维护性。

6. 对象和组件的命名：使用有意义且可重用的命名约定来标识对象和组件。命名应该清晰描述对象的功能和用途，以便其他开发者能够理解和使用。

7. 考虑响应式设计：在编写样式时考虑响应式设计，使组件能够适应不同的屏幕尺寸和设备。

这些原则帮助开发者在编写 CSS 时提供一种结构化的方法，并鼓励可重用、可维护的代码。通过遵循 OOCSS 的原则，可以提高代码的可扩展性、灵活性和可维护性。

### 构建包含

```
A.运行   
B.链接     
C.编译      
D.提交
```

### 变更追溯包括

```
A.变更人员  B.变更内容  C.变更时间   D.变更原因
```

变更管理是指对软件系统或项目进行修改或更新的过程和实践。在软件开发中，变更管理旨在确保对系统的变更进行有效的控制、跟踪和审计。变更管理涉及记录、追踪和评估对系统的任何变更，以便了解变更的原因、内容、时间和执行人员。

通过对变更进行追溯，可以提供对变更历史的全面了解，包括了解谁做出了什么样的变更，何时做出的以及为什么做出的变更。这有助于团队或组织更好地管理变更，确保变更的正确性、一致性和可追踪性，并为后续的维护和升级工作提供依据。

变更追溯的内容通常包括==变更人员、变更内容、变更时间和变更原因==，这些信息可以用于跟踪和审查变更，并为团队成员或利益相关者提供必要的上下文和背景。

### Interator遍历

迭代器（Iterator）是一种用于遍历集合或序列的对象。通过使用迭代器，我们可以按照特定的顺序逐个访问集合中的元素，而不需要直接访问底层的数据结构。

在许多编程语言中，迭代器模式提供了一种统一的遍历方式，使得不同类型的集合可以使用相同的迭代器接口进行遍历。

遍历集合时，迭代器提供了以下常用的方法：

1. `next()`: 返回集合中的下一个元素，并将迭代器移动到下一个位置。
2. `hasNext()`: 检查集合中是否还有下一个元素，返回布尔值。
3. `remove()`: 从集合中删除当前迭代器指向的元素（在一些语言中可能不支持）。

使用迭代器进行遍历的一般模式是使用循环结构，不断调用 `next()` 方法，直到遍历完所有的元素。

### 前后端分离的优势

```
1、独立开发
2、松耦合
3、前端技术选型自由
4、提升性能和扩展性
5、多端适配
```

## 判断

```
1.sassdoc为创建一系列开放和个性化的文档页面提供了工具。
2.JavaScript语言的对象继承是通过接口继承实现的。
3.正则表达式中，\B 描述单词的前或后边界。
4.Object.assign()可以拷贝继承属性
```

1、SassDoc 是一个用于生成 Sass（Syntactically Awesome Style Sheets）文档的工具。它是一个文档生成器，可以解析 Sass 文件中的注释，并生成详细的、可定制的 Sass 文档页面。

SassDoc 的主要功能包括：

1. 解析注释：SassDoc 可以解析 Sass 文件中的注释，包括普通注释和特殊注释。

2. 自动生成文档：通过解析注释，SassDoc 可以自动生成关于变量、混合器、函数、样式规则等 Sass 元素的文档。

3. 生成文档页面：SassDoc 可以生成结构化的文档页面，展示生成的文档内容。这些页面可以包含变量、混合器、函数的说明、使用示例、参数列表等信息。

4. 支持定制化：SassDoc 提供了丰富的配置选项，可以定制生成文档的样式、主题、布局等。

通过使用 SassDoc，开发者可以为 Sass 项目生成易于阅读和理解的文档，提供给其他开发者或团队成员参考和使用。这有助于提高代码的可维护性、可重用性和可理解性。

2、JavaScript 语言的对象继承是通过原型链继承实现的，而不是通过接口继承。JavaScript 中的对象可以通过原型链继承来继承属性和方法。

3、在正则表达式中，\b（而不是\B）表示单词的边界。具体来说，\b 匹配一个位置，该位置位于一个单词字符和一个非单词字符之间，或者位于字符串的开头或结尾与单词字符之间。而\B 表示非单词的边界，即与\b 相反，它匹配一个位置，该位置位于两个连续的单词字符或两个连续的非单词字符之间。

4、`Object.assign()` 方法用于将一个或多个源对象的可枚举属性复制到目标对象中，而不会拷贝继承属性。继承属性是指通过原型链继承而来的属性，它们存在于对象的原型链上，并且不能通过对象本身进行复制或修改。

```js
Object.assign(target, ...sources)
// 其中，target 是目标对象，sources 是一个或多个源对象。Object.assign() 方法会将源对象的可枚举属性复制到目标对象中，并返回目标对象。
```

# 2022/11/21 补考总结

前端有个十五六道，nginx大概4、5到，安卓ios有3道4道、设计模式2道、剩下都是部署测试的

## 单选

### 滴滴打车支付，Activity会发生的生命周期回调顺序

```
onPause() ——> onCreate() ——> onStart() ——> onResume()
```

### 代码运行结果

```js
var a, b;
(function() {
  alert(a);
  alert(b);
  var a = b = 3;
  alert(a);
  alert(b);
})();
alert(a);
alert(b);
```

```A
A.undefined，undefined，3，3，undefined，3
B.undefined，undefined，3，3，undefined，undefined
C.undefined，undefined，3，3，0，0
D.0，0，3，3，undefined，undefined
```

请注意，这段代码中存在一个常见的陷阱，即变量声明和赋值的顺序导致变量作用域和值的意外结果。

1. 第一个立即执行函数中的 `alert(a)`：显示 `undefined`，因为在函数内部重新声明了局部变量 `a`，但还没有赋值。
2. 第一个立即执行函数中的 `alert(b)`：显示 `undefined`，因为在函数内部重新声明了局部变量 `b`，但还没有赋值。
3. 第一个立即执行函数中的 `alert(a)`：显示 `3`，因为在函数内部将局部变量 `a` 和全局变量 `b` 都赋值为 `3`。
4. 第一个立即执行函数中的 `alert(b)`：显示 `3`，因为在函数内部将全局变量 `b` 赋值为 `3`。
5. 最外层的 `alert(a)`：显示 `undefined`，因为在全局作用域中没有声明和赋值变量 `a`。
6. 最外层的 `alert(b)`：显示 `3`，因为全局变量 `b` 的值在函数内部被赋值为 `3`。

### 灰度发布是指

灰度发布（Gray Release）是一种软件发布策略，用于逐步将新版本的软件或功能推出给部分用户，以便在真实环境中进行测试和评估，降低发布风险和最大化用户体验。

在灰度发布中，新版本或功能不是一次性全部发布给所有用户，而是先发布给一小部分用户，这些用户被称为灰度用户。随后，通过监控和收集反馈，对新版本或功能进行验证和优化。如果没有出现严重的问题或负面影响，逐步增加灰度用户范围，最终达到全量发布的目标。

**灰度发布的优势包括：**

1. 风险控制：通过逐步发布给部分用户，可以及早发现和解决可能存在的问题，减少对整个用户群体的影响。

2. 用户反馈：通过与灰度用户的互动和反馈，可以了解他们的体验和意见，从而及时进行改进和优化。

3. 性能评估：灰度发布提供了在真实环境中评估新版本或功能性能的机会，可以收集性能指标和数据，进一步优化系统。

4. 逐步推进：灰度发布允许渐进式推进，有助于逐步引入新功能或变更，使用户适应和接受变化的过程更平滑。

需要注意的是，灰度发布需要仔细规划和监控，确保在控制范围内进行，并及时处理可能的问题。同时，也需要根据实际情况选择合适的灰度比例和发布策略，以最大程度地减少风险并提升用户体验。

### 以下哪个是前端常用的构建工具？

```A
A.Webpack
B.Vue
C.Element
D.React
```

Webpack 是一个模块打包工具，可以将多个 JavaScript 文件及其依赖打包成一个或多个静态资源文件。它支持代码分割、模块化管理、代码压缩等功能，是前端开发中最常用的构建工具之一。

Webpack的主要功能和特点包括：

1. 模块化支持：Webpack可以处理各种类型的模块，如JavaScript、CSS、图片等，并支持模块之间的依赖关系管理。
2. 打包和压缩：Webpack将所有依赖的模块打包成一个或多个最终的部署文件，以便在生产环境中使用。它还可以对这些文件进行压缩和优化，以提高加载速度和性能。
3. 资源管理：Webpack可以处理各种类型的静态资源，如图片、字体等，并根据需要进行合并、转换和优化。
4. 插件系统：Webpack具有丰富的插件系统，可以扩展其功能，例如代码分割、热模块替换、自动化构建等。
5. 开发环境支持：Webpack提供了开发服务器和开发工具链的支持，包括自动刷新、模块热替换等功能，以提高开发效率。

通过配置Webpack的入口文件、输出文件路径、加载器（Loaders）和插件（Plugins），开发人员可以根据项目的需求进行自定义配置和打包优化。

总而言之，Webpack是一个强大的静态模块打包工具，能够帮助开发人员处理模块之间的依赖关系、打包和优化资源，并提供丰富的插件系统和开发支持，使前端项目的构建和部署更加高效和可靠。

### Nginx代理服务器向后端服务器发出read/write请求，默认时间

Nginx代理服务器向后端服务器发出read/write请求的默认超时时间可以通过配置项来设置。具体的配置项名称和默认值可能会因Nginx的版本和具体的配置而有所不同。

以下是一些与代理请求超时相关的Nginx配置项及其默认值：

1. proxy_read_timeout：此配置项定义了向后端服务器发出读取请求（包括获取响应数据）的超时时间。默认值为60秒。

2. proxy_send_timeout：此配置项定义了向后端服务器发出写入请求（包括发送请求数据）的超时时间。默认值为60秒。

需要注意的是，这些默认值可能会因为Nginx的版本、编译选项和配置文件中的具体设置而有所不同。可以在Nginx的配置文件中找到相应的配置项，并根据实际需求进行调整。

此外，还可以使用其他配置项来进行更详细的调优，例如调整Nginx与后端服务器之间的连接超时时间、缓冲区大小等。根据具体情况，可以参考Nginx的官方文档或相关资料来了解更多配置选项和其默认值。

## 多选

### 下列哪些操作会使用线程释放锁资源

```
A.join（）
B.Sleep（）
C.Wait（）
D.Yield（）
```

在给出的选项中，下列操作会使用线程释放锁资源：

A. join()：该操作会使当前线程等待被调用的线程执行完毕，然后再继续执行。在等待期间，当前线程会释放锁资源，允许其他线程获取该锁。

C. Wait()：该操作是在线程等待某个条件满足时调用的，它会释放锁资源并使当前线程进入等待状态，直到其他线程通过notify()或notifyAll()来通知该线程继续执行。

因此，选项 A 和 C 和是会使用线程释放锁资源的操作。

B. Sleep()：该操作是使线程进入休眠状态一段指定的时间。在休眠期间，线程不会释放锁资源。

D. Yield()：该操作是线程主动放弃当前的执行权，使其他具有相同优先级的线程有机会执行。虽然并非直接释放锁资源，但通过让其他线程执行，间接地允许其他线程获取锁资源。

### 制品库是什么？

制品库（Artifact Repository）是用于存储和管理软件构建产物（即制品）的中央化存储库。它是软件开发过程中的关键组成部分，用于管理和分发各种构建产物，例如编译后的程序文件、库文件、依赖包、镜像文件等。

制品库通常提供了版本控制、元数据管理、访问权限控制等功能，以便团队成员可以方便地共享和获取构建产物。它有助于提高开发效率、确保构建产物的一致性和可追溯性，并支持自动化部署和持续集成/交付流程。

常见的制品库包括 Maven Repository（用于 Java 生态系统）、NPM Registry（用于 Node.js 生态系统）、Docker Registry（用于容器镜像）、NuGet Gallery（用于 .NET 生态系统）等。此外，还有一些通用的制品库管理工具，如 JFrog Artifactory、Sonatype Nexus 等，它们支持多种编程语言和技术栈，并提供了更广泛的功能和集成选项。

### 以下属于制品库的是：（）

```
A. 基础镜像
B. 项目镜像
C. 开源组件
D. 某某组件
```

A. 基础镜像：基础镜像是构建容器化应用程序时使用的初始镜像，通常包含操作系统和基本的运行时环境。将基础镜像存储在制品库中有助于集中管理和版本控制。

B. 项目镜像：项目镜像是构建完成的容器镜像，包含了应用程序代码、依赖项和配置等。将项目镜像存储在制品库中可以方便地进行版本管理和分发。

C. 开源组件：开源组件是开源社区或第三方提供的软件库或工具，用于开发中使用。将开源组件存储在制品库中可以方便团队成员共享和使用，并确保组件的版本和来源可控。

D. 某某组件：根据提供的选项，无法确定具体指代的是哪个组件。如果是指特定的组件或自定义的组件，将其存储在制品库中也是常见的做法，以方便团队内部共享和管理。

因此，选项 A、B、C 和 D 都属于制品库中的内容。制品库用于存储和管理各种构建产物和依赖项，包括镜像、组件和其他相关文件。

### Ribbon配置

Ribbon是一个负载均衡客户端，常用于微服务架构中。它可以与服务发现组件（如Eureka）结合使用，根据一定的负载均衡策略自动选择可用的服务实例进行请求转发。

在使用Ribbon时，需要进行一些配置以定义负载均衡的行为和规则。以下是一些常见的Ribbon配置项：

1. 服务列表配置：指定需要进行负载均衡的服务列表，可以通过配置服务名称或服务实例的URL。

2. 负载均衡策略配置：定义负载均衡的算法和规则，包括轮询（Round Robin）、随机（Random）、加权轮询（Weighted Round Robin）等。

3. 超时配置：设置请求超时时间，用于判断请求是否超时，并进行相应的处理。

4. 重试配置：指定在请求失败时是否进行重试，并配置重试的次数和间隔。

5. 服务实例状态配置：定义服务实例的健康检查机制和状态判断规则，以决定是否将请求转发给该实例。

这些配置可以通过属性文件、注解或编程方式进行设置，具体的配置方式取决于所使用的框架和技术栈。

需要注意的是，Ribbon在Spring Cloud中已经被标记为不推荐使用，并计划在未来的版本中移除。取而代之的是Spring Cloud LoadBalancer和服务发现组件的集成。因此，在使用Ribbon时，建议参考相关的官方文档和最新的推荐做法。

### 流水线建立全流程的自动化能力的环节

1. 持续集成（Continuous Integration）：这是自动化流水线的基础环节，它涉及将开发团队的代码集成到共享存储库中，并进行自动化构建和测试。持续集成的关键是确保代码的频繁集成和自动化测试，以便尽早发现和解决问题。

2. 自动化构建（Automated Build）：在持续集成的基础上，自动化构建环节负责将源代码转换为可部署的软件包或容器镜像。这包括编译源代码、打包依赖项、执行静态代码分析等操作。常见的构建工具包括Maven、Gradle、Webpack等。

3. 自动化测试（Automated Testing）：自动化测试环节用于执行各种类型的测试，包括单元测试、集成测试、端到端测试等。自动化测试可以通过自动化测试框架和工具来实现，例如JUnit、Selenium、Cypress等。测试结果应该及时反馈给开发团队，以便修复和改进代码。

4. 自动化部署（Automated Deployment）：自动化部署环节负责将构建好的软件包或容器镜像部署到目标环境中，例如测试环境、预发布环境和生产环境。这通常涉及自动化配置管理、容器编排和云平台管理等。常用的部署工具有Docker、Kubernetes、Ansible等。

5. 自动化监控与反馈（Automated Monitoring and Feedback）：自动化监控与反馈环节用于监控应用程序和基础设施的运行状态，并及时反馈给相关团队。这可以通过监控工具和日志分析来实现，以便快速发现和解决问题。

通过在这些环节中应用自动化工具和技术，可以实现软件开发和交付过程的高效、一致和可靠性。同时，它还有助于提高团队的生产力、降低错误率，并支持持续交付和持续部署的实践。

### 属于质量检测工具

```CD
A.Sonarcuber
B.Jacoco
C.代码卫士
D.Maven
```

### 项目部署步骤的目标群体环境

1. 目标群体：项目部署的目标群体是指最终使用该项目或受该项目影响的人群，可能包括以下方面：
   - 最终用户：使用该项目提供的功能或服务的实际用户。
   - 运维团队：负责项目的部署、监控和维护的技术团队。
   - 开发团队：负责项目的开发和维护的技术团队。
2. 环境：项目部署的环境包括以下几个方面：
   - 开发环境：用于开发人员进行代码编写、测试和调试的环境。
   - 测试环境：用于进行系统集成测试、性能测试和用户验收测试的环境。
   - 预生产环境：用于进行最终的系统验证和准备部署到生产环境的环境。
   - 生产环境：项目正式运行和提供服务的环境。
3. 步骤：项目部署的步骤可以包括以下几个方面，具体步骤会根据项目和环境的不同而有所差异：
   - 确定部署计划和策略：制定详细的部署计划，包括时间安排、人员配备和部署策略。
   - 配置环境和依赖：准备好目标环境，并配置所需的运行环境、数据库、缓存等依赖。
   - 打包和部署应用：将项目代码打包成可执行的软件包或容器镜像，并部署到目标环境中。
   - 数据迁移：如果涉及数据库的部署，需要进行数据迁移和数据同步操作。
   - 配置和参数设置：对应用程序进行必要的配置和参数设置，确保其在目标环境中正常运行。
   - 测试和验证：在目标环境中进行系统测试和验证，确保部署的应用程序和环境都正常工作。
   - 监控和调优：配置监控工具和日志记录，以便及时监控和调优部署的应用程序。

## 判断

```1T/2T
1.模块@babel/rehister是实时转码，只适合在开发环境使用
2.关于可视化描述正确的包括部署流水线全员可见
```

1. 模块@babel/register用于实时转码，它主要在开发环境中使用。@babel/register会在运行时将ES6+的代码转换为当前Node.js版本支持的代码，使开发人员可以在开发过程中使用最新的JavaScript语法和功能。在生产环境中，通常不建议使用@babel/register，而是预先将代码转码为目标版本的代码，以提高性能和稳定性。

2. 关于可视化描述部署流水线全员可见是正确的。部署流水线是一种自动化的软件交付过程，涉及从代码提交到应用部署的一系列步骤。可视化描述部署流水线的主要目的是提供一个直观、易懂的界面，用于展示和跟踪整个部署过程。全员可见意味着团队中的所有成员，包括开发人员、运维人员、项目经理等，都可以查看和了解部署流水线的状态、进度和结果，以便及时发现和解决问题，保证项目的顺利进行。这种可视化描述可以通过使用工具和平台，如Jenkins、GitLab CI/CD、Azure DevOps等来实现。

# 2022/11/18补考总结

Js大概十几二十道，原题五六道，设计模式三四道、大部分都是nginx的配置题，差不多有十几道，devops的题五六道，vue的三四道，其他题型七八道

### 输出结果

```js
var value = 5 + 3 + "7";
var value2 = 3 + "7";
```

```js
// 这行代码的执行结果是"87"。在这个表达式中，首先进行数值相加的操作5 + 3得到结果8，然后将结果8与字符串"7"进行字符串拼接，得到最终的字符串"87"。

// 这行代码的执行结果是"37"。在这个表达式中，由于其中一个操作数是字符串"7"，所以会进行字符串拼接的操作，将数字3转换为字符串，然后将两个字符串拼接在一起，得到最终的字符串"37"。
```

### 以下哪个不是 nginx 的负载均衡算法

```
A.加权轮询
B.什么哈希
C.cookie
D.url
```

A. 加权轮询（Weighted Round Robin）：根据服务器的权重分配请求，权重越高的服务器接收到的请求比例越高。

B. 哈希（Hash）：使用请求的某个特定属性（如客户端 IP 或 URL）计算哈希值，然后将请求分发到具有对应哈希值的服务器上，确保相同属性的请求始终发送到同一台服务器。

C. Cookie：基于请求中的特定 Cookie 值，将请求发送到具有相同 Cookie 值的服务器上，适用于需要维持会话的应用。

D. URL：并不是 Nginx 的负载均衡算法，而是请求中的一部分信息。

### 以下说法正确的是

```js
function * gen() { yield 1; yield 2; yield 3; } 
```

```CD
A.gen()执行后返回2
B.gen()执行后返回undefined
C.gen()执行后返回一个Generator对象
D.gen()执行后返回1
```

### CommonsChunkPlugin

通常用于将多个入口点（entry points）中==共享的代码==提取为一个==单独的文件==，以便于==缓存和重用==。

具体来说，CommonsChunkPlugin是一个Webpack插件，它可以在构建过程中将重复的模块或共享的模块提取出来，并将它们放置在一个单独的chunk中，这个chunk可以被多个入口点引用。这样做的好处是，当多个入口点共享相同的模块时，这些模块可以被提取到公共的chunk中，避免重复加载和浪费。

使用CommonsChunkPlugin可以优化打包后的文件大小，减少重复的模块加载，提高页面加载速度和性能。它常用于处理共享的第三方库、公共组件、公共样式等。

总结来说，CommonsChunkPlugin的主要作用是将共享的代码提取到一个单独的chunk中，以便于复用和优化性能。

### GLSurFaceView 的特性

GLSurfaceView 是 Android 平台上的一个视图控件，用于显示 OpenGL ES 绘制的图形和动画。它具有以下特性：

1. OpenGL ES 支持：GLSurfaceView 提供了与 OpenGL ES 相关的接口和功能，使开发者能够方便地在应用中渲染 2D 和 3D 图形。

2. 双缓冲机制：GLSurfaceView 使用双缓冲机制来避免图像闪烁和绘制的不连续性。它包含一个前缓冲区和一个后缓冲区，绘制操作在后缓冲区中进行，然后交换缓冲区将结果显示在屏幕上，提供平滑的图形更新效果。

3. 独立的渲染线程：GLSurfaceView 在后台创建一个独立的渲染线程，用于执行 OpenGL ES 相关的绘制操作。这样可以避免在主线程中执行耗时的绘制操作，保证应用的响应性和流畅性。

4. 生命周期管理：GLSurfaceView 提供了与 Activity 生命周期的集成，可以通过回调方法（如 onResume()、onPause()）正确地管理渲染线程的启动和暂停，以避免资源浪费和内存泄漏。

5. 触摸事件处理：GLSurfaceView 可以处理触摸事件，提供了相关的触摸事件回调方法，使开发者能够对触摸事件进行处理，实现与 OpenGL ES 相关的交互操作。

6. 多样化的配置选项：GLSurfaceView 提供了许多配置选项，可以根据需要进行自定义设置，例如渲染模式、像素格式、深度缓冲、模板缓冲等。

总的来说，GLSurfaceView 是一个方便的工具，使开发者能够在 Android 应用中使用 OpenGL ES 进行图形渲染，并提供了生命周期管理、触摸事件处理和配置选项等功能，简化了 OpenGL ES 的集成和使用过程。

### Nginx的作用

Nginx 是一个开源的高性能的==Web 服务器==和==反向代理服务器==，它具有以下主要作用：

1. Web 服务器：Nginx 可以作为静态资源服务器，处理和响应来自客户端的 HTTP 请求。它可以快速地传送静态内容，如 HTML 文件、图像、CSS 和 JavaScript 文件等，提供高效的 Web 访问服务。

2. 反向代理服务器：Nginx 可以作为反向代理服务器，代理并转发客户端的请求到后端的多个服务器。它能够根据特定的负载均衡算法将请求分发到不同的后端服务器，提高系统的并发处理能力和可靠性。

3. 负载均衡：作为反向代理服务器，Nginx 可以根据配置的负载均衡算法将请求均匀地分发到多个后端服务器上，以实现负载均衡，提高系统的性能和可扩展性。

4. 高并发处理：Nginx 的事件驱动的异步非阻塞架构使其能够高效地处理大量并发连接，支持高并发的请求处理和数据传输。

5. 静态文件缓存：Nginx 可以缓存静态文件，减少对后端服务器的请求，提高访问速度和效率。

6. SSL/TLS 加密：Nginx 支持 SSL/TLS 协议，能够提供安全的加密通信，保护客户端和服务器之间的数据传输安全。

7. 虚拟主机支持：Nginx 支持虚拟主机配置，可以在一台服务器上托管多个域名或网站，并根据配置将请求正确地路由到对应的虚拟主机。

### 前端任务处理器流程

```
接收任务 ——> 解析任务 ——> 执行任务 ——> 更新界面 ——> 监听事件 ——> 错误处理 ——> 完成任务
```

1. 接收任务：前端任务处理器首先需要接收任务，这可以是用户输入、服务器请求或其他事件触发。

2. 解析任务：接收到任务后，前端任务处理器会解析任务的内容，了解任务的要求和目标。

3. 执行任务：根据任务的要求和目标，前端任务处理器开始执行相应的操作。这可能涉及到修改DOM元素、发送请求、调用API等。

4. 更新界面：任务执行完毕后，前端任务处理器可能需要更新界面以反映执行结果。这可能涉及到更新DOM元素、显示提示信息或错误信息等。

5. 监听事件：前端任务处理器可能需要监听一些事件，以便在事件触发时执行相应的任务。这可以是用户交互、网络请求完成等。

6. 错误处理：在任务执行过程中，前端任务处理器需要处理可能出现的错误情况。这包括捕获和处理异常、显示错误信息等。

7. 完成任务：当任务执行完毕后，前端任务处理器可以进行清理工作，关闭不再需要的资源，或者进行下一步操作的准备。

这个流程可以根据具体的应用场景和需求进行调整和扩展。

### DevOps

DevOps是一种将软件开发（Dev）和信息技术运维（Ops）两个领域进行整合的方法论和实践。它旨在通过改进软件开发团队和运维团队之间的协作与沟通，加快软件交付速度、提高质量和稳定性，以及实现持续交付和持续部署的能力。

DevOps的关键特点和流程包括：

1. 自动化：通过自动化工具和流程，包括构建、测试、部署等，减少人工操作，提高效率和一致性。

2. 持续集成和持续交付：采用持续集成（CI）和持续交付（CD）的实践，使团队能够频繁地集成代码、自动化测试，并快速交付高质量的软件。

3. 配置管理：使用配置管理工具来管理和自动化服务器和基础设施的配置，确保环境的一致性和可重复性。

4. 监控和日志：通过实时监控和日志记录，及时发现和解决问题，提高系统的可用性和性能。

5. 协作与沟通：促进开发团队和运维团队之间的密切合作与沟通，共享知识和责任，减少摩擦和延迟。

6. 安全和合规性：将安全性和合规性考虑纳入整个开发和运维过程，确保系统的安全性和符合相关法规和标准。

DevOps的目标是通过改进团队协作、自动化流程和持续改进，提高软件交付速度、质量和稳定性，同时增强业务的灵活性和创新能力。它是一种文化和方法论的变革，强调跨团队合作和持续学习的重要性。

## 多选

### 版本控制的内容包括（）

```ACD
A. 版本控制系统
B. 单一
C. 管理
D. 分支
```

版本控制的内容主要包括版本控制系统、管理和分支。

版本控制系统是实现版本控制的工具或平台，它可以帮助开发团队跟踪、管理和控制软件代码和文件的不同版本。

管理涉及对版本控制系统中的代码和文件进行有效的组织、维护和共享。

分支是版本控制系统中的一个重要概念，允许开发团队在同一代码库中创建并并行开发不同的代码分支，以便独立地进行特性开发、修复错误或实验性工作，并最终合并回主分支。

### 造成ANR的原因正确的是（）

```
A. 后台200s没处理
B. 前台广播receive
C. 5s内没处理
D. 20s内没处理
```

ANR（Application Not Responding）是指在Android应用程序中，当主线程（UI线程）在一段时间内无法响应用户的输入或界面更新时出现的错误。造成ANR的常见原因包括：

C. 5s内没处理：如果应用程序在主线程上执行的操作超过5秒钟而没有完成，系统将会认为应用程序无响应，触发ANR错误。

D. 20s内没处理：如果应用程序在主线程上执行的广播接收器或服务等操作超过20秒钟而没有完成，系统也会认为应用程序无响应，触发ANR错误。

A. 后台200s没处理：虽然后台操作的执行时间过长可能会对应用程序性能和用户体验产生负面影响，但它不是直接造成ANR的原因。

B. 前台广播receive：前台广播接收器的执行通常是在主线程上进行的，因此如果广播接收器在一段时间内占用了主线程而无法完成执行，也会导致ANR错误。

综上所述，造成ANR的原因是C. 5s内没处理和D. 20s内没处理。

### 接口测试工具有哪些？

1. Postman：Postman是一款功能强大的API开发和测试工具，可以发送HTTP请求、模拟服务器响应、编写和运行自动化测试脚本，并生成测试报告。
2. SoapUI：SoapUI是一款专注于Web服务测试的工具，支持测试SOAP和RESTful接口。它提供了创建、执行和管理接口测试的功能，以及对测试结果进行断言和报告生成的能力。
3. JMeter：JMeter是一个广泛应用于性能测试的工具，但也可以用于接口测试。它支持多种协议，包括HTTP、HTTPS、FTP、SOAP、REST等，能够模拟大量并发请求进行接口测试和负载测试。
4. RestAssured：RestAssured是一个基于Java的开源库，用于编写和执行RESTful接口的自动化测试。它提供了丰富的API和断言功能，支持处理JSON和XML等数据格式。
5. Karate：Karate是一个开源的接口测试框架，基于Cucumber和Gherkin语法，旨在简化RESTful接口的自动化测试。它提供了易于使用的DSL（领域特定语言）和内置的断言功能。
6. HTTPie：HTTPie是一个命令行工具，用于发送HTTP请求和与接口进行交互。它具有直观的语法、可扩展性和易于使用的界面，适用于简单的接口测试和调试。
