# 2022/11/23 补考总结

Js：5，6道；es：2，3道，动画：2道；css：引入样式2道；nginx，docker，zuul，Devops3，4道；Vue生命周期、数据渲染1道；时间复杂度2道；环境部署

## 单选

### 下面这段程序的显示结果是？

```js
var x = new Boolean(false);
if (x) {
  alert('hi'); 
}
var y = Boolean(0);
if (y) {
  alert('hello');  
}
```

```
A.Hi
B.hi hello
C.Hello
D.不显示
```

当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。

如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。

### 以下排序算法中，时间复杂度为0(N)的为（）

```A
A.直接插入
B.快速排序
C.冒泡排序
D.希尔排序
```

这道题要求选择时间复杂度为O(N)的排序算法。

选项A. 直接插入排序的时间复杂度为O(N^2)，因为在最坏情况下，每个元素需要依次与已排序序列中的元素比较和移动位置。

选项B. 快速排序的平均时间复杂度为O(NlogN)，最坏情况下为O(N^2)。因此，它不符合题目要求。

选项C. 冒泡排序的时间复杂度为O(N^2)，因为每个元素都需要与其他元素进行比较和交换位置。

选项D. 希尔排序的平均时间复杂度为O(NlogN)或者更好，最坏情况下为O(N^2)。因此，它也不符合题目要求。

### Generator函数的yield关键字的作用是：

```B
A.退出函数
B.暂停执行，等待 next() 方法调用
C.停止执行
D.停正执行，可自行恢复执行
```

### 关于 AlertDialog 描述错误的是

```D
A.show() 方法创建并显示对话框
B.AlertDialog.Builder 的 create() 和 show() 方法都返回 AlertDialog 对象
C.AlertDialog 不能直接用 new 关键字构建对象，而必须使用其内部类 Builder
D.create() 方法创建并显示对话框
```

AlertDialog 是一个用于显示警告或提示信息的对话框组件，常用于 Android 应用程序开发中。它是 Android 系统提供的一种内置对话框类型，可以用于显示消息、确认用户操作、获取用户输入等功能。

AlertDialog 可以包含标题、消息内容、按钮以及其他可选的交互元素。通过创建 AlertDialog 实例并设置相应的属性，可以自定义对话框的外观和行为。

以下是使用 AlertDialog 的一般步骤：

1. 创建 AlertDialog.Builder 对象：通过实例化 AlertDialog.Builder 类来创建一个 AlertDialog 对象的构建器。

2. 设置对话框属性：使用构建器对象的方法来设置对话框的标题、消息内容、图标、按钮等属性。

3. 设置按钮点击监听器：为对话框上的按钮设置点击事件的监听器，以响应用户的操作。

4. 创建和显示对话框：调用构建器的 `create()` 方法来创建 AlertDialog 对象，然后调用 `show()` 方法显示对话框。

通过这些步骤，可以创建一个自定义的 AlertDialog 对话框来满足应用程序的需求，并与用户进行交互。

### [1,2,[3,[4,5]]].flat 的结果

```js
[1,2,[3,[4,5]]].flat // [1,2,3,[4,5]]
```

### 要运用css3动画，你需要运用什么规则？

```A
A.keyframes
B.Animation
C.Flash
D.transition
```

### HTML5中不再支持哪些元素？

1. `<applet>`：用于嵌入 Java Applet 的元素。现在应该使用更现代的技术，如JavaScript和HTML5的Canvas或WebGL。
2. `<acronym>`：用于定义首字母缩略词。现在应该使用更语义化的标签，如 `<abbr>`。
3. `<basefont>`：用于设置基本字体大小和颜色。现在应该使用 CSS 来控制字体样式。
4. `<big>`：用于定义大号文本。现在应该使用 CSS 来控制文本的大小。
5. `<center>`：用于居中对齐内容。现在应该使用 CSS 来实现布局和对齐。
6. `<font>`：用于设置字体相关属性。现在应该使用 CSS 来控制字体样式。⭐
7. `<frame>` 和 `<frameset>`：用于创建网页框架。现在应该使用更现代的布局技术，如 `<div>` 元素和 CSS。⭐
8. `<strike>` 和 `<s>`：用于定义删除线文本。现在应该使用 CSS 来控制文本的样式。
9. `<tt>`：用于定义打字机文本。现在应该使用 CSS 来控制文本的样式。

### 不属于补间动画：FrameAnimation

FrameAnimation 是通过连续切换一系列静态帧图像来创建动画效果。FrameAnimation 通常使用 GIF 或精灵图（Sprite Sheet）的形式来实现。

CSS 补间动画（CSS Transitions）是一种在浏览器中使用 CSS 属性进行动画过渡的技术。以下是一些常见的 CSS 补间动画属性：

1. `transition-property`：指定要应用过渡效果的 CSS 属性名称。
2. `transition-duration`：指定过渡的持续时间。
3. `transition-timing-function`：指定过渡的时间函数，控制动画的加速和减速效果。
4. `transition-delay`：指定过渡的延迟时间。
5. `transition`：可以用于简写上述四个过渡属性的属性缩写形式。

通过组合使用这些属性，可以创建各种类型的 CSS 补间动画效果，包括：

- 淡入淡出效果（Opacity）
- 缩放效果（Scale）
- 旋转效果（Rotate）
- 移动效果（Translate）
- 渐变效果（Color）
- 边框效果（Border）

这些属性和效果可以通过设置不同的起始状态和结束状态，配合适当的过渡属性值，来实现平滑的动画过渡效果。通过 CSS 补间动画，可以在不使用 JavaScript 或其他动画框架的情况下，使用纯 CSS 实现动画效果。

### Web诞生在哪个时期

Web（万维网）诞生于 1990 年代初期（二十世纪九十年代）。

Web 的起源可以追溯到 1989 年，由英国科学家蒂姆·伯纳斯-李（Tim Berners-Lee）提出的构想。他在 CERN（欧洲核子研究组织）工作期间，提出了一种基于超文本和互联网的信息共享系统的概念，这就是 Web 的雏形。

在 1990 年，蒂姆·伯纳斯-李发明了第一个 Web 服务器和客户端浏览器，并创建了第一个 Web 页面。他使用了 HTML（超文本标记语言）来描述和组织页面内容，并使用了 HTTP（超文本传输协议）来进行页面的传输和交互。

随着时间的推移和技术的发展，Web 在 1990 年代逐渐普及。万维网的发展对互联网的普及和信息共享产生了深远的影响，开启了一个全新的数字时代。

### 在 Vue 组件的生命周期中，数据渲染并上树的过程发生在哪里？

在 Vue 组件的生命周期中，数据渲染并上树的过程发生在 `mounted` 钩子函数期间。

下面是有关 Vue 组件生命周期中的三个钩子函数的说明：

1. `beforeCreate` 钩子函数在组件实例被创建之初被调用。在这个阶段，组件实例已经被初始化，但是数据观测（data observation）和事件机制尚未设置。因此，在 `beforeCreate` 钩子函数中，无法访问到组件的 `data` 数据和其他实例属性。

2. `beforeMount` 钩子函数在组件挂载之前被调用。在这个阶段，模板已经编译完成，但是尚未将组件实例挂载到 DOM 上。因此，在 `beforeMount` 钩子函数中，你可以访问到组件的模板内容，但是无法访问到挂载后的 DOM 元素。

3. `mounted` 钩子函数在组件挂载到 DOM 后被调用。在这个阶段，组件已经挂载到 DOM 上，可以访问到组件的挂载后的 DOM 元素。同时，组件的数据已经被渲染到 DOM 中，可以进行相关的操作和交互。

因此，在 `mounted` 钩子函数期间，数据已经完成渲染并成功上树，此时可以进行 DOM 操作、请求数据、订阅事件等。

### zuul拦截器

Zuul 拦截器是在 Netflix 的开源网关框架 Zuul 中使用的组件，用于实现对进入网关的请求和出去的响应进行拦截和处理的机制。

Zuul 是一个基于 JVM 的动态路由和过滤器网关，用于在微服务架构中提供请求路由、负载均衡、安全认证、限流等功能。而 Zuul 拦截器则是 Zuul 网关的核心功能之一，用于对请求和响应进行拦截和处理。

通过编写自定义的 Zuul 拦截器，你可以在请求经过网关之前或响应返回给客户端之前，执行一些额外的逻辑操作。拦截器可以用于鉴权、认证、请求转发、日志记录、请求修改等各种场景。你可以根据自己的需求定义和配置多个拦截器，它们按照定义的顺序依次执行。

⭐⭐⭐以下是 Zuul 网关的一些常见拦截器类型：

1. 前置拦截器（Pre Filter）：在请求路由到目标服务之前执行的拦截器。可以用于鉴权、认证、请求转发等前置处理逻辑。

2. 路由拦截器（Route Filter）：用于执行实际的路由逻辑，将请求发送到目标服务。可以进行负载均衡、请求重试等处理。

3. 后置拦截器（Post Filter）：在目标服务响应返回给客户端之前执行的拦截器。可以对响应进行修改、日志记录等后置处理操作。

4. 错误拦截器（Error Filter）：用于处理路由过程中产生的错误，例如目标服务不可用、超时等。可以进行统一的错误处理、日志记录等操作。

### 读取文件内容的首要方法

```D
A.openFileOutput
B.Read
C.Write
D.openFileInput
```

解析题目：题目要求找出读取文件内容的首要方法。

正确答案是 D. `openFileInput`。

`openFileInput` 方法是 Android 中用于读取应用内部存储目录下的文件内容的方法。通过该方法打开文件输入流后，可以使用读取流的方式读取文件内容。

A. `openFileOutput` 是用于写入文件内容的方法，而非读取文件内容。

B. `Read` 不是 Android 中的文件读取方法，可能是一个错误选项。

C. `Write` 也不是 Android 中的文件读取方法，可能是一个错误选项。

因此，D. `openFileInput` 是读取文件内容的首要方法。

### 以下不属于把CSS样式表与HTML网页关联的方法

```A
A.在HTML文档的＜!--…--＞标签内定义CSS样式
B.用＜link＞标签链接网上可访问的CSS样式表文件
C.在HTML文档的＜head＞标签内定义CSS样式
D.用＠import引入样式表文件
```

### 使用nginx将http请求转发请求到后端服务，后端服务不可用的时候会返回什么状态码？

```D
A.400
B.404
C.500
D.502
```

在使用 Nginx 将 HTTP 请求转发到后端服务时，如果后端服务不可用，Nginx 会返回 D. 502 Bad Gateway 状态码。

A. 400 Bad Request：表示客户端发送的请求存在语法错误或不合理。

B. 404 Not Found：表示客户端请求的资源在服务器上未找到。

C. 500 Internal Server Error：表示服务器在处理请求时遇到了内部错误。

D. 502 Bad Gateway：表示代理服务器（即 Nginx）作为网关或代理，无法从上游服务器（即后端服务）获得有效的响应。这通常意味着后端服务无法正常响应请求，可能是由于后端服务故障、宕机、网络连接问题等原因导致。

通过返回 502 Bad Gateway 状态码，Nginx 向客户端指示请求的后端服务不可用，并且客户端可以根据此状态码进行相应的处理，例如进行错误处理、重试请求等。

### 如下代码输出的结果是什么

```
console.log(1+ "2"+"2");
console.log(1+ +"2"+"2");
console.log("A"- "B"+"2");
console.log("A"- "B"+2);
```

```
A.122 122 NaN NaN
B.122 32 NaN NaN2
C.122 32 NaN2 NaN
D.122 32 NaN2 NaN2
```

### [...a,b]，a，b的值？

注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

### Docker启动流程

Docker 是一种开源的容器化平台，用于构建、部署和运行应用程序。它利用容器化技术将应用程序及其依赖项打包到一个独立的、可移植的容器中，提供了一种轻量级、快速部署的解决方案。

Docker 的启动流程如下：

1. 编写 Dockerfile：Dockerfile 是一个文本文件，用于定义 Docker 镜像的构建过程。在 Dockerfile 中，你可以指定所需的基础镜像、安装依赖、配置环境、拷贝文件等操作。

2. 构建镜像：使用 Docker 命令行工具执行 `docker build` 命令，根据 Dockerfile 构建 Docker 镜像。该命令会根据指定的 Dockerfile 执行每一条指令，生成一个包含应用程序及其运行环境的镜像。

3. 运行容器：使用 `docker run` 命令启动容器，基于构建好的镜像创建一个运行实例。在运行容器时，可以指定端口映射、挂载数据卷、设置环境变量等配置。

4. 应用程序运行：容器启动后，Docker 会在容器中运行应用程序，并提供访问接口。应用程序可以在容器内部以与在物理机或虚拟机上运行时相同的方式运行。

总结起来，Docker 的启动流程包括编写 Dockerfile 定义镜像构建过程，使用 Docker 构建镜像，运行容器并启动应用程序。通过容器化的方式，应用程序可以在各种环境中以一致的方式运行，并且容器之间相互隔离，提供更高的可移植性、可靠性和效率。

### Vue-router路由信息保存在哪里？

在 Vue.js 中，Vue Router 的路由信息保存在路由器实例的 `routes` 属性中。`routes` 是一个数组，包含了定义的所有路由配置信息。

每个路由配置对象包含了路由的路径、组件、元数据等信息。下面是一个示例：

```javascript
import { createApp } from 'vue';
import { createRouter, createWebHistory } from 'vue-router';
import Home from './components/Home.vue';
import About from './components/About.vue';

const router = createRouter({
  history: createWebHistory(),
  routes: [
    { path: '/', component: Home },
    { path: '/about', component: About }
  ]
});

const app = createApp(App);
app.use(router);
app.mount('#app');

```

在上述示例中，`routes` 数组包含了两个路由配置，分别是根路由 `'/'` 和关于页路由 `'/about'`。每个路由配置包括了路径（`path`）和对应的组件（`component`）。

通过 `createRouter` 函数创建的 `router` 对象中包含了 `routes` 数组以及其他路由相关的属性和方法，用于管理和控制路由的跳转、导航等操作。

## 多选

### 以下哪三种使用CSS来格式化网页的方式

```
A.在HEAD中引用
B.作为标记来引用
C.在BODY中引用
D.作为文件来引用。
```

### 当用户打开一个网页时，想一直停留在当前打开的页面，禁止页面前进和后退，以下==不正确==的是

```BC
A.window.history.forward(1)；
B.window.history.back(1)
C.window.history.go(-1)
D.window. history.forward(-1);
```

B选项`window.history.back(1)`是用于返回到前一个页面。 C选项`window.history.go(-1)`也是用于返回到前一个页面。

A选项`window.history.forward(1)`用于前进到下一个页面。 D选项`window.history.forward(-1)`虽然参数是负数，但仍然是用于前进到下一个页面，因为`forward()`方法的参数是一个整数，表示前进或后退的步数。`window.history.forward()` 方法不接受负数参数。

### 下面哪些是线程安全的

```AB
A.Vector
B.ConcurrentHashMap
C.Arraylist
D.LinkedList
```

A. Vector
B. ConcurrentHashMap

选项 A. Vector 和选项 B. ConcurrentHashMap 是线程安全的数据结构。

Vector 是一个动态数组，它提供了同步方法来确保在多线程环境下的线程安全性。它的方法使用了同步锁来保证线程之间的互斥访问，因此可以安全地在多个线程中使用。

ConcurrentHashMap 是 Java 中的一个线程安全的哈希表实现。它采用了锁分段技术，将数据分成多个段（Segment），每个段维护自己的锁。这种设计允许多个线程同时读取和写入不同的段，从而提高并发性能。

选项 C. ArrayList 和选项 D. LinkedList 都不是线程安全的。它们没有内置的同步机制，因此在多线程环境下同时修改它们可能会导致数据不一致或并发访问异常。

如果需要在多线程环境下使用 ArrayList 或 LinkedList，可以通过使用外部同步手段（如使用 Collections.synchronizedList 方法）来实现线程安全。

### 以下选项中，不属于分布式源代码控制工具的是:

```
A.GitLab
B.GitHub
C.SVN
D.CVS
```

不属于分布式源代码控制工具的选项是 C. SVN（Subversion）和 D. CVS（Concurrent Versions System）。

A. GitLab 和 B. GitHub 都是常见的分布式源代码控制工具，用于版本控制和协作开发。

C. SVN 是集中式源代码控制工具，与分布式控制工具相比，它的工作方式略有不同。

D. CVS 也是集中式源代码控制工具，它在早期被广泛使用，但目前已经被更现代的工具所取代。

### nginx的常见使用

```AD
A.作为Web服务器
B.作为java服务器
C.正向代理
D.反向代理
```

ChatGPT给的答案：Nginx 是一个常见的开源软件，主要用于以下用途：

A. 作为Web服务器：Nginx 可以作为静态或动态内容的 HTTP 服务器，处理客户端的请求，并向客户端提供网页、图像、视频等内容。

C. 正向代理：Nginx 可以作为正向代理服务器，通过中间人的方式转发客户端请求，并将响应返回给客户端，隐藏了真实的服务器。

D. 反向代理：Nginx 也可以作为反向代理服务器，接收客户端的请求，并将请求转发给后端的服务器，然后将后端服务器的响应返回给客户端。

B 选项 "作为java服务器" 不是 Nginx 的常见使用方式，因为 Nginx 本身并不直接支持 Java 应用程序的执行。Java 应用程序通常需要使用 Java Servlet 容器（如 Tomcat、Jetty）来运行。

因此，正确的选项是 A 、C 和 D。

### 添加样式的方式

```ABCD
A.外部引用式：即将样式单独放到一个文件夹中，然后用link标签引入页面的形式。如:link rel="stylesheet" type
B.嵌入式：即用<style>.classname{width:100px;}</style>标签括起来写在页面中的样式
C.导入样式：@import url(css/style.css)
D.内联式：即直接加在标签上的样式如：<div style="width.100px:"></div>
```

### 下列哪些属于ECMAScript包含的数据类型

```ABD
A.Object
B.NulL
C.Double
D.Undefined
```

ECMAScript 是 JavaScript 的规范标准，它定义了一种基本的数据类型集合。根据 ECMAScript 的规范，包含的数据类型有：

A. Object：对象是 ECMAScript 中最常见的数据类型，它可以表示复杂的数据结构。

B. Null：null 是表示空值或者空对象引用的特殊值。

C. Double 并不是 ECMAScript 包含的数据类型。它通常用于表示双精度浮点数（即双精度小数）的数据类型。ECMAScript 中的数字类型是 Number，用于表示整数和浮点数。

D. Undefined：undefined 是表示未定义值的特殊值，当变量声明但没有赋值时，会被默认设置为 undefined。

### Docker组件都有哪些

```ABCD
A.仓库
B.镜像
C.容器
D.dockfile
```

A. 仓库（Registry）：Docker 仓库是用于存储和分享 Docker 镜像的中央存储库。其中最常见的是 Docker Hub，它是一个公共的 Docker 仓库，包含了大量的官方和社区维护的镜像。

B. 镜像（Image）：Docker 镜像是一个只读的模板，用于创建 Docker 容器。它包含了运行应用程序所需的所有文件、依赖和配置。镜像可以通过构建（Build）或者拉取（Pull）的方式获取。

C. 容器（Container）：Docker 容器是基于 Docker 镜像创建的运行实例。每个容器都是独立的、可移植的单元，包含了应用程序及其所有依赖项。容器可以被启动、停止、删除等操作，同时也可以与其他容器或宿主机进行通信。

D. Dockerfile：Dockerfile 是一个文本文件，用于定义和构建 Docker 镜像的自动化脚本。它包含了一系列指令，用于描述如何从一个基础镜像构建新的镜像，并设置各种配置选项、添加文件、运行命令等。

因此，正确答案是 A. 仓库，B. 镜像，C. 容器，D. Dockerfile。其中 A、B、C、D 是核心组件。

### 以下哪些手段对优化前端页面展现速度有益

```ABCD
A.GziP
B.优化资源加载顺序
C.减少HTTP请求
D.使用浏览器缓存策略
```

A. Gzip：使用 Gzip 压缩可以减小前端资源（如 CSS、JavaScript 文件）的大小，从而加快下载速度。

B. 优化资源加载顺序：通过合理安排资源加载顺序，例如将关键资源放在首位、异步加载非关键资源等，可以提高页面的展现速度。

C. 减少 HTTP 请求：减少页面中的 HTTP 请求次数可以显著提升页面加载速度。这可以通过合并和压缩文件、使用 CSS 精灵图、使用字体图标等方式实现。

D. 使用浏览器缓存策略：利用浏览器缓存可以减少对服务器的请求，从而加快页面加载速度。合理设置缓存头和缓存策略，使得页面资源能够在浏览器端进行缓存，提高页面的响应速度。

因此，正确答案是 A. Gzip、B. 优化资源加载顺序、C. 减少 HTTP 请求和 D. 使用浏览器缓存策略。

## 判断

```
1.使用Nginx作为正向代理，支持代理HTTP站点和HTTPS站点。

2.JavaScript 语言的对象继承是通过接口继承实现的。

3.脚手架是一种创建项目初始文件的工具。

4.在JavaScript中介者模式中，消息统一由中介者对象发布，所有订阅者对象间接被中介者管理。
```

1. 正确。Nginx 可以作为正向代理，支持代理 HTTP 和 HTTPS 站点。通过配置适当的代理规则，Nginx 可以接收客户端请求并转发到目标站点，实现代理功能。

2. 错误。JavaScript 语言的对象继承是通过原型链继承实现的，而不是通过接口继承。JavaScript 中的对象可以通过原型链关系，继承其他对象的属性和方法。

3. 正确。脚手架是一种用于创建项目初始文件和目录结构的工具。它可以提供项目的基本框架和配置，使开发人员可以快速开始开发，避免重复的初始化工作。

4. 正确。在 JavaScript 中的中介者模式，也称为发布-订阅模式或事件模式，中介者对象充当了消息的发布者和订阅者之间的调度者。消息的发布者不直接与订阅者进行通信，而是通过中介者来发布消息，中介者负责将消息传递给相关的订阅者对象，实现对象间的解耦和集中管理。

# 2022/11/22 补考总结

这次考试相比前几次相对容易，没有新增知识点，主体以nginx（15+），JavaScript，html，css三者结合（10-15），剩下部分判断大部分是测试，ios/android(1-2),未出现设计模式相关考题。

前端题有十七道，nginx大概有7道，正则有1道,构建有3道，ativity 1道，Devops，AsyncTask，LAMP，度量指标，变更追溯，测试，sql语句。

## 单选

### 在Android工程中新建了一个activity，需要在哪个xml文件中声明一下

```D
A.layout.xml
B.Main.xml
C.String.xml
D.AndroidMainifest.xml
```

在 Android 工程中新建一个 Activity，需要在 D. AndroidManifest.xml 文件中进行声明。

AndroidManifest.xml 是 Android 应用程序的清单文件，它包含了应用程序的元数据和配置信息，包括应用程序的组件（如 Activity、Service、BroadcastReceiver）声明、权限声明、应用程序的名称、图标等信息。

在 AndroidManifest.xml 中，可以使用 `<activity>` 元素来声明新建的 Activity。在 `<activity>` 元素中，需要指定 Activity 的名称、标签、主题等属性。这样，Android 系统才能够正确识别和启动这个新建的 Activity。

### 下面哪一个不属于js的六种基本数据类型？

```C
A.Null
B.Undefined
C.Object
D.String
```

### 下列不属于service生命周期的方法是？

```D
A.onCreate
B.onBind
C.onDestroy
D.onStop
```

在 Android 中，Service 是一种用于执行长时间运行操作或在后台处理任务的组件。Service 具有以下生命周期方法：

1. onCreate(): 当 Service 被创建时调用。在该方法中，可以进行初始化操作和准备资源的加载。

2. onStartCommand(Intent intent, int flags, int startId): 当调用 startService() 方法启动 Service 时调用。在该方法中，可以处理需要在后台执行的任务。返回值用于指定 Service 的行为，例如在被系统杀死后如何重启等。

3. onBind(Intent intent): 当调用 bindService() 方法绑定 Service 时调用。在该方法中，可以返回一个 IBinder 接口的实现，用于客户端与 Service 进行通信。

4. onUnbind(Intent intent): 当调用 unbindService() 方法解绑 Service 时调用。在该方法中，可以进行资源释放和清理操作。

5. onDestroy(): 当 Service 被销毁时调用。在该方法中，可以释放所有资源，停止后台任务等。

需要注意的是，Service 的生命周期是由客户端的操作（如启动、绑定、解绑等）以及系统的资源情况来决定的。系统可能会根据需要销毁或重新创建 Service。

这些生命周期方法提供了在 Service 的不同阶段执行逻辑和资源管理的机会，以便开发者可以控制和优化 Service 的行为和性能。

### 执行结果

```js
Var i=2，
for（var i=0,i<10,i++）{};
console.log(i) // 10
```

输出结果为 10。在 `for` 循环中重新定义了变量 `i`，因此会影响到外部定义的同名变量。这种变量声明会提升到函数或全局作用域的顶部，所以外部的 `var i=2` 实际上被覆盖了。如果想要避免这种情况，可以使用 `let` 或 `const` 关键字来声明变量，以创建块级作用域。

### 程序输出

```js
var a="undefined";
var b="false";
var c="";
function assert(aVar){
  if(aVar)     
    alert(true);
  else  
    alert(false);
}
assert(a);
assert(b);
assert(c);
```

```B
A.true，true，true
B.true，true，false
C.false，false，true
D.false，false，false
```

### 下列代码中hasOwnProperty的作用是？

```
var obj={}
obj.hasOwnProperty("val")
```

```B
A.判断obj对象是否具有val的值
B.判断obj对象是否具有val属性
C.判断obj的原型对象是否具有val的属性
D.判断obj的原型对象是否具有val的值
```

`hasOwnProperty()` 是 JavaScript 中的一个对象方法，用于检查对象是否具有指定的属性。

### 块级元素有哪些？

在 HTML 中，常见的块级元素包括：

1. `<div>`：定义一个文档区块。

2. `<p>`：定义段落。

3. `<h1>` - `<h6>`：定义标题，其中 `<h1>` 是最高级别的标题，而 `<h6>` 是最低级别的标题。

4. `<ul>`：定义无序列表。

5. `<ol>`：定义有序列表。

6. `<li>`：定义列表项，在无序列表或有序列表中使用。

7. `<table>`：定义表格。

8. `<form>`：定义表单。

9. `<header>`：定义页面或区块的页眉。

10. `<footer>`：定义页面或区块的页脚。

11. `<section>`：定义文档中的节（section）。

12. `<article>`：定义独立的文章内容。

13. `<nav>`：定义导航链接的容器。

14. `<aside>`：定义页面的侧边栏内容。

15. `<blockquote>`：定义块引用。

这只是块级元素的一些常见示例，还有其他的块级元素。块级元素通常会在页面上==显示为一个独立的块，并会独占一行或一块空间。==

### BOM 的核心对象是？

```C
A.Location
B.History
C.Window
D.Screen
```

1. Location（位置）对象提供了与当前窗口加载的文档相关的信息和操作。它包含了 URL、主机名、路径、查询参数等信息，可以用于获取和修改当前窗口的 URL 地址。

2. History（历史）对象用于管理浏览器窗口的浏览历史记录。它提供了向前和向后导航、加载指定页面、获取当前历史记录状态等功能。

3. Window（窗口）对象是 BOM 的核心对象，代表了一个浏览器窗口或一个框架。它提供了许多方法和属性，用于控制和操作浏览器窗口，包括打开和关闭窗口、弹出对话框、定时器、框架之间的通信等。

4. Screen（屏幕）对象提供了关于用户屏幕的信息，如屏幕尺寸、颜色深度等。它可以用于根据屏幕大小进行布局调整或提供与屏幕相关的功能。

### html5中不在支持下面那个元素

```D
A.P
B.Ins
C.Menu
D.Font
```

A. P（段落）是HTML标签中的一个元素，用于定义段落文本。

B. Ins（插入）是HTML标签中的一个元素，用于表示插入的文本，通常会带有下划线或其他样式来标识新添加的内容。

C. Menu（菜单）是HTML标签中的一个元素，用于定义菜单列表。

D. Font（字体）是HTML标签中的一个元素，用于指定文本的字体样式，包括字体类型、大小、颜色等。

### 哪些方法不可用于显示指定目标组件（Android）

```C
A.setClass（）
B.setComponent()
C.getClassName()
D.setClassName()
```

A. setClass() 方法：这个方法并不常见，可能是指在特定框架或库中使用的自定义方法，因此无法确定其功能和可用性。

B. setComponent() 方法：这个方法可能是拼写错误，正确的拼写应该是 setComponent()。然而，没有一个常见的标准方法名为 setComponent()，用于显示指定目标组件。

C. getClassName() 方法：这个方法用于获取对象的类名，但它与显示指定目标组件无关。通常，用于显示指定目标组件的方法可能会涉及到查找、选择、设置或更新组件的属性、样式、位置等。

D. setClassName() 方法：这个方法用于设置对象的类名，但它与显示指定目标组件也无关。类名通常用于为组件应用特定的样式或选择器。

### 执行Array.from(‘hello’)后，字符串变为

```A
A.['h', 'e', 'l', 'l', 'o']
B.['hello']
C.Hello''
D.['h']
```

Array.from() 是 JavaScript 中的一个静态方法，用于从可迭代对象（iterable）或类数组对象创建一个新的数组实例。可以通过指定映射函数对元素进行转换或处理。

语法：`Array.from(iterable, mapFn, thisArg)`

参数：

`iterable`：必需，一个可迭代对象或类数组对象，用于转换成数组。

`mapFn`（可选）：一个映射函数，用于对数组中的每个元素进行转换或处理。

`thisArg`（可选）：执行 mapFn 时的 this 值。

返回值：一个新的数组实例，其中包含从可迭代对象或类数组对象转换而来的元素。

示例用法：
1. 从字符串创建数组：
   ```javascript
   const str = 'hello';
   const arr = Array.from(str);
   console.log(arr); // ['h', 'e', 'l', 'l', 'o']
   ```

2. 从类数组对象创建数组：
   ```javascript
   const nodeList = document.querySelectorAll('p');
   const arr = Array.from(nodeList);
   console.log(arr); // [p1, p2, p3, ...]（包含所有选中的 <p> 元素）
   ```

3. 使用映射函数进行转换：
   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const squared = Array.from(numbers, x => x * x);
   console.log(squared); // [1, 4, 9, 16, 25]
   ```

### vue.js中用于在表单元素创建双向绑定的指令是？

```B
A.v-if
B.v-model
C.v-bind
D.v-binding
```

A. v-if 是用于条件性地渲染元素的指令，它根据指定的表达式的真假来决定是否渲染该元素。

B. v-model 是用于在表单元素（如 input、select、textarea）和 Vue.js 实例的数据之间创建双向数据绑定的指令。它将表单元素的值与 Vue.js 数据对象的属性进行关联，实现数据的同步更新。

C. v-bind 是用于绑定 HTML 特性的指令，它可以动态地将指定的属性绑定到 Vue.js 实例的数据或计算属性上。

D. v-binding 并不是 Vue.js 中的有效指令。

### 下列全部属于css单位是？

```D
A.pt sp px
B.Px dp %
C.Sp dp %
D.% px em
```

- pt（point）：用于打印的绝对长度单位，通常用于印刷和排版领域。
- sp（scalable point）：类似于 pt 单位，但会根据用户设置的字体大小进行缩放，主要用于屏幕上的文本显示。
- px（pixel）：像素单位，相对于显示设备上的一个物理像素。
- dp（density-independent pixel）：密度无关像素，用于在 Android 开发中表示长度，与像素密度相关，适应不同屏幕密度的设备。
- %（百分比）：相对于父元素的尺寸进行计算的相对单位。
- em：相对长度单位，相对于当前元素的字体大小，也可以继承父元素的字体大小。

### margin属性设置边距的顺序是？

```C
A.左右上下
B.上下左右
C.上右下左
D.下右上左
```

```css
margin: 10px 20px; /* 上下为10像素，左右为20像素 */
margin: 10px 20px 30px; /* 上为10像素，左右为20像素，下为30像素 */
margin: 10px 20px 30px 40px; /* 上为10像素，右为20像素，下为30像素，左为40像素 */
```

### math.clz32()的返回值？

```A
A.32
B.0
C.NAN
D.Undefined
```

`Math.clz32()` 是 JavaScript 中的一个静态方法，用于返回一个数的 32 位二进制表示中的==前置零的数量==。返回值范围是 0 到 32。

示例用法：
```javascript
console.log(Math.clz32(1));     // 31  (二进制表示：00000000000000000000000000000001，前导零的数量：31)
console.log(Math.clz32(100));   // 25  (二进制表示：00000000000000000000000001100100，前导零的数量：25)
console.log(Math.clz32(1000));  // 22  (二进制表示：00000000000000000000001111101000，前导零的数量：22)
console.log(Math.clz32(10000)); // 19  (二进制表示：00000000000000000011000011010000，前导零的数量：19)
console.log(Math.clz32(0));     // 32  (二进制表示：00000000000000000000000000000000，前导零的数量：32)
```

### DOM事件流将事件分为哪几个阶段？

```A
A.捕获阶段 目标阶段 冒泡阶段
B.冒泡阶段 目标阶段 捕获阶段
C.捕获阶段 目标阶段 触发阶段
D.捕获阶段 冒泡阶段 触发阶段
```

### HTML5中不支持的视频有

```D
A.Ogg
B.Mp4
C.Webm
D.Flv
```

HTML5 中支持的常见视频格式：

1. MP4（MPEG-4 Part 14）：这是一种常见的视频容器格式，广泛支持并被大多数现代浏览器所支持。

2. WebM：这是一种开放的多媒体容器格式，支持高质量的视频和音频编码。它是由Google推出的，并得到了现代浏览器的广泛支持。

3. Ogg：这是一种免费开放的媒体容器格式，支持音频和视频编码。Ogg Vorbis 是一种常见的音频编码格式，Ogg Theora 是一种常见的视频编码格式。

请注意，尽管 HTML5 支持这些视频格式，但具体支持哪种格式取决于用户的浏览器和操作系统。因此，在使用视频时，建议提供多个格式的视频源以确保在各种浏览器和设备上的兼容性。

## 多选

### Localstorage正确的是

```ABD
A.localStorage 拓展了 cookie 的 4K 限制。
B.localStorage有5M的大小（类似这个意思） 
C.关闭页面后会自动删除缓存
D.在浏览器的隐私模式下面是不可读取的。
```

### oocss的基本原则有哪些？

```AB
A. 分离容器和内容
B. 分离结构和外观
C. 分离容器和外观
D. 分离结构和内容
```

OOCSS（Object-Oriented CSS，面向对象的 CSS）是一种组织和编写可重用、可扩展的 CSS 的方法论。它强调将样式抽象为可重复使用的组件和对象，以提高代码的可维护性和可扩展性。OOCSS 的基本原则包括：

1. 分离结构和样式：将 HTML 结构与样式分离，避免将样式信息直接嵌入到 HTML 标签中，而是使用类名或选择器来定义样式。

2. 拆分样式和内容：将样式定义为独立的类或对象，而不是与特定的 HTML 内容耦合。样式应该可重用于不同的 HTML 结构，增加样式的灵活性和复用性。

3. 使用模块化和可重用的组件：将样式抽象为可重复使用的组件或对象。通过定义一致的样式模块，可以在不同的页面和应用中重复使用，并减少代码的冗余。

4. 保持样式的通用性：避免使用具体的、与特定上下文相关的样式，而是使用更通用的样式定义。这样可以使样式更具灵活性，适应不同的上下文和布局。

5. 使用层叠和继承：通过层叠和继承的方式来构建样式。通过继承和扩展基础样式，可以减少重复的样式定义，并保持一致性和可维护性。

6. 对象和组件的命名：使用有意义且可重用的命名约定来标识对象和组件。命名应该清晰描述对象的功能和用途，以便其他开发者能够理解和使用。

7. 考虑响应式设计：在编写样式时考虑响应式设计，使组件能够适应不同的屏幕尺寸和设备。

这些原则帮助开发者在编写 CSS 时提供一种结构化的方法，并鼓励可重用、可维护的代码。通过遵循 OOCSS 的原则，可以提高代码的可扩展性、灵活性和可维护性。

### 构建包含

```
A.运行   
B.链接     
C.编译      
D.提交
```

### 变更追溯包括

```
A.变更人员  B.变更内容  C.变更时间   D.变更原因
```

变更管理是指对软件系统或项目进行修改或更新的过程和实践。在软件开发中，变更管理旨在确保对系统的变更进行有效的控制、跟踪和审计。变更管理涉及记录、追踪和评估对系统的任何变更，以便了解变更的原因、内容、时间和执行人员。

通过对变更进行追溯，可以提供对变更历史的全面了解，包括了解谁做出了什么样的变更，何时做出的以及为什么做出的变更。这有助于团队或组织更好地管理变更，确保变更的正确性、一致性和可追踪性，并为后续的维护和升级工作提供依据。

变更追溯的内容通常包括==变更人员、变更内容、变更时间和变更原因==，这些信息可以用于跟踪和审查变更，并为团队成员或利益相关者提供必要的上下文和背景。

### Interator遍历

迭代器（Iterator）是一种用于遍历集合或序列的对象。通过使用迭代器，我们可以按照特定的顺序逐个访问集合中的元素，而不需要直接访问底层的数据结构。

在许多编程语言中，迭代器模式提供了一种统一的遍历方式，使得不同类型的集合可以使用相同的迭代器接口进行遍历。

遍历集合时，迭代器提供了以下常用的方法：

1. `next()`: 返回集合中的下一个元素，并将迭代器移动到下一个位置。
2. `hasNext()`: 检查集合中是否还有下一个元素，返回布尔值。
3. `remove()`: 从集合中删除当前迭代器指向的元素（在一些语言中可能不支持）。

使用迭代器进行遍历的一般模式是使用循环结构，不断调用 `next()` 方法，直到遍历完所有的元素。

### 前后端分离的优势

```
1、独立开发
2、松耦合
3、前端技术选型自由
4、提升性能和扩展性
5、多端适配
```

## 判断

```
1.sassdoc为创建一系列开放和个性化的文档页面提供了工具。
2.JavaScript语言的对象继承是通过接口继承实现的。
3.正则表达式中，\B 描述单词的前或后边界。
4.Object.assign()可以拷贝继承属性
```

1、SassDoc 是一个用于生成 Sass（Syntactically Awesome Style Sheets）文档的工具。它是一个文档生成器，可以解析 Sass 文件中的注释，并生成详细的、可定制的 Sass 文档页面。

SassDoc 的主要功能包括：

1. 解析注释：SassDoc 可以解析 Sass 文件中的注释，包括普通注释和特殊注释。

2. 自动生成文档：通过解析注释，SassDoc 可以自动生成关于变量、混合器、函数、样式规则等 Sass 元素的文档。

3. 生成文档页面：SassDoc 可以生成结构化的文档页面，展示生成的文档内容。这些页面可以包含变量、混合器、函数的说明、使用示例、参数列表等信息。

4. 支持定制化：SassDoc 提供了丰富的配置选项，可以定制生成文档的样式、主题、布局等。

通过使用 SassDoc，开发者可以为 Sass 项目生成易于阅读和理解的文档，提供给其他开发者或团队成员参考和使用。这有助于提高代码的可维护性、可重用性和可理解性。

2、JavaScript 语言的对象继承是通过原型链继承实现的，而不是通过接口继承。JavaScript 中的对象可以通过原型链继承来继承属性和方法。

3、在正则表达式中，\b（而不是\B）表示单词的边界。具体来说，\b 匹配一个位置，该位置位于一个单词字符和一个非单词字符之间，或者位于字符串的开头或结尾与单词字符之间。而\B 表示非单词的边界，即与\b 相反，它匹配一个位置，该位置位于两个连续的单词字符或两个连续的非单词字符之间。

4、`Object.assign()` 方法用于将一个或多个源对象的可枚举属性复制到目标对象中，而不会拷贝继承属性。继承属性是指通过原型链继承而来的属性，它们存在于对象的原型链上，并且不能通过对象本身进行复制或修改。

```js
Object.assign(target, ...sources)
// 其中，target 是目标对象，sources 是一个或多个源对象。Object.assign() 方法会将源对象的可枚举属性复制到目标对象中，并返回目标对象。
```

2022/11/21 补考总结

前端有个十五六道，nginx大概4、5到，安卓ios有3道4道、设计模式2道、剩下都是部署测试的

## 单选

### 滴滴打车支付，Activity会发生的生命周期回调顺序

```
onPause() ——> onCreate() ——> onStart() ——> onResume()
```

### 代码运行结果

```js
var a, b;
(function() {
  alert(a);
  alert(b);
  var a = b = 3;
  alert(a);
  alert(b);
})();
alert(a);
alert(b);
```

```A
A.undefined，undefined，3，3，undefined，3
B.undefined，undefined，3，3，undefined，undefined
C.undefined，undefined，3，3，0，0
D.0，0，3，3，undefined，undefined
```

请注意，这段代码中存在一个常见的陷阱，即变量声明和赋值的顺序导致变量作用域和值的意外结果。

1. 第一个立即执行函数中的 `alert(a)`：显示 `undefined`，因为在函数内部重新声明了局部变量 `a`，但还没有赋值。
2. 第一个立即执行函数中的 `alert(b)`：显示 `undefined`，因为在函数内部重新声明了局部变量 `b`，但还没有赋值。
3. 第一个立即执行函数中的 `alert(a)`：显示 `3`，因为在函数内部将局部变量 `a` 和全局变量 `b` 都赋值为 `3`。
4. 第一个立即执行函数中的 `alert(b)`：显示 `3`，因为在函数内部将全局变量 `b` 赋值为 `3`。
5. 最外层的 `alert(a)`：显示 `undefined`，因为在全局作用域中没有声明和赋值变量 `a`。
6. 最外层的 `alert(b)`：显示 `3`，因为全局变量 `b` 的值在函数内部被赋值为 `3`。

### 灰度发布是指

灰度发布（Gray Release）是一种软件发布策略，用于逐步将新版本的软件或功能推出给部分用户，以便在真实环境中进行测试和评估，降低发布风险和最大化用户体验。

在灰度发布中，新版本或功能不是一次性全部发布给所有用户，而是先发布给一小部分用户，这些用户被称为灰度用户。随后，通过监控和收集反馈，对新版本或功能进行验证和优化。如果没有出现严重的问题或负面影响，逐步增加灰度用户范围，最终达到全量发布的目标。

**灰度发布的优势包括：**

1. 风险控制：通过逐步发布给部分用户，可以及早发现和解决可能存在的问题，减少对整个用户群体的影响。

2. 用户反馈：通过与灰度用户的互动和反馈，可以了解他们的体验和意见，从而及时进行改进和优化。

3. 性能评估：灰度发布提供了在真实环境中评估新版本或功能性能的机会，可以收集性能指标和数据，进一步优化系统。

4. 逐步推进：灰度发布允许渐进式推进，有助于逐步引入新功能或变更，使用户适应和接受变化的过程更平滑。

需要注意的是，灰度发布需要仔细规划和监控，确保在控制范围内进行，并及时处理可能的问题。同时，也需要根据实际情况选择合适的灰度比例和发布策略，以最大程度地减少风险并提升用户体验。

### 以下哪个是前端常用的构建工具？

```A
A.Webpack
B.Vue
C.Element
D.React
```

Webpack 是一个模块打包工具，可以将多个 JavaScript 文件及其依赖打包成一个或多个静态资源文件。它支持代码分割、模块化管理、代码压缩等功能，是前端开发中最常用的构建工具之一。

Webpack的主要功能和特点包括：

1. 模块化支持：Webpack可以处理各种类型的模块，如JavaScript、CSS、图片等，并支持模块之间的依赖关系管理。
2. 打包和压缩：Webpack将所有依赖的模块打包成一个或多个最终的部署文件，以便在生产环境中使用。它还可以对这些文件进行压缩和优化，以提高加载速度和性能。
3. 资源管理：Webpack可以处理各种类型的静态资源，如图片、字体等，并根据需要进行合并、转换和优化。
4. 插件系统：Webpack具有丰富的插件系统，可以扩展其功能，例如代码分割、热模块替换、自动化构建等。
5. 开发环境支持：Webpack提供了开发服务器和开发工具链的支持，包括自动刷新、模块热替换等功能，以提高开发效率。

通过配置Webpack的入口文件、输出文件路径、加载器（Loaders）和插件（Plugins），开发人员可以根据项目的需求进行自定义配置和打包优化。

总而言之，Webpack是一个强大的静态模块打包工具，能够帮助开发人员处理模块之间的依赖关系、打包和优化资源，并提供丰富的插件系统和开发支持，使前端项目的构建和部署更加高效和可靠。

### Nginx代理服务器向后端服务器发出read/write请求，默认时间

Nginx代理服务器向后端服务器发出read/write请求的默认超时时间可以通过配置项来设置。具体的配置项名称和默认值可能会因Nginx的版本和具体的配置而有所不同。

以下是一些与代理请求超时相关的Nginx配置项及其默认值：

1. proxy_read_timeout：此配置项定义了向后端服务器发出读取请求（包括获取响应数据）的超时时间。默认值为60秒。

2. proxy_send_timeout：此配置项定义了向后端服务器发出写入请求（包括发送请求数据）的超时时间。默认值为60秒。

需要注意的是，这些默认值可能会因为Nginx的版本、编译选项和配置文件中的具体设置而有所不同。可以在Nginx的配置文件中找到相应的配置项，并根据实际需求进行调整。

此外，还可以使用其他配置项来进行更详细的调优，例如调整Nginx与后端服务器之间的连接超时时间、缓冲区大小等。根据具体情况，可以参考Nginx的官方文档或相关资料来了解更多配置选项和其默认值。

## 多选

### 下列哪些操作会使用线程释放锁资源

```
A.join（）
B.Sleep（）
C.Wait（）
D.Yield（）
```

在给出的选项中，下列操作会使用线程释放锁资源：

A. join()：该操作会使当前线程等待被调用的线程执行完毕，然后再继续执行。在等待期间，当前线程会释放锁资源，允许其他线程获取该锁。

C. Wait()：该操作是在线程等待某个条件满足时调用的，它会释放锁资源并使当前线程进入等待状态，直到其他线程通过notify()或notifyAll()来通知该线程继续执行。

因此，选项 A 和 C 和是会使用线程释放锁资源的操作。

B. Sleep()：该操作是使线程进入休眠状态一段指定的时间。在休眠期间，线程不会释放锁资源。

D. Yield()：该操作是线程主动放弃当前的执行权，使其他具有相同优先级的线程有机会执行。虽然并非直接释放锁资源，但通过让其他线程执行，间接地允许其他线程获取锁资源。

### 制品库是什么？

制品库（Artifact Repository）是用于存储和管理软件构建产物（即制品）的中央化存储库。它是软件开发过程中的关键组成部分，用于管理和分发各种构建产物，例如编译后的程序文件、库文件、依赖包、镜像文件等。

制品库通常提供了版本控制、元数据管理、访问权限控制等功能，以便团队成员可以方便地共享和获取构建产物。它有助于提高开发效率、确保构建产物的一致性和可追溯性，并支持自动化部署和持续集成/交付流程。

常见的制品库包括 Maven Repository（用于 Java 生态系统）、NPM Registry（用于 Node.js 生态系统）、Docker Registry（用于容器镜像）、NuGet Gallery（用于 .NET 生态系统）等。此外，还有一些通用的制品库管理工具，如 JFrog Artifactory、Sonatype Nexus 等，它们支持多种编程语言和技术栈，并提供了更广泛的功能和集成选项。

### 以下属于制品库的是：（）

```
A. 基础镜像
B. 项目镜像
C. 开源组件
D. 某某组件
```

A. 基础镜像：基础镜像是构建容器化应用程序时使用的初始镜像，通常包含操作系统和基本的运行时环境。将基础镜像存储在制品库中有助于集中管理和版本控制。

B. 项目镜像：项目镜像是构建完成的容器镜像，包含了应用程序代码、依赖项和配置等。将项目镜像存储在制品库中可以方便地进行版本管理和分发。

C. 开源组件：开源组件是开源社区或第三方提供的软件库或工具，用于开发中使用。将开源组件存储在制品库中可以方便团队成员共享和使用，并确保组件的版本和来源可控。

D. 某某组件：根据提供的选项，无法确定具体指代的是哪个组件。如果是指特定的组件或自定义的组件，将其存储在制品库中也是常见的做法，以方便团队内部共享和管理。

因此，选项 A、B、C 和 D 都属于制品库中的内容。制品库用于存储和管理各种构建产物和依赖项，包括镜像、组件和其他相关文件。

### Ribbon配置

Ribbon是一个负载均衡客户端，常用于微服务架构中。它可以与服务发现组件（如Eureka）结合使用，根据一定的负载均衡策略自动选择可用的服务实例进行请求转发。

在使用Ribbon时，需要进行一些配置以定义负载均衡的行为和规则。以下是一些常见的Ribbon配置项：

1. 服务列表配置：指定需要进行负载均衡的服务列表，可以通过配置服务名称或服务实例的URL。

2. 负载均衡策略配置：定义负载均衡的算法和规则，包括轮询（Round Robin）、随机（Random）、加权轮询（Weighted Round Robin）等。

3. 超时配置：设置请求超时时间，用于判断请求是否超时，并进行相应的处理。

4. 重试配置：指定在请求失败时是否进行重试，并配置重试的次数和间隔。

5. 服务实例状态配置：定义服务实例的健康检查机制和状态判断规则，以决定是否将请求转发给该实例。

这些配置可以通过属性文件、注解或编程方式进行设置，具体的配置方式取决于所使用的框架和技术栈。

需要注意的是，Ribbon在Spring Cloud中已经被标记为不推荐使用，并计划在未来的版本中移除。取而代之的是Spring Cloud LoadBalancer和服务发现组件的集成。因此，在使用Ribbon时，建议参考相关的官方文档和最新的推荐做法。

### 流水线建立全流程的自动化能力的环节

1. 持续集成（Continuous Integration）：这是自动化流水线的基础环节，它涉及将开发团队的代码集成到共享存储库中，并进行自动化构建和测试。持续集成的关键是确保代码的频繁集成和自动化测试，以便尽早发现和解决问题。

2. 自动化构建（Automated Build）：在持续集成的基础上，自动化构建环节负责将源代码转换为可部署的软件包或容器镜像。这包括编译源代码、打包依赖项、执行静态代码分析等操作。常见的构建工具包括Maven、Gradle、Webpack等。

3. 自动化测试（Automated Testing）：自动化测试环节用于执行各种类型的测试，包括单元测试、集成测试、端到端测试等。自动化测试可以通过自动化测试框架和工具来实现，例如JUnit、Selenium、Cypress等。测试结果应该及时反馈给开发团队，以便修复和改进代码。

4. 自动化部署（Automated Deployment）：自动化部署环节负责将构建好的软件包或容器镜像部署到目标环境中，例如测试环境、预发布环境和生产环境。这通常涉及自动化配置管理、容器编排和云平台管理等。常用的部署工具有Docker、Kubernetes、Ansible等。

5. 自动化监控与反馈（Automated Monitoring and Feedback）：自动化监控与反馈环节用于监控应用程序和基础设施的运行状态，并及时反馈给相关团队。这可以通过监控工具和日志分析来实现，以便快速发现和解决问题。

通过在这些环节中应用自动化工具和技术，可以实现软件开发和交付过程的高效、一致和可靠性。同时，它还有助于提高团队的生产力、降低错误率，并支持持续交付和持续部署的实践。

### 属于质量检测工具

```CD
A.Sonarcuber
B.Jacoco
C.代码卫士
D.Maven
```

### 项目部署步骤的目标群体环境

1. 目标群体：项目部署的目标群体是指最终使用该项目或受该项目影响的人群，可能包括以下方面：
   - 最终用户：使用该项目提供的功能或服务的实际用户。
   - 运维团队：负责项目的部署、监控和维护的技术团队。
   - 开发团队：负责项目的开发和维护的技术团队。
2. 环境：项目部署的环境包括以下几个方面：
   - 开发环境：用于开发人员进行代码编写、测试和调试的环境。
   - 测试环境：用于进行系统集成测试、性能测试和用户验收测试的环境。
   - 预生产环境：用于进行最终的系统验证和准备部署到生产环境的环境。
   - 生产环境：项目正式运行和提供服务的环境。
3. 步骤：项目部署的步骤可以包括以下几个方面，具体步骤会根据项目和环境的不同而有所差异：
   - 确定部署计划和策略：制定详细的部署计划，包括时间安排、人员配备和部署策略。
   - 配置环境和依赖：准备好目标环境，并配置所需的运行环境、数据库、缓存等依赖。
   - 打包和部署应用：将项目代码打包成可执行的软件包或容器镜像，并部署到目标环境中。
   - 数据迁移：如果涉及数据库的部署，需要进行数据迁移和数据同步操作。
   - 配置和参数设置：对应用程序进行必要的配置和参数设置，确保其在目标环境中正常运行。
   - 测试和验证：在目标环境中进行系统测试和验证，确保部署的应用程序和环境都正常工作。
   - 监控和调优：配置监控工具和日志记录，以便及时监控和调优部署的应用程序。

## 判断

```1T/2T
1.模块@babel/rehister是实时转码，只适合在开发环境使用
2.关于可视化描述正确的包括部署流水线全员可见
```

1. 模块@babel/register用于实时转码，它主要在开发环境中使用。@babel/register会在运行时将ES6+的代码转换为当前Node.js版本支持的代码，使开发人员可以在开发过程中使用最新的JavaScript语法和功能。在生产环境中，通常不建议使用@babel/register，而是预先将代码转码为目标版本的代码，以提高性能和稳定性。

2. 关于可视化描述部署流水线全员可见是正确的。部署流水线是一种自动化的软件交付过程，涉及从代码提交到应用部署的一系列步骤。可视化描述部署流水线的主要目的是提供一个直观、易懂的界面，用于展示和跟踪整个部署过程。全员可见意味着团队中的所有成员，包括开发人员、运维人员、项目经理等，都可以查看和了解部署流水线的状态、进度和结果，以便及时发现和解决问题，保证项目的顺利进行。这种可视化描述可以通过使用工具和平台，如Jenkins、GitLab CI/CD、Azure DevOps等来实现。

# 2022/11/18补考总结

Js大概十几二十道，原题五六道，设计模式三四道、大部分都是nginx的配置题，差不多有十几道，devops的题五六道，vue的三四道，其他题型七八道

### 输出结果

```js
var value = 5 + 3 + "7";
var value2 = 3 + "7";
```

```js
// 这行代码的执行结果是"87"。在这个表达式中，首先进行数值相加的操作5 + 3得到结果8，然后将结果8与字符串"7"进行字符串拼接，得到最终的字符串"87"。

// 这行代码的执行结果是"37"。在这个表达式中，由于其中一个操作数是字符串"7"，所以会进行字符串拼接的操作，将数字3转换为字符串，然后将两个字符串拼接在一起，得到最终的字符串"37"。
```

### 以下哪个不是 nginx 的负载均衡算法

```
A.加权轮询
B.什么哈希
C.cookie
D.url
```

A. 加权轮询（Weighted Round Robin）：根据服务器的权重分配请求，权重越高的服务器接收到的请求比例越高。

B. 哈希（Hash）：使用请求的某个特定属性（如客户端 IP 或 URL）计算哈希值，然后将请求分发到具有对应哈希值的服务器上，确保相同属性的请求始终发送到同一台服务器。

C. Cookie：基于请求中的特定 Cookie 值，将请求发送到具有相同 Cookie 值的服务器上，适用于需要维持会话的应用。

D. URL：并不是 Nginx 的负载均衡算法，而是请求中的一部分信息。

### 以下说法正确的是

```js
function * gen() { yield 1; yield 2; yield 3; } 
```

```CD
A.gen()执行后返回2
B.gen()执行后返回undefined
C.gen()执行后返回一个Generator对象
D.gen()执行后返回1
```

### CommonsChunkPlugin

通常用于将多个入口点（entry points）中==共享的代码==提取为一个==单独的文件==，以便于==缓存和重用==。

具体来说，CommonsChunkPlugin是一个Webpack插件，它可以在构建过程中将重复的模块或共享的模块提取出来，并将它们放置在一个单独的chunk中，这个chunk可以被多个入口点引用。这样做的好处是，当多个入口点共享相同的模块时，这些模块可以被提取到公共的chunk中，避免重复加载和浪费。

使用CommonsChunkPlugin可以优化打包后的文件大小，减少重复的模块加载，提高页面加载速度和性能。它常用于处理共享的第三方库、公共组件、公共样式等。

总结来说，CommonsChunkPlugin的主要作用是将共享的代码提取到一个单独的chunk中，以便于复用和优化性能。

### GLSurFaceView 的特性

GLSurfaceView 是 Android 平台上的一个视图控件，用于显示 OpenGL ES 绘制的图形和动画。它具有以下特性：

1. OpenGL ES 支持：GLSurfaceView 提供了与 OpenGL ES 相关的接口和功能，使开发者能够方便地在应用中渲染 2D 和 3D 图形。

2. 双缓冲机制：GLSurfaceView 使用双缓冲机制来避免图像闪烁和绘制的不连续性。它包含一个前缓冲区和一个后缓冲区，绘制操作在后缓冲区中进行，然后交换缓冲区将结果显示在屏幕上，提供平滑的图形更新效果。

3. 独立的渲染线程：GLSurfaceView 在后台创建一个独立的渲染线程，用于执行 OpenGL ES 相关的绘制操作。这样可以避免在主线程中执行耗时的绘制操作，保证应用的响应性和流畅性。

4. 生命周期管理：GLSurfaceView 提供了与 Activity 生命周期的集成，可以通过回调方法（如 onResume()、onPause()）正确地管理渲染线程的启动和暂停，以避免资源浪费和内存泄漏。

5. 触摸事件处理：GLSurfaceView 可以处理触摸事件，提供了相关的触摸事件回调方法，使开发者能够对触摸事件进行处理，实现与 OpenGL ES 相关的交互操作。

6. 多样化的配置选项：GLSurfaceView 提供了许多配置选项，可以根据需要进行自定义设置，例如渲染模式、像素格式、深度缓冲、模板缓冲等。

总的来说，GLSurfaceView 是一个方便的工具，使开发者能够在 Android 应用中使用 OpenGL ES 进行图形渲染，并提供了生命周期管理、触摸事件处理和配置选项等功能，简化了 OpenGL ES 的集成和使用过程。

### Nginx的作用

Nginx 是一个开源的高性能的==Web 服务器==和==反向代理服务器==，它具有以下主要作用：

1. Web 服务器：Nginx 可以作为静态资源服务器，处理和响应来自客户端的 HTTP 请求。它可以快速地传送静态内容，如 HTML 文件、图像、CSS 和 JavaScript 文件等，提供高效的 Web 访问服务。

2. 反向代理服务器：Nginx 可以作为反向代理服务器，代理并转发客户端的请求到后端的多个服务器。它能够根据特定的负载均衡算法将请求分发到不同的后端服务器，提高系统的并发处理能力和可靠性。

3. 负载均衡：作为反向代理服务器，Nginx 可以根据配置的负载均衡算法将请求均匀地分发到多个后端服务器上，以实现负载均衡，提高系统的性能和可扩展性。

4. 高并发处理：Nginx 的事件驱动的异步非阻塞架构使其能够高效地处理大量并发连接，支持高并发的请求处理和数据传输。

5. 静态文件缓存：Nginx 可以缓存静态文件，减少对后端服务器的请求，提高访问速度和效率。

6. SSL/TLS 加密：Nginx 支持 SSL/TLS 协议，能够提供安全的加密通信，保护客户端和服务器之间的数据传输安全。

7. 虚拟主机支持：Nginx 支持虚拟主机配置，可以在一台服务器上托管多个域名或网站，并根据配置将请求正确地路由到对应的虚拟主机。

### 前端任务处理器流程

```
接收任务 ——> 解析任务 ——> 执行任务 ——> 更新界面 ——> 监听事件 ——> 错误处理 ——> 完成任务
```

1. 接收任务：前端任务处理器首先需要接收任务，这可以是用户输入、服务器请求或其他事件触发。

2. 解析任务：接收到任务后，前端任务处理器会解析任务的内容，了解任务的要求和目标。

3. 执行任务：根据任务的要求和目标，前端任务处理器开始执行相应的操作。这可能涉及到修改DOM元素、发送请求、调用API等。

4. 更新界面：任务执行完毕后，前端任务处理器可能需要更新界面以反映执行结果。这可能涉及到更新DOM元素、显示提示信息或错误信息等。

5. 监听事件：前端任务处理器可能需要监听一些事件，以便在事件触发时执行相应的任务。这可以是用户交互、网络请求完成等。

6. 错误处理：在任务执行过程中，前端任务处理器需要处理可能出现的错误情况。这包括捕获和处理异常、显示错误信息等。

7. 完成任务：当任务执行完毕后，前端任务处理器可以进行清理工作，关闭不再需要的资源，或者进行下一步操作的准备。

这个流程可以根据具体的应用场景和需求进行调整和扩展。

### DevOps

DevOps是一种将软件开发（Dev）和信息技术运维（Ops）两个领域进行整合的方法论和实践。它旨在通过改进软件开发团队和运维团队之间的协作与沟通，加快软件交付速度、提高质量和稳定性，以及实现持续交付和持续部署的能力。

DevOps的关键特点和流程包括：

1. 自动化：通过自动化工具和流程，包括构建、测试、部署等，减少人工操作，提高效率和一致性。

2. 持续集成和持续交付：采用持续集成（CI）和持续交付（CD）的实践，使团队能够频繁地集成代码、自动化测试，并快速交付高质量的软件。

3. 配置管理：使用配置管理工具来管理和自动化服务器和基础设施的配置，确保环境的一致性和可重复性。

4. 监控和日志：通过实时监控和日志记录，及时发现和解决问题，提高系统的可用性和性能。

5. 协作与沟通：促进开发团队和运维团队之间的密切合作与沟通，共享知识和责任，减少摩擦和延迟。

6. 安全和合规性：将安全性和合规性考虑纳入整个开发和运维过程，确保系统的安全性和符合相关法规和标准。

DevOps的目标是通过改进团队协作、自动化流程和持续改进，提高软件交付速度、质量和稳定性，同时增强业务的灵活性和创新能力。它是一种文化和方法论的变革，强调跨团队合作和持续学习的重要性。

## 多选

### 版本控制的内容包括（）

```ACD
A. 版本控制系统
B. 单一
C. 管理
D. 分支
```

版本控制的内容主要包括版本控制系统、管理和分支。

版本控制系统是实现版本控制的工具或平台，它可以帮助开发团队跟踪、管理和控制软件代码和文件的不同版本。

管理涉及对版本控制系统中的代码和文件进行有效的组织、维护和共享。

分支是版本控制系统中的一个重要概念，允许开发团队在同一代码库中创建并并行开发不同的代码分支，以便独立地进行特性开发、修复错误或实验性工作，并最终合并回主分支。

### 造成ANR的原因正确的是（）

```
A. 后台200s没处理
B. 前台广播receive
C. 5s内没处理
D. 20s内没处理
```

ANR（Application Not Responding）是指在Android应用程序中，当主线程（UI线程）在一段时间内无法响应用户的输入或界面更新时出现的错误。造成ANR的常见原因包括：

C. 5s内没处理：如果应用程序在主线程上执行的操作超过5秒钟而没有完成，系统将会认为应用程序无响应，触发ANR错误。

D. 20s内没处理：如果应用程序在主线程上执行的广播接收器或服务等操作超过20秒钟而没有完成，系统也会认为应用程序无响应，触发ANR错误。

A. 后台200s没处理：虽然后台操作的执行时间过长可能会对应用程序性能和用户体验产生负面影响，但它不是直接造成ANR的原因。

B. 前台广播receive：前台广播接收器的执行通常是在主线程上进行的，因此如果广播接收器在一段时间内占用了主线程而无法完成执行，也会导致ANR错误。

综上所述，造成ANR的原因是C. 5s内没处理和D. 20s内没处理。

### 接口测试工具有哪些？

1. Postman：Postman是一款功能强大的API开发和测试工具，可以发送HTTP请求、模拟服务器响应、编写和运行自动化测试脚本，并生成测试报告。
2. SoapUI：SoapUI是一款专注于Web服务测试的工具，支持测试SOAP和RESTful接口。它提供了创建、执行和管理接口测试的功能，以及对测试结果进行断言和报告生成的能力。
3. JMeter：JMeter是一个广泛应用于性能测试的工具，但也可以用于接口测试。它支持多种协议，包括HTTP、HTTPS、FTP、SOAP、REST等，能够模拟大量并发请求进行接口测试和负载测试。
4. RestAssured：RestAssured是一个基于Java的开源库，用于编写和执行RESTful接口的自动化测试。它提供了丰富的API和断言功能，支持处理JSON和XML等数据格式。
5. Karate：Karate是一个开源的接口测试框架，基于Cucumber和Gherkin语法，旨在简化RESTful接口的自动化测试。它提供了易于使用的DSL（领域特定语言）和内置的断言功能。
6. HTTPie：HTTPie是一个命令行工具，用于发送HTTP请求和与接口进行交互。它具有直观的语法、可扩展性和易于使用的界面，适用于简单的接口测试和调试。

### Nginx配置文件的块

1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。

2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。

3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。

4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。

5、location块：配置请求的路由，以及各种页面的处理情况。

### hystrix的熔断隔离级别有（）

```AC（答案不确定）
A.	Semaphore
B.	Read uncommitted
C.	Thread
D.	Serializable
```

### 完整的 JavaScript 实现包括哪些内容（）

```ABD
A.	ECMAscript
B.	DOM
C.	Cenvi
D.	BOM
```

### DevOps平台通常提供以下功能

A. 度量：DevOps平台可以提供度量和监控功能，帮助团队了解系统的性能、稳定性和可用性指标。

B. 自动化：自动化是DevOps的核心概念之一，平台可以提供自动化工具和功能，例如自动化部署、自动化测试、自动化构建等，以加快交付流程并减少人工操作。

C. 代码安全扫描：DevOps平台可以集成代码安全扫描工具，帮助团队发现和解决潜在的安全漏洞和风险。

D. 接口测试：DevOps平台可以提供接口测试工具和框架，用于测试和验证应用程序的接口功能和性能。

E. 单元测试：DevOps平台可以支持单元测试，帮助开发人员编写和执行单元测试用例，以确保代码的质量和稳定性。

### 变更管理的主要包括（）

```
A.	变更工程
B.	变更回滚
C.	变更查询
D.	变更追溯
```

### Vue中的keepalive组件

在Vue中，keep-alive是一个内置组件，用于在组件之间缓存和保持状态。它可以帮助提高应用程序的性能和用户体验，特别是在涉及频繁切换的组件之间。

当一个组件包裹在keep-alive组件中时，该组件的状态将被缓存，而不是每次都销毁和重新创建。这样可以节省资源和减少组件的加载时间。以下是keep-alive组件的一些相关功能：

1. 缓存组件状态：keep-alive会缓存包裹的组件的状态，包括数据、DOM状态和组件实例。

2. 生命周期钩子：keep-alive提供了一些额外的生命周期钩子函数，如activated和deactivated。这些钩子函数在组件进入和离开缓存时被调用，可以用于执行特定的操作。

3. include和exclude属性：可以使用include和exclude属性来选择性地缓存组件。include属性指定哪些组件应该被缓存，而exclude属性指定哪些组件不应该被缓存。

4. 组件激活和失活事件：keep-alive组件会触发activated和deactivated事件，可以在这些事件中执行自定义的逻辑，比如请求数据或更新状态。

## 判断

```
1.	Web性能优化的必要手段
2.	trimEnd方法对字符串尾部的换行符无效
3.	数据回滚...变更测试
4.	JavaScript具有自动垃圾回收机制
5.	正则表达式的valueof()方法返回本身
6.	HTTP头部字段
7.	Nginx配置文件中，使用...，参数正值高于负值的优先级
```

1. Web性能优化的必要手段：正确（是的，Web性能优化有许多必要手段，例如使用缓存、压缩资源、减少HTTP请求等来提高网页加载速度和用户体验。）
2. trimEnd方法对字符串尾部的换行符无效：错误（trimEnd方法可以移除字符串末尾的空格、制表符、换行符等空白字符，包括换行符。所以它对字符串尾部的换行符有效。）
3. 数据回滚...变更测试：不完整题目（请提供更多信息以使问题完整。）
4. JavaScript具有自动垃圾回收机制：正确（是的，JavaScript具有自动垃圾回收机制，它负责自动检测不再使用的对象并释放其占用的内存。开发人员无需显式地处理内存管理。）
5. 正则表达式的valueOf()方法返回本身：正则表达式的`valueOf()`方法是JavaScript中的一个内置方法，它用于返回正则表达式本身。这个方法不会对正则表达式进行任何操作或转换，仅仅返回正则表达式对象。
6. HTTP头部字段：正确（是的，HTTP头部包含了各种字段，用于在客户端和服务器之间传递附加信息。一些常见的头部字段包括Content-Type、Authorization、User-Agent等。）
7. Nginx配置文件中，使用...，参数正值高于负值的优先级：错误（在Nginx配置文件中，参数的值不一定遵循正值高于负值的优先级。优先级的具体规则取决于具体的配置指令和上下文。）

# 20221117第一次考试总结

此次考试出现的牛客网原题很少，JS和ES6比重没有想象中的多，很少有程序题，大部分是知识点， CSS的题有五六道，HTML也有五六道， 有一道Ngnix、三道JAVA相关的，有5道左右设计模式的题，有2道火狐IE兼容的题，还有几道是网络基础知识的，有两道题知识点完全没见过。

20221117涉及知识点html、js 20道；css 4道；es6 4道；nginx 1道；webpack 2道；设计模式（4道）：中介者模式、观察者模式 各1道。 Java 1道；ribbon 1道；vue 1道。原题比较多。

选择题：js+es6最多、html较少、css较少、nginx1道、设计模式1道、其他未见过的 2道、程序题6道。程序题考点是var的作用域链，在不同作用域如全局、闭包函数、自调用函数、方法内的声明的互相影响及执行顺序，函数和变量的声明提升，this的指向。Css考点是定位、浮动，html是表单、输入框、多媒体、按钮标签的属性。Nginx考点是nginx的常用配置项。判断题：GeneratorFunction生成器，weakmap、weakset、map、set的异同，promise函数的三个状态。

判断题设计模式占比例较多，安全题多为文件保存上传以及离开桌面的基本常识

# 套卷一

## 单选题

### 对于ECMAScript的描述，以下说法错误的是（）

```D
A.	它是一个重要的标准，并不是javaScript唯一的部分
B.	是一种开放的，国际上广为接受的，标准的脚本语言规范
C.	它主要描述了语法，变量，数据类型，运算符，逻辑控制语句等
D.	ECMAScript遵循了JAVAScript标准  
```

JavaScript是基于ECMAScript标准的实现。ECMAScript定义了JavaScript的核心语言规范，包括语法、变量、数据类型、运算符和逻辑控制语句等。JavaScript是在ECMAScript规范的基础上实现的，它包含了ECMAScript规定的功能，并且添加了许多其他特性，如DOM操作和浏览器API。

### 在 ECMAScript6 中，promise的状态有:()

```ACD
A.	Pending
B.	seccceed
C.	Fulfilled
D.	Rejected
```

### Docker搭建以太坊私有链

要在Docker中搭建以太坊私有链，可以按照以下步骤进行操作：

1. 安装Docker和Docker Compose：确保你的系统上已经安装了Docker和Docker Compose。你可以从官方网站上下载并按照说明进行安装。

2. 创建一个新的目录用于存储私有链的配置文件和数据。在命令行中，通过以下命令创建一个新目录：

   ```bash
   mkdir ethereum-private-chain
   cd ethereum-private-chain
   ```

3. 创建以太坊私有链配置文件：使用文本编辑器创建一个名为 `genesis.json` 的文件，其中包含以太坊私有链的创世块配置。以下是一个示例的 `genesis.json` 文件内容：

   ```json
   {
     "config": {
       "chainId": 1234,
       "homesteadBlock": 0,
       "eip150Block": 0,
       "eip155Block": 0,
       "eip158Block": 0
     },
     "alloc": {
       "YOUR_ACCOUNT_ADDRESS": {
         "balance": "100000000000000000000000"
       }
     },
     "coinbase": "YOUR_ACCOUNT_ADDRESS",
     "difficulty": "1",
     "extraData": "",
     "gasLimit": "2000000",
     "nonce": "0",
     "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
     "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
     "timestamp": "0"
   }
   ```

   请注意替换 `YOUR_ACCOUNT_ADDRESS` 为你的以太坊账户地址。

4. 创建一个 `Dockerfile` 文件：使用文本编辑器创建一个名为 `Dockerfile` 的文件，并将以下内容添加到文件中：

   ```Dockerfile
   FROM ethereum/client-go:stable
   
   COPY genesis.json /root/genesis.json
   
   CMD geth --datadir /root/data init /root/genesis.json && geth --datadir /root/data --networkid 1234 --rpc --rpcaddr "0.0.0.0" --rpcport 8545 --rpcapi "eth,net,web3" --nodiscover
   ```

   这个 `Dockerfile` 文件使用 Ethereum 官方的 Docker 镜像，并将 `genesis.json` 文件复制到容器中。然后，它通过 `geth` 命令初始化私有链并启动节点。

5. 构建Docker镜像：在命令行中，在当前目录下执行以下命令，构建Docker镜像：

   ```bash
   docker build -t ethereum-private-chain .
   ```

   这会根据 `Dockerfile` 中的定义构建一个名为 `ethereum-private-chain` 的Docker镜像。

6. 启动以太坊私有链节点：执行以下命令来启动私有链节点：

   ```bash
   docker run -p 8545:8545 -v $(pwd)/data:/root/data ethereum-private-chain
   ```

### 以下错误的是（）

```B
A.	400：语义有误，当前请求无法被服务器理解
B.	401：页面加载不到资源
C.	403：服务器已经理解请求，但是拒绝执行它
D.	200：请求被服务器端正常处理，
// ajax请求成功返回的是200而不是201（注意：和以前的选项不一样）
```

A. 400：语义有误，当前请求无法被服务器理解。表示服务器无法理解请求的语法或参数格式不正确。

C. 403：服务器已经理解请求，但是拒绝执行它。表示服务器理解请求，但拒绝执行，通常是因为请求的资源被服务器禁止访问。

D. 200：请求被服务器端正常处理。表示服务器成功处理了请求，并返回了正确的响应结果。这是最常见的成功状态码之一。

### 关于代码质量

1. DRY（Don't Repeat Yourself）：DRY是一种软件开发原则，旨在避免重复代码。它鼓励开发者在代码中尽量避免重复的逻辑或功能，并通过封装、抽象和重用来实现代码的简洁性和可维护性。
2. KISS（Keep It Simple, Stupid）：KISS原则强调保持代码简单和易于理解。它倡导在设计和编写代码时避免过度复杂化，尽可能使用简单直接的解决方案，以减少错误和提高代码的可读性和可维护性。
3. YAGNI（You Ain't Gonna Need It）：YAGNI是一种开发原则，建议在编写代码时避免过度设计或添加不必要的功能。它强调只实现当前需求，并避免为未来可能的需求添加复杂性，以降低开发成本和减少不必要的工作。

### 圈复杂度

圈复杂度（Cyclomatic Complexity）是一种软件度量，用于衡量程序中的控制流复杂度。它可以帮助开发人员评估代码的复杂程度、理解代码的可测试性，并提供改进代码质量的线索。

圈复杂度通过计算程序中的独立路径数量来度量代码的复杂性。每个决策点（例如条件语句、循环语句等）增加了一个独立路径。较高的圈复杂度表示代码中有更多的可能路径和更复杂的控制流。这可能导致代码更难理解、测试和维护。

控制流图是计算圈复杂度的基础。控制流图以代码的基本块（例如语句、条件、循环等）为节点，通过连接这些基本块的边表示控制流转移。圈复杂度等于控制流图中的路径数减去节点数，并加1。

较高的圈复杂度可能需要更多的测试用例来覆盖不同的路径，以确保代码的正确性。较低的圈复杂度通常意味着更简单、可读性更好的代码，更易于理解和维护。

一般来说，圈复杂度应尽可能低于一定的阈值，例如10或15，以提高代码质量。当圈复杂度超过阈值时，可能需要进行重构，简化控制流，提取重复代码等来降低代码的复杂性。

### 检测代码的时候谁不能到场（）

```
A.	安全管理员
B.	业务员
C.	程序员
D.	是什么来着忘了，但是应该是对的
```

### 白盒测试和黑盒测试

白盒测试和黑盒测试是软件测试中常用的两种不同的测试方法。

#### 白盒测试（White Box Testing）：

- 白盒测试也被称为结构测试、透明盒测试或逻辑驱动测试。
- 在白盒测试中，测试人员具有对被测试软件的内部结构和代码的详细了解。
- 测试人员可以查看源代码、设计文档和系统内部的逻辑，以编写测试用例。
- 白盒测试主要关注验证内部逻辑、路径覆盖、条件覆盖和代码执行情况等方面。
- 这种测试方法适用于单元测试、集成测试和系统测试。

#### 黑盒测试（Black Box Testing）：

- 黑盒测试也被称为功能测试、规格驱动测试或数据驱动测试。
- 在黑盒测试中，测试人员对被测试软件的内部结构和实现细节一无所知。
- 测试人员只能根据需求规格、用户界面和输入输出等外部特征来编写测试用例。
- 黑盒测试主要关注验证功能是否符合需求、用户体验、错误处理和系统与外部接口的交互等方面。
- 这种测试方法适用于系统测试、验收测试和用户验收测试。

#### 总结：

白盒测试和黑盒测试是两种不同的测试方法。白盒测试基于对软件内部结构的了解，着重验证内部逻辑和代码覆盖。而黑盒测试基于对软件外部特征的观察，关注功能是否符合需求和用户体验。两种测试方法在不同阶段和场景中都有其适用性，测试人员可以根据具体的测试目标和需求选择合适的测试方法。

### OOCSS的思想主要有（）

```AC（C不确定）
A.	分离结构和外观
B.	分离结构和内容
C.	分离容器和内容
D.	分离容器和外观
```

分离结构和外观：这是OOCSS的核心思想之一。它强调将CSS样式从具体的HTML结构中分离出来，使样式能够独立于结构存在，并能够在不同的结构上重复使用。通过分离结构和外观，可以提高样式的可重用性和可维护性。

### 关于模板字符串，下列说法不正确的是（）

```D
A.	使用反引号标识
B.	插入变量的时候使用${ }
C.	所有的空格和缩进都会被保留在输出中
D.	${ }中的表达式不能是函数的调用
```

A. 使用反引号标识：是正确的描述。在ECMAScript中，使用反引号（`）来定义模板字符串。

B. 插入变量的时候使用${ }：是正确的描述。在模板字符串中，可以使用`${expression}`的形式来插入变量和表达式。这被称为模板字符串的插值（Interpolation）。

C. 所有的空格和缩进都会被保留在输出中：是错误的描述。模板字符串中的空格和缩进在输出时会被压缩成一个空格，除非在模板字符串中使用了换行符（\n）。

D. ${ }中的表达式不能是函数的调用：是错误的描述。在模板字符串中，${ }中的表达式可以是任意合法的JavaScript表达式，包括函数的调用。

### Proxy代理

Proxy是JavaScript中的一个内置对象，它用于创建一个代理对象，可以用来拦截并自定义对象的各种操作。通过使用Proxy，我们可以修改对象的默认行为，以实现自定义的操作和行为。

Proxy对象的创建方式是通过使用`new Proxy(target, handler)`语法来实例化。其中，`target`表示要代理的目标对象，而`handler`是一个包含各种拦截方法的对象，用于定义代理对象的行为。

通过Proxy对象，我们可以拦截和自定义的操作包括：

1. 属性访问拦截：可以通过`get`和`set`拦截属性的读取和赋值操作。
2. 方法调用拦截：可以通过`apply`拦截函数的调用操作。
3. 构造函数拦截：可以通过`construct`拦截构造函数的调用，即使用`new`关键字创建实例时的操作。
4. 属性删除拦截：可以通过`deleteProperty`拦截属性的删除操作。
5. 属性枚举拦截：可以通过`enumerate`拦截属性的枚举操作，如`for...in`循环等。
6. 其他各种拦截操作，包括原型访问、拦截`in`操作符、拦截`hasOwnProperty`等等。

通过使用Proxy，我们可以在对象操作的各个层面进行拦截和自定义处理，实现对对象行为的灵活控制和修改。这使得Proxy成为实现元编程和实现高级特性的强大工具之一。

### ES6的module模块相关知识

ES6引入了一种新的模块系统，称为ES6模块（ES6 Modules）。ES6模块提供了一种在JavaScript中组织、导入和导出代码的标准方式，以替代之前的模块化方案。

以下是ES6模块的相关知识：

1. 导出（Export）：使用`export`关键字可以将变量、函数、类或对象作为模块的公共接口导出。可以使用默认导出（default export）或命名导出（named export）。

   - 默认导出：使用`export default`语法将一个变量、函数、类或对象设为默认导出。一个模块只能有一个默认导出。
   - 命名导出：使用`export`关键字将一个或多个变量、函数、类或对象作为命名导出。

2. 导入（Import）：使用`import`关键字可以导入其他模块导出的内容。可以使用默认导入（default import）或命名导入（named import）。

   - 默认导入：使用`import defaultName from 'module'`语法将默认导出的内容导入，并将其赋值给`defaultName`。
   - 命名导入：使用`import { namedExport } from 'module'`语法将命名导出的内容导入，并将其赋值给相应的变量。

3. 模块的文件路径：ES6模块使用文件路径来引用其他模块。可以使用相对路径或绝对路径指定模块的位置。

   - 相对路径：使用相对当前模块的路径，如`./`表示当前目录，`../`表示上级目录。
   - 绝对路径：使用完整的文件路径，从项目根目录开始。

4. 模块的默认导出和命名导出的语法区别：

   - 默认导出使用`export default`和`import defaultName from 'module'`语法。
   - 命名导出使用`export`和`import { namedExport } from 'module'`语法。

5. 循环依赖：ES6模块可以处理循环依赖问题。当模块存在循环依赖时，ES6模块会自动处理，确保每个模块只被加载和执行一次。

6. 动态导入：ES6模块支持动态导入，可以在运行时根据条件导入模块。使用`import()`函数来实现动态导入。

   - `import('module')`：返回一个Promise，可以使用`then`方法来获取导入的模块。

ES6模块提供了一种更先进、更强大的模块化方案，它具有更好的语法支持、更强的静态分析能力和更好的兼容性。它已经被现代的JavaScript环境广泛支持，包括浏览器和Node.js。

### 设计模式相关的判断题

from——chatGPT

```
设计模式是一种固定的代码模板，可以直接复制粘贴在项目中使用。 (False)

JavaScript设计模式是一套经过验证的解决特定问题的最佳实践。 (True)

单例模式是一种设计模式，用于限制一个类只能创建一个实例。 (True)

观察者模式是一种设计模式，其中一个对象（称为主题）维护其依赖项列表，并在状态发生变化时通知它们。 (True)

原型模式是一种设计模式，通过克隆已有对象来创建新对象，而不是通过实例化类。 (True)

策略模式是一种设计模式，可以在运行时选择算法的行为。 (True)

工厂模式是一种创建对象的设计模式，将对象的实例化过程封装在工厂类中。 (True)

MVC（模型-视图-控制器）是一种设计模式，用于将应用程序分成三个组件，以实现分离关注点。 (True)

适配器模式是一种设计模式，用于将一个接口转换成另一个接口，以满足不同类之间的兼容性要求。 (True)

JavaScript语言本身已经内置了所有常见的设计模式，因此不需要自己实现或使用其他库。 (False)
```

### Webpack相关内容

### super（）

在JavaScript中，`super`是一个关键字，用于访问和调用对象的父类（或超类）的方法。它主要用于类继承关系中，可以在子类中通过`super`来调用父类中的方法。

以下是`super`的几种用法和相关知识点：

1. 调用父类构造函数：在子类的构造函数中，通过`super()`可以调用父类的构造函数，以便执行父类的初始化操作。这通常是在子类构造函数的第一行使用。

```javascript
class Parent {
  constructor(name) {
    this.name = name;
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name); // 调用父类构造函数
    this.age = age;
  }
}
```

2. 调用父类方法：在子类中，可以使用`super.methodName()`的方式调用父类中的方法。这样可以在子类中重写父类方法，但仍然可以通过`super`调用父类方法。

```javascript
class Parent {
  greet() {
    console.log("Hello from Parent");
  }
}

class Child extends Parent {
  greet() {
    super.greet(); // 调用父类的greet方法
    console.log("Hello from Child");
  }
}
```

3. 在静态方法中使用：在静态方法中，可以使用`super`来调用父类的静态方法。

```javascript
class Parent {
  static staticMethod() {
    console.log("Static method in Parent");
  }
}

class Child extends Parent {
  static staticMethod() {
    super.staticMethod(); // 调用父类的静态方法
    console.log("Static method in Child");
  }
}
```

需要注意的是，`super`只能在派生类（子类）的构造函数、普通方法和静态方法中使用，并且必须在使用之前调用`super()`。此外，`super`只能用于访问父类的方法，而不能用于访问父类的属性。

通过使用`super`，可以在子类中继承和扩展父类的功能，实现类之间的继承关系和方法的重写。

## 判断题

```
判断设计模式：能使一个对象的状态发生改变时通知所有依赖她的坚挺着。将已有类的接口转换成目标接口兼容的设计模式是适配器模式
```

正确：将已有类的接口转换成目标接口兼容的设计模式是适配器模式。适配器模式通过包装一个已有的类，将其接口转换为客户端所期望的接口，从而使原本不兼容的类能够协同工作。适配器模式可以在不修改现有代码的情况下，使得已有的类能够与其他类或组件进行协作。适配器模式通常用于解决接口不匹配、功能扩展或不兼容的问题。

# 套卷二

## 单选

### 给定代码 `var [a, b, ...c] = ['a']`，`a、b、c`值是什么（）

使用了解构赋值语法。这里使用了数组的解构赋值，将数组 `['a']` 中的元素赋值给了变量 `a`、`b` 和 `c`。

根据代码，变量 `a` 被赋值为 `'a'`，这是数组的第一个元素。

由于数组中只有一个元素，变量 `b` 没有对应的值，因此它的结果为 `undefined`。

变量 `c` 使用了剩余参数（rest parameter）的语法 `...c`，它会将剩余的所有元素收集到一个新的数组中。在这种情况下，剩余元素为空，因为数组中只有一个元素。因此，变量 `c` 的结果是一个空数组 `[]`。

综上所述，根据给定的代码，变量 `a` 的结果为 `'a'`，变量 `b` 的结果为 `undefined`，变量 `c` 的结果为 `[]`。

### 下列关于nginx说法错误的是

```
nginx只能转发http请求
```

### web.xml和applicationContext.xml文件的作用

```
A. web.xml
B. config.xml
C. applicationContext.xml
D. jdbc.properties
```

1. `web.xml`： `web.xml`是Java Web应用程序的部署描述文件，通常位于WEB-INF目录下。它是一个XML文件，用于配置和描述Web应用程序的部署信息和行为。它主要包含以下内容：

   - Servlet配置：定义Servlet的映射、初始化参数等。
   - Filter配置：定义过滤器的映射、初始化参数等。
   - Listener配置：定义监听器，用于监听Web应用程序的生命周期事件。
   - 错误页面配置：定义处理特定错误的页面。
   - Session配置：定义会话管理策略和超时设置。
   - 安全配置：定义安全约束和权限设置等。

   `web.xml`文件通过提供Web应用程序的部署和行为信息，告诉Web容器如何处理请求、初始化应用程序、配置安全等。

2. `applicationContext.xml`： `applicationContext.xml`是Spring框架中的配置文件，用于定义应用程序的组件和它们之间的关系。它也是一个XML文件，通常位于类路径下。它主要包含以下内容：

   - Bean定义：定义应用程序中的各个组件（Bean）以及它们的属性、依赖关系等。
   - 依赖注入（Dependency Injection）配置：定义Bean之间的依赖关系，通过依赖注入将依赖的实例注入到相应的Bean中。
   - 切面（Aspect）配置：定义切面和通知，用于实现面向切面编程（AOP）。
   - 数据库配置：定义数据库连接信息和数据访问对象（DAO）。

   `applicationContext.xml`文件通过提供Spring框架的配置信息，告诉Spring容器如何管理和组装应用程序中的组件。

### Ribbon的特点和作用

Ribbon是Netflix开源的一个负载均衡器库，它主要用于在微服务架构中客户端进行服务调用时的负载均衡和故障转移。下面是Ribbon的特点和作用：

1. 负载均衡：Ribbon能够根据配置的负载均衡算法（如轮询、随机等）自动将客户端请求分发到多个服务实例上，实现请求的负载均衡，提高系统的可伸缩性和性能。

2. 故障转移：Ribbon能够监测服务实例的健康状态，当某个服务实例发生故障或不可用时，Ribbon可以自动将请求切换到其他可用的服务实例，实现故障转移，提高系统的可靠性和容错性。

3. 客户端侧负载均衡：Ribbon是一个客户端负载均衡器，与服务端无关。客户端直接使用Ribbon来选择要调用的服务实例，相对于服务端负载均衡，具有更好的灵活性和独立性。

4. 配置灵活：Ribbon提供了丰富的配置选项，可以通过配置文件或编程方式进行自定义配置。可以配置负载均衡算法、重试策略、超时设置等，以满足不同场景下的需求。

5. 与Spring Cloud集成：Ribbon是Spring Cloud框架的一部分，与其他组件（如Eureka、Zuul等）无缝集成。通过与Spring Cloud的配合使用，可以快速搭建和管理基于微服务架构的应用。

总结：
Ribbon是一个负载均衡器库，主要用于微服务架构中客户端的负载均衡和故障转移。它具有负载均衡、故障转移、客户端侧负载均衡、配置灵活和与Spring Cloud集成等特点和作用，能够提高系统的可伸缩性、可靠性和容错性。

### WUI是指（）

```B
A.安卓设计
B.网页设计
C.移动端设计
D.iOS设计
```

WUI是Web User Interface的缩写，指的是Web用户界面。它是指通过Web浏览器作为客户端访问和操作应用程序或系统的用户界面。

WUI通常是基于Web技术（如HTML、CSS、JavaScript）开发的，通过在浏览器中呈现页面和交互元素，让用户可以使用鼠标、键盘或触摸屏等方式与应用程序进行交互。用户可以通过WUI来查看和操作数据、填写表单、执行功能操作等。

Web应用程序中的WUI可以具有丰富的功能和交互性，可以实现响应式设计、动态内容加载、表单验证、图表展示等。WUI的优势之一是它的跨平台性，用户只需通过支持Web浏览器的设备访问应用程序，如电脑、手机、平板电脑等。

总结：WUI指的是通过Web浏览器作为客户端的Web用户界面，通过使用Web技术实现用户与应用程序的交互和操作。

### 下面代码输出结果为（）

```js
var a = 2; 
var b = 4; 
console.log(a^b);
```

```A
A. 6		
B. 8		
C. 12		
D. 16
```

在JavaScript中，`^`是按位异或运算符，用于执行两个操作数的按位异或操作。它将操作数的每个对应位进行异或运算，返回结果。

对于数字2和4，其二进制表示分别为`10`和`100`。按位异或操作会将对应位置上的二进制位进行比较，如果不同则结果为1，相同则结果为0。

执行`console.log(a^b);`会输出结果为`6`，因为`10 ^ 100`的结果为`110`，即6的二进制表示。

请注意，按位异或操作符(`^`)在JavaScript中也可以用作指数运算符(`**`)，具体取决于运算符的上下文。在这种情况下，`^`不是按位异或，而是表示求幂运算。然而，在您提供的代码中，`^`是按位异或运算符。

### 下面关于div和span标记的描述,错误的选项是（）

```D
A. div默认情况下是块模式,即标记前后有类似换行符一样的功能
B. span默认情况下是行模式,即标记前后内容在同行显示
C. div和span标记的默认模式,可以通过css的display属性予以调整
D. 前后两个div标记块的内容,不能出现在同一行
```

### 一台主机要实现通过局域网与另一个局域网通信，需要做的工作是

```C
A.配置域名服务器
B.定义一条本机指向所在网络的路由
C.定义一条本机指向所在网络网关的路由
D.定义一条本机指向目标网络网关的路由
```

要实现通过局域网与另一个局域网通信，需要在本机上定义一条路由，将本机指向所在网络的网关。这样，本机就能够将数据包发送给所在网络的网关，再由网关进行转发，以实现跨局域网的通信。

选项解析：
- A. 配置域名服务器是为了将域名解析为对应的IP地址，与局域网通信无直接关系。
- B. 定义一条本机指向所在网络的路由是指将本机与所在局域网的通信连接起来，而不是实现跨局域网通信。
- C. 定义一条本机指向所在网络网关的路由是关键步骤，它将本机与所在局域网的网关连接起来，使本机能够将数据包发送给网关进行转发，从而实现跨局域网通信。
- D. 定义一条本机指向目标网络网关的路由是与实现跨局域网通信无关的操作。

因此，正确答案是 C. 定义一条本机指向所在网络网关的路由。

### 下面有关 CSS sprites 说法错误的是？

```C
A.允许你将一个页面涉及到的所有零星图片都包含到一张大图中去
B.利用 CSS 的 “background-image”，“background-repeat”，“background-position” 的组合进行背景定位
C.CSS Sprites 虽然增加了总的图片的字节，但是很好地减少网页的 http 请求，从而大大的提高页面的性能
D.CSS Sprites 整理起来更为方便，同一个按钮不同状态的图片也不需要一个个切割出来并个别命名
```

实际上，CSS Sprites 可以减少网页的 HTTP 请求，但并不会增加总的图片字节。相反，使用 CSS Sprites 可以通过将多个小图片合并为一张大图，减少了请求的次数和服务器的负载。由于只需加载一张大图，可以减少网络延迟和连接开销，从而提高页面加载性能。

### 下面代码输出结果为

一：

```js
var a = 2;
if( var a = 0; a < 10; a++ ) {
  //代码块
} 
console.log(a)
```

```C
A.0		B.2		C.10	  D.undefined
```

二：

```js
var num = Number("Hello");
console.log(typeof num);
```

```B
A.String
B.Number
C.NaN
D.Hello
```

### 在局域网中，某台主机用PING命令测试网络连接时发现网络内部的主机都可以连通，而不能与公网连通，则问题可能是（）

```C
A.主机IP地址设置有误
B.没有设置连接局域网的网关
C.局域网的网关或主机的网关设置有误
D.局域网DNS服务器设置有误
```

在局域网中，网络连接通常需要通过网关来与公网进行通信。网关是一个连接局域网和外部网络（如互联网）的设备，它负责将数据包从局域网传递到公网或从公网传递到局域网。如果局域网的网关设置有误，主机就无法正确地将数据包传递到公网。

通过PING命令测试网络连接时，如果网络内部的主机都可以连通，但不能与公网连通，这可能意味着局域网的网关或主机的网关设置有误。主机无法正确地将数据包发送到外部网络，导致无法与公网进行通信。

因此，问题可能出现在局域网的网关或主机的网关设置方面。检查和确认网关的配置是否正确可以帮助解决此问题。

### `JavaScript`中`class{}`的哪个关键字用于继承

```A
A.extends	B. base	 C.super	D.inherit
```

### `noscript`标签是做什么用的

```C
A、制止脚本的运行	
B、防止区域脚本被js修改<br>(例如aDiv.innerHTML = 'something' 将会不起作用
C、用来定义在脚本未被执行时的替代内容
D、NOSCRIPT 标签并不存在
```

`NOSCRIPT`标签用于在浏览器不支持或禁用JavaScript时提供替代内容。

当浏览器加载网页时，默认情况下会执行其中的JavaScript代码。然而，有时用户可能禁用了JavaScript功能，或者浏览器本身不支持JavaScript。在这种情况下，网页中的JavaScript代码将无法执行，可能导致页面显示不正常或功能无法正常工作。

为了解决这个问题，可以使用`NOSCRIPT`标签。`NOSCRIPT`标签是一个HTML标签，用于在浏览器不支持或禁用JavaScript时提供替代内容。在`NOSCRIPT`标签中可以包含一些文本、链接或其他HTML元素，用于向用户显示无法执行JavaScript时的替代内容。

使用`NOSCRIPT`标签时，其中的内容只有在浏览器不支持或禁用JavaScript时才会显示，而在浏览器支持JavaScript并且未禁用的情况下，`NOSCRIPT`标签内的内容会被忽略。

例如，以下代码展示了一个使用`NOSCRIPT`标签的示例：

```html
<script>
    // JavaScript代码
</script>

<noscript>
    <p>您的浏览器不支持或已禁用JavaScript。</p>
    <p>请启用JavaScript以正常浏览本网站。</p>
</noscript>
```

在上面的示例中，如果浏览器支持并启用了JavaScript，则`<script>`标签内的代码会执行，而`<noscript>`标签内的内容会被忽略。如果浏览器不支持或禁用了JavaScript，则`<noscript>`标签内的内容会显示给用户。

### 《中华人民共和国网络安全法》施行时间

《中华人民共和国网络安全法》是中国的一部法律，旨在加强网络安全保护，维护网络空间主权和国家安全。该法律于2016年11月7日经全国人民代表大会常务委员会表决通过，并于2017年6月1日正式生效施行。

因此，《中华人民共和国网络安全法》的==施行时间是2017年6月1日==。从那时起，该法律对于涉及网络安全的各个方面，包括网络运营者、网络产品和服务提供者、个人用户等，都有一系列规定和要求。

### 关于Set结构的实例方法，下面说法错误的是（）

```C
A.set方法用于添加成员
B.clear方法用于清除所有成员。
C.entries方法返回成员的位置索引和值的遍历器
D.values方法返回成员值的遍历器
```

A. `set`方法用于添加成员到Set结构中。 

B. `clear`方法用于清除Set结构中的所有成员。 

C. `entries`方法返回一个遍历器对象，该遍历器包含Set结构中每个成员的键值对。 

D. `values`方法返回一个遍历器对象，该遍历器包含Set结构中每个成员的值。

### JavaScript的原始类型错误的是（）

```D
A.undefined	  
B.String      	
C.Number    	
D.Long
```



## 多选

### `script`标签引入`JavaScript`时， `async`属性的特点 

1. 异步加载：当`script`标签具有`async`属性时，浏览器会异步加载该脚本，不会阻塞页面的解析和渲染。它会在后台与页面的加载并行进行，不会影响页面的加载速度。
2. 执行时机不确定：由于异步加载的特性，`async`属性指示浏览器在下载脚本完成后立即执行脚本。执行时机可能在文档的解析和其他资源的加载之前或之后，具体取决于脚本的下载速度。
3. 不保证顺序：当页面中有多个带有`async`属性的`script`标签时，它们的加载和执行顺序是不确定的。这意味着它们可能以任意顺序执行，而不一定按照它们在文档中的顺序。
4. 不阻塞页面加载：由于异步加载和执行，`async`脚本不会阻塞页面的加载。页面会继续解析和渲染，不需要等待脚本的下载和执行完成。

### 下面关于IE、FF下面CSS的解释区别描述正确的有？

```CD
A.	FireFox的div的内嵌div可以把父级的高度撑大，而IE6.0不可以，要自己设置高度。

B.	当设置为三列布局时，FireFox0的float宽度不能达到100％，而IE6.可以。当设置为两列布局时，两种浏览器都可以。	

C.	火狐浏览器中，非float的div前面有同一父级的float的div，此div若有背景图，要使用clear：both，才能显示背景图，而IE6.0中不用使用clear：both	

D.	在[text-decoration:underline]的属性下，IE6.0显示的下划线会比FireFox低一点。在FireFox中，部分笔画会在下划线的下面1个像素左右。
```

### 将文件从docker中拷贝下来的指令有哪几种？（）

```AB
A.COPY		
B.ADD	 
C.WORKDIR		
D.ps
```

在 Docker 中，有多种指令可用于将文件从容器复制到本地主机。以下是几种常用的方法：

1. `docker cp` 命令：使用 `docker cp` 命令可以将文件或目录从容器复制到主机。命令的基本语法为：
   
   ```
   docker cp <容器ID或名称>:<容器内路径> <主机目标路径>
   ```
   例如，要将容器中的文件 `example.txt` 复制到当前主机的 `/path/to/destination` 目录，可以运行以下命令：
   ```
   docker cp <容器ID或名称>:/path/to/example.txt /path/to/destination/
   ```
   
2. 使用 Dockerfile 的 `COPY` 或 `ADD` 指令：在 Dockerfile 中，可以使用 `COPY` 或 `ADD` 指令将文件从主机复制到容器。这些指令在构建镜像时执行，并将文件复制到指定的容器路径。例如：
   ```
   COPY <主机源路径> <容器目标路径>
   ```
   或
   ```
   ADD <主机源路径> <容器目标路径>
   ```

这些方法都可以用于将文件从 Docker 容器复制到主机。具体选择哪种方法取决于您的需求和使用场景。

## 判断

```
1、es6编译时加载
2、设计模式能使一个对象的状态发生改变时通知所有依赖她的坚挺着。将已有类的接口转换成目标接口兼容的设计模式是适配器模式
3、设计模式的中介模式， 订阅者是双向的，既可以是消息的发布者，也可以是消息的订阅者
4、命令模式由于为每一个请求封装一个对象，所以会增加系统的复杂度（有个选择有复杂度这个知识点）
5、JavaScript中trimEnd()会使字符串末尾换行无效。
6、行为模式涉及怎样合理地设计对象之间的交互通信，以及怎样合理为对象分配职责。
7、在不涉及样式情况下,页面元素的优先显示与结构摆放顺序无关。
```

1. 错误。ES6（ECMAScript 2015）是一种JavaScript的版本，它在浏览器中运行时并不需要编译，现代浏览器已经支持直接运行ES6语法的JavaScript代码。
2. 正确。适配器模式是一种设计模式，用于将一个已有类的接口转换成目标接口兼容的形式，以便其他类可以通过目标接口与该类进行交互。
3. 错误。中介者模式是一种设计模式，用于集中处理对象之间的交互和通信。订阅者只负责接收消息，而发布者负责发布消息。
4. 正确。命令模式是一种设计模式，它通过将请求封装为命令对象来实现请求的发送者和接收者之间的解耦。封装每个请求为一个对象会增加系统的复杂度。
5. 错误。`trimEnd()`方法是用于移除字符串末尾的空格（包括空格、制表符、换行符等）。它不会使字符串末尾的换行无效。
6. 正确。行为模式是一种设计模式的分类，它关注对象之间的交互通信和职责分配。
7. 错误。HTML文档是逐行解析的，浏览器按照文档流的顺序将元素呈现在页面上。在不涉及样式的情况下，页面元素的显示和结构摆放顺序是相关的。按照HTML文档的结构摆放顺序，页面元素会按照从上到下的顺序逐个显示。如果它们在同一个位置上，后面的元素会覆盖前面的元素。

## 安全

### 以下关于安全测试正确的是（）

```A
A、 Fuzz测试是经常采用的安全方法之一
B、 软件安全测试就是黑盒测试
C、 软件安全测试关注的是软件的功能
D、 软件安全测试可以发现所有安全问题
```

A、 Fuzz测试是经常采用的安全方法之一。

Fuzz测试是一种常用的安全测试方法，它通过向系统或应用程序输入大量的随机、异常或非预期的数据来检测潜在的漏洞和安全问题。Fuzz测试可以帮助发现输入验证、缓冲区溢出、代码注入等安全漏洞。

==其他选项是不正确的：==

B、 软件安全测试并不仅限于黑盒测试。安全测试可以采用黑盒、白盒或灰盒等不同的测试方法，根据测试人员对系统内部结构和实现的了解程度进行测试。

C、 软件安全测试并不仅关注软件的功能。安全测试的主要目标是评估系统的安全性，包括发现和修复潜在的安全漏洞和弱点，而不仅仅是功能的正确性。

D、 软件安全测试不能保证发现所有的安全问题。尽管安全测试可以帮助发现系统中的许多安全问题，但它并不能保证捕获所有可能的漏洞和安全隐患。安全测试应该作为一个综合的安全保障措施的一部分，与其他安全实践相结合，以最大程度地提高系统的安全性。

### 如何获取userId（）

```D
A、 post路径中
B、 cookie中
C、 session中
D、 以上都可以
```

获取 userId 的方式可以有多种，具体取决于应用程序的设计和实现方式。常见的方式包括：

A、在 POST 路径中：可以通过请求的参数或请求体中包含 userId 的方式进行传递。例如，可以在 POST 请求的 URL 中包含 userId，或者在请求体中以参数的形式传递。

B、在 Cookie 中：可以将 userId 存储在客户端的 Cookie 中，然后在后续的请求中通过读取 Cookie 来获取 userId。这需要在用户登录时将 userId 设置为 Cookie 的值，并在后续的请求中发送包含该 Cookie 的请求头。

C、在 Session 中：可以将 userId 存储在服务器端的 Session 中。用户在登录时，将 userId 存储在服务器端的 Session 对象中，然后在后续的请求中，服务器可以通过读取 Session 来获取 userId。

D、以上都可以：根据应用程序的设计和需求，可以同时使用多种方式来获取 userId。例如，可以将 userId 同时存储在 Cookie、Session 和请求参数中，以提供更灵活的获取方式。

### `Jsp.xxxx.haikkk`会解析成什么（）

```
A、jsp
B、xxxx
C、haikkk
D、纯文本
```

## 新增

### 20221110前端补考考试总结：

原题出现在前端（1）/前端2019xlsx文档之中，有三道，可能旧题库出现部分习题，占比不多大约2-5道。

环境部署，测试相关题型较多，两者想加大约有15左右，占比较大，三种题型都有，单选题型复杂，有JavaScript（1）、nginx（2-3）、vue（2-3）、测试、环境部署，涉及面比较多而且繁杂，

新增Android（2-3） 、MVVM、springcloud、feign题型其中后三者出现较多每种出现4-6道，单选、多选、判断都有。

css和html占比不多大约1-2道。

环境部署，测试相关题型占比最多（30%-40%），其次是MVVM、springcloud、feign占比（15-20%%），其余部分就是nginx、Android、html、css、VUE等多种方向各占比（5%—10%）

### 20221109前端补考考试总结： 

Aidl，ios两三道，git的合并指令一道，Math一道，js，es6,nginx，项目管理，版本更新

js10道，nginx的最多将近20，安卓10到，部署两道，判断设计模式大概5道，sails.js框架、Websocket协议两道

### 20221108前端补考考试总结：

设计模式居多大概十道左右，并且问的较深入，其余安卓两道，测试三四道，项目部署四五道，ui两三道，java两道，项目管理等五六道，Math.clz32()出了四五道，js的逻辑题有五六道。

### 20221103补考考试总结：

设计模式一题，牛客网原题三到四题，剩余考题涉及nginx、webpack、ios和安卓布局两到三题、aidl一题，测试三到四题，Java两题，objective-c一题，linux两题

### 第一次考试的考试总结：

### 20221111考试总结：

原题10题，Math一道，nginx6道，webpack3道，持续集成4道，过程流水线4道，浏览器的CSS前缀一道

### 20221104考试总结：

设计模式和js大概30题，其余涉及：html、css、java和测试的、架构流程。

涉及知识点es6的API，正则匹配，css选择器，设计模式的十道左右比较多。设计模式的题都在多选和判断有十几道，单选主要都是问一些正则匹配，复杂对象类型，引用类型的复制，存储位置，字符串API，数组的创建循环，这几个占比加起来差不多20几道

### 20221010考试总结：

试题中牛客网原题约五题，JS基本是牛客网原题、springboot两三题，java 两三道（继承，程序题）、考试侧重点在js设计模式，设计模式至少8道，要深度理解不同设计模式的区别，会给例子问适合哪种设计模式（中介者模式、享元模式【判断】、模板方法模式、链模式）

html和css相对占比较少

多选题：涉及到项目部署，测试等方面知识

## 新增补考总结：

### 从字符串 `const str = 'qwbewrbbeqqbbbweebbbbqee;'`中能得到结果 `["b", "bb", "bbb", "bbbb"]` 以下错误语句是？（）

```B
A、str.match(/b+/g)             
B、str.match(/b*/g)          
C、str.match(/b{1,4}/g)          
D、str.match(/b{1,5}/g)
```

A、`str.match(/b+/g)`: 该模式表示匹配一个或多个连续的字母 "b"。返回的结果是字符串中所有连续的 "b" 字母的数组。

B、`str.match(/b*/g)`: 该模式表示匹配零个或多个连续的字母 "b"。返回的结果是字符串中所有连续的 "b" 字母（包括空字符串）的数组。

C、`str.match(/b{1,4}/g)`: 该模式表示匹配连续出现 1 到 4 次的字母 "b"。返回的结果是字符串中所有连续的 1 到 4 个 "b" 字母的数组。

D、`str.match(/b{1,5}/g)`: 该模式表示匹配连续出现 1 到 5 次的字母 "b"。返回的结果是字符串中所有连续的 1 到 5 个 "b" 字母的数组。

### 通过分析如下HTML代码，可以得出（）

```html
<table border="10"> 
  <tr> 
    <td colspan=2 align="center">员工号</td>
  </tr> 
  <tr> 
    <td rowspan=2 align="center">学历</td>
    <td align="center">专业</td>
  </tr>
  <tr>
    <td colspan=2 align="center">毕业学校</td>
  </tr> 
</table>
```

```BD
A、该表格共有2行3列                 
B、该表格中的文字均居中显示          
C、该表格的边框宽度为10毫米          
D、"员工号"单元格跨2列
```

A、该表格共有 3 行 2 列：根据表格的结构，可以看到表格中有 3 个 `<tr>` 标签，表示 3 行数据，且每行有 2 个 `<td>` 标签，共计 2 列。

B、该表格中的文字均居中显示：根据 `<td align="center">` 属性设置，表格中的文字会在单元格内居中显示。

D、"员工号"单元格跨 2 列：根据 `<td colspan=2>` 属性设置，"员工号"单元格横跨了两列。

C、该表格的边框宽度为 10 个==像素（px）==：根据 `<table border="10">` 属性设置，表格的边框宽度被设置为 10 个像素。

### BOM的核心对象是？

BOM（浏览器对象模型）的核心对象是 `window` 对象。在浏览器环境中，`window` 对象代表整个浏览器窗口，它是 BOM 的顶层对象，提供了访问和控制浏览器窗口的方法和属性。

`window` 对象包含了许多子对象和属性，用于操作浏览器窗口、处理文档、执行 JavaScript 代码等。一些常用的 `window` 对象的子对象和属性包括：

- `document`：代表当前窗口中加载的 HTML 文档，提供了对文档内容的访问和操作方法。
- `location`：提供了当前窗口的 URL 信息，包括加载的页面地址、参数等。
- `navigator`：提供了关于浏览器的信息，如浏览器名称、版本、用户代理等。
- `history`：用于访问浏览器的历史记录，可以前进、后退、跳转到特定页面等操作。
- `screen`：提供了有关用户屏幕的信息，如屏幕宽度、高度、颜色深度等。

这些对象和属性构成了 BOM 的核心，并且可以通过 `window` 对象访问它们。

### nginx是一个基于什么的web服务器（单选）（）

```C
A、流程                 
B、驱动          
C、事件         
D、……
```

Nginx（发音为"engine-x"）是一个基于事件驱动的、异步的、轻量级的开源 Web 服务器，也可以用作反向代理服务器、负载均衡器和HTTP缓存等。它是基于事件驱动和异步处理的设计理念，具有高性能、高并发处理能力和低内存消耗的特点。

Nginx 的设计目标是为了解决 C10k（同时处理 10,000 个并发连接）问题，能够处理大量的并发连接而不消耗过多的系统资源。它采用了事件驱动的架构，使用少量的线程或进程来处理客户端请求，并通过异步非阻塞的方式处理网络连接，提高了并发处理能力和系统的响应速度。

Nginx 的特点包括：

- 高性能：采用了事件驱动、异步非阻塞的处理方式，具有出色的并发处理能力和高性能表现。
- 轻量级：具有较低的内存消耗和资源占用，适合部署在资源受限的环境中。
- 可扩展性：支持模块化的架构，可以通过添加扩展模块来增加功能和定制化需求。
- 反向代理和负载均衡：作为反向代理服务器，可以接收客户端请求并转发到后端服务器，实现负载均衡和高可用性。
- 高度可配置：提供丰富的配置选项和灵活的配置语法，使管理员可以根据需求进行灵活配置和定制。

总而言之，Nginx 是一个基于事件驱动、异步处理的高性能、轻量级的 Web 服务器，适用于处理大量并发连接和高负载的场景。

### Android 中动画分类不包含？（）

```C
A、tween                 
B、frame        
C、alpha       
D、Animation
```

在 Android 中，动画主要分为三类：

A、Tween 动画（补间动画）：也称为补间动画，通过指定起始值和结束值之间的过渡来实现动画效果。常见的 Tween 动画包括平移动画（TranslateAnimation）、缩放动画（ScaleAnimation）、旋转动画（RotateAnimation）和透明度动画（AlphaAnimation）等。

B、Frame 动画（逐帧动画）：也称为逐帧动画，是由一系列静态图像（帧）组成的动画。每个帧在指定的时间间隔后进行切换，从而呈现出连续的动画效果。Frame 动画适合用于展示连续的图像序列，如帧动画列表或者 GIF 图片。

C、属性动画（Property Animation）：是 Android 3.0（API 级别 11）引入的一种动画机制，通过改变对象的==属性值==实现动画效果。与 Tween 动画不同，属性动画可以对任何对象的任意属性进行动画处理，具有更强大的灵活性和控制性。

### springcloud的组件有那些？（多选）

```ABD
A、Eureka                 
B、Zuul         
C、Zuul2         
D、Ribbon
```

Spring Cloud 是一个用于构建分布式系统的开发工具包，它提供了一系列的组件和功能，用于简化分布式系统的开发和管理。以下是一些常用的 Spring Cloud 组件：

1. Eureka：服务注册与发现组件，用于实现服务注册、发现和负载均衡。

2. Ribbon：客户端负载均衡组件，用于在客户端实现负载均衡和故障转移。

3. Feign：声明式的 HTTP 客户端，简化了服务间的调用。

4. Hystrix：容错管理组件，提供了服务降级、熔断、限流等功能，增加系统的弹性和容错性。

5. Zuul：网关组件，用于实现动态路由、访问控制、请求过滤等功能。

6. Config：配置管理组件，支持将应用程序的配置集中管理，并提供动态刷新配置的能力。

7. Bus：事件、消息总线组件，用于在分布式系统中传播状态的变化。

8. Sleuth：分布式跟踪系统，用于跟踪和监控请求在分布式系统中的传播和处理。

除了上述组件，还有很多其他的 Spring Cloud 组件可用于实现不同的功能和需求，如Spring Cloud Stream（消息驱动），Spring Cloud Security（安全认证和授权），Spring Cloud Task（任务调度）等。

请注意，这只是列举了一些常用的组件，实际上 Spring Cloud 还有更多的组件和扩展，可以根据具体需求选择适合的组件来构建分布式系统。

### Nginx虚拟主机怎么配置？（多选）

```ABD
A、域名                 
B、端口        
C、socketID        
D、ip
```

Nginx 虚拟主机可以通过配置域名来实现。每个虚拟主机可以通过不同的域名来访问，从而实现对不同域名的请求进行不同的处理和转发。

以下是配置 Nginx 虚拟主机的一般步骤：

1. 在 Nginx 配置文件中找到 `http` 块，并在该块内部添加 `server` 块。例如：
```
http {
    server {
        ...
    }
}
```

2. 在 `server` 块内部配置虚拟主机的相关信息，包括监听的端口、域名等。例如：
```
server {
    listen 80;
    server_name example.com;
    ...
}
```
在上述示例中，虚拟主机监听端口 80，域名为 example.com。可以根据需求配置多个 `server` 块，每个块代表一个虚拟主机。

3. 在虚拟主机的配置中，可以进一步配置具体的请求处理规则、反向代理等。例如：
```
server {
    listen 80;
    server_name example.com;
    
    location / {
        proxy_pass http://backend_server;
    }
}
```
上述示例中使用了 `location` 块来配置针对 `/` 路径的请求转发到后端服务器（`http://backend_server`）。

4. 根据实际需求配置其他虚拟主机，每个虚拟主机对应一个域名和相关的处理规则。

5. 完成配置后，重新加载或重启 Nginx 服务器，使配置生效。

需要注意的是，虚拟主机的配置也可以基于端口来区分不同的主机，但更常见的做法是使用域名来区分虚拟主机。配置完成后，Nginx 将根据请求的域名来选择对应的虚拟主机进行处理。

### 使用mvvm框架的优势？（多选）

1. 分离视图和业务逻辑：MVVM 模式通过将视图（View）和业务逻辑（ViewModel）分离，使代码结构更加清晰和可维护。视图专注于展示数据和处理用户交互，而业务逻辑由 ViewModel 处理，提供数据和行为的封装。
2. 双向数据绑定：MVVM 模式提供了双向数据绑定的机制，使视图与 ViewModel 之间的数据同步更加简单。当 ViewModel 中的数据发生变化时，视图会自动更新；同时，当用户在视图中输入数据时，ViewModel 中的数据也会相应更新。
3. 可测试性：由于视图和业务逻辑的分离，MVVM 模式使单元测试更加容易。可以独立地测试 ViewModel 中的业务逻辑，而无需关注具体的视图实现。
4. 可复用性：MVVM 模式鼓励将可复用的逻辑放在 ViewModel 中，从而实现代码的复用。多个视图可以共享同一个 ViewModel，避免重复编写类似的业务逻辑。
5. 支持团队协作：MVVM 模式通过明确的分工和规范的数据绑定机制，使视图开发人员和业务逻辑开发人员能够并行开发，提高团队协作效率。
6. 可扩展性：MVVM 模式通过引入 ViewModel 层，使应用程序的业务逻辑与具体的视图框架解耦。这样，可以更轻松地替换或切换视图框架，同时保持 ViewModel 的一致性。

### MVVM模式和MVC模式区别对比？（多选）

MVVM（Model-View-ViewModel）模式和 MVC（Model-View-Controller）模式是两种常见的软件架构模式，它们有以下区别：

1、视图与模型的交互方式：

- MVC模式中，视图（View）直接与模型（Model）进行交互，视图可以主动请求数据更新，并且可以直接从模型中获取数据。
- MVVM模式中，视图通过与视图模型（ViewModel）进行交互，视图模型封装了视图所需的数据和行为，视图通过数据绑定机制从视图模型中获取数据，并通过命令模式来执行相关行为。

2、数据绑定机制：

- MVC模式中，视图与模型之间通常没有直接的数据绑定机制，视图需要手动更新和同步模型的数据。
- MVVM模式中，视图与视图模型之间使用双向数据绑定机制，视图自动更新和同步视图模型中的数据，同时视图模型也可以响应视图中的用户交互。

3、关注点分离：

- MVC模式中，控制器（Controller）负责接收和处理用户输入，并将相关的数据和行为传递给模型和视图。模型负责处理数据逻辑，视图负责展示数据。
- MVVM模式中，视图模型负责处理用户交互和数据逻辑，视图负责展示数据，而模型则专注于业务逻辑和数据存储。

4、可测试性：

- MVC模式中，视图和控制器之间的耦合度较高，导致难以对视图和控制器进行单独的单元测试。
- MVVM模式中，由于视图和视图模型之间通过数据绑定解耦，可以更容易地对视图模型进行单元测试，而视图也可以通过模拟数据来进行测试。

总体来说，MVVM模式相较于MVC模式，更加关注视图和数据的绑定、数据驱动的交互方式，降低了视图与模型之间的耦合度，提供了更好的可测试性和可维护性。而MVC模式则更加注重控制器的角色，在一些传统的Web应用程序中仍然广泛使用。选择使用哪种模式应根据具体的应用场景和需求来决定。

## 判断题

```false
nginx状态码500——服务端处理时间过长，客户端主动关闭了连接。
```

状态码500表示"Internal Server Error"，它是服务器在处理请求时遇到了意外的错误，无法完成请求。这个错误通常是由于服务器端的代码或配置问题导致的，而不是客户端主动关闭连接。

当客户端主动关闭连接时，通常会返回状态码如400（Bad Request）或者499（Client Closed Request），而不是500。

# 套卷三

## 单选

### web诞生于

```B
A.21世纪10年代
B.20世纪90年代
C.20世纪80年代
D.20世纪70年代
```

### 下面关于div和span标记的描述,错误的选项是

```D
A. div默认情况下是块模式,即标记前后有类似换行符一样的功能
B. span默认情况下是行模式,即标记前后内容在同行显示
C. div和span标记的默认模式,可以通过css的display属性予以调整
D. 前后两个div标记块的内容,不能出现在同一行
```

### `<script>`标签不具有哪种属性

```C
A.src
B.type
C.style
D.charset
```

### 能将JSON对象转换为JavaScript对象的是

```B
A.JSON.toString
B.JSON.parse
C.toJSON
D.JSON.stringify
```

### 假设document是HTML文档中的一个节点，点击该节点后会发生什么？

```js
function test() {
  this.flag = false;
  this.change = () => {
    this.flag = true;
    console.log(button.flag);
  };
}
const button = new test();
document.addEventListener("click", button.change);
```

```A
A.输出true
B.输出false
C.输出undefined
D.报错
```

假设在HTML文档中点击了document节点后，会触发"click"事件，并执行`button.change`函数。

根据代码中的定义，`button`是通过`new test()`创建的实例，`test`函数有一个`change`方法，该方法在点击事件发生时被调用。在`change`方法中，`this.flag`被设置为`true`，并通过`console.log(button.flag)`打印出`button`对象的`flag`属性的值。

由于事件监听器是通过`document.addEventListener("click", button.change)`添加到document节点上的，所以无论点击文档中的哪个元素，都会触发该事件，并执行`button.change`方法。点击document节点后，`button.change`方法会将`button`对象的`flag`属性设置为`true`，并在控制台中打印`true`。

需要注意的是，在这段代码中，`button.flag`和`this.flag`引用的是同一个值，因为箭头函数没有自己的`this`，它会继承父级作用域的`this`值，也就是`button`对象。所以，`console.log(button.flag)`输出的结果将是`true`。

### 写出下面代码的运行结果

```js
var a,b;
(function(){
    alert(a);
    alert(b);
    var a=b=3;
    alert(a);
    alert(b);
})();
alert(a);
alert(b);
```

```A
A、undefined，undefined，3,3，undefined，3
B、undefined，undefined，3,3，undefined，undefined
C、0，0，3,3，undefined，undefined
D、undefined，undefined，3,3，0，0
```

首先，声明了两个变量 `a` 和 `b`，它们的初始值为 `undefined`。

在立即执行函数 `(function(){ ... })()` 内部：

1. `alert(a);` 输出：`undefined`。因为在立即执行函数内部，变量 `a` 还没有被赋值，所以它的值为 `undefined`。

2. `alert(b);` 输出：`undefined`。与变量 `a` 类似，变量 `b` 在立即执行函数内部还没有被赋值，所以它的值也是 `undefined`。

3. `var a=b=3;` 将变量 `a` 和 `b` 同时赋值为 `3`。由于赋值操作符从右到左结合，相当于先执行 `b=3`，再执行 `var a=b`。这导致 `b` 成为了全局变量，而 `a` 只在立即执行函数内部声明并赋值为 `3`。

4. `alert(a);` 输出：`3`。在立即执行函数内部，变量 `a` 已经被赋值为 `3`，所以输出为 `3`。

5. `alert(b);` 输出：`3`。由于 `b` 是全局变量，因此在立即执行函数内部对其赋值为 `3`，所以输出为 `3`。

立即执行函数执行完毕后，再次执行：

6. `alert(a);` 输出：`undefined`。由于变量 `a` 是在立即执行函数内部声明的局部变量，它在立即执行函数外部是不可访问的，所以输出为 `undefined`。

7. `alert(b);` 输出：`3`。变量 `b` 是在立即执行函数内部赋值的全局变量，所以在立即执行函数外部仍然可以访问，输出为 `3`。

### 在css中，选择器优先级最高的是

```A
A.ID选择器
B.类选择器
C.标签选择器
D.伪类选择器
```

### 在Objective-c中，以下说法正确的是

```
A.对象被创建出来后，未被引用，它的引用计数是1
B.使用@class类名，就可以把想要的类的接口文件中内容包含进来
C.一个文件中可以声明多个类
D.使用遍历构造器创建的对象需要通过调用release方法释放
```

在Objective-C中，以下说法是正确的：

B. 使用@class类名，就可以把想要的类的接口文件中内容包含进来。

使用@class关键字可以在头文件中引入其他类的声明，而无需包含其完整的接口文件。这在解决类之间的循环依赖问题时非常有用。

其他选项的说明如下：

A. 对象被创建出来后，未被引用，它的引用计数是1：这是不正确的。对象的初始引用计数为0，只有当对象被引用时，引用计数才会增加。

C. 一个文件中可以声明多个类：这是不正确的。Objective-C中每个类通常对应一个单独的源文件和头文件，每个源文件和头文件中只能声明一个类。

D. 使用遍历构造器创建的对象需要通过调用release方法释放：这是不正确的。在Objective-C中，使用遍历构造器创建的对象会自动被设置为autorelease，不需要手动调用release方法进行释放。

### nginx通过___配置多个域名？

```D
A.proxy
B.
C.
D.Server
```

Nginx可以通过"server"块配置多个域名。

在Nginx的配置文件中，可以使用多个"server"块来配置不同的域名或虚拟主机。每个"server"块定义了一个虚拟主机，用于处理特定的域名或主机名的请求。

### 下列说法错误的是？（安卓）

```D
A.Button是普通按钮组件，除此外还有其他的按钮组件
B.TextView是显示文本的组件，TextView是EditText的父类
C.EditText是编辑文本的组件，可以使用EditText输入特定的字符
D.ImageView是显示图片的组件，可以通过设置显示局部图片
```

ImageView是用于显示图片的组件，但是它并不支持直接显示局部图片。通常情况下，ImageView会显示整个图片，而无法只显示图片的一部分。如果想要显示图片的局部区域，需要在外部对图片进行裁剪或者使用其他方式处理。

### 关于JSON和XML说法，错误的是（）

```B
A.JSON的速度要远远快于XML
B.JSON对数据的描述性比XML好
C.JSON相对于XML来讲，数据的体积小
D.JSON和XML同样拥有丰富的解析手段
```

A. JSON的速度要远远快于XML：这个说法是正确的。相比于XML，JSON的解析和序列化速度更快。JSON数据格式使用了更简洁的语法，没有繁重的标记和冗余的结构，因此在数据的传输和处理过程中更加高效。

B. JSON对数据的描述性比XML好：这个说法是主观的，没有一个明确的答案。JSON和XML在描述数据方面具有不同的特点。XML具有自描述性，可以使用自定义标签来描述数据的结构和属性，但是会增加一定的冗余。而JSON使用简洁的键值对结构来表示数据，对于简单的数据结构，JSON可能更加清晰和易读。

C. JSON相对于XML来讲，数据的体积小：这个说法是正确的。由于JSON使用了简洁的语法，没有冗余的标记和结构，相比于XML，JSON在数据的体积方面更加紧凑。这使得在网络传输和存储中，JSON相对于XML具有更小的数据体积，减少了带宽和存储的需求。

D. JSON和XML同样拥有丰富的解析手段：这个说法是不准确的。尽管JSON和XML都是用于数据交换和表示的格式，但它们在解析和处理方面有一些区别。JSON有更简单和直观的解析方式，大多数编程语言都提供了内置的JSON解析器。而XML的解析相对复杂一些，需要使用XML解析器来解析和处理XML文档。因此，JSON的解析相对来说更加简单和方便。

### 在手机开发中常用的数据库是（）

```D
A.Oracle
B.Sql Server
C.Db23
D.SQLite3
```

在手机开发中，常用的数据库包括：

1. SQLite：SQLite 是一种轻量级的关系型数据库管理系统，被广泛用于手机应用的数据存储。它是 Android 平台默认提供的数据库引擎，通过使用 SQLite API，开发者可以在 Android 应用中创建、查询和管理数据库。

2. Realm：Realm 是一种移动端数据库解决方案，具有高性能和易用性。它提供了面向对象的数据模型，可以直接在应用程序中使用对象进行数据操作，而无需使用 SQL 查询语言。

这两个数据库在手机开发中应用广泛，具备不同的特点和优势。开发者可以根据具体的需求和项目要求选择适合的数据库。

### 关于Generator函数的描述，错误的是（A）

```
A.使用return语句使Generator函数暂停执行，直到next方法的调用
B.Generator函数执行后得到的是一个生成器对象
C.声明Generator函数的关键字是：function*
D.Generator函数，又称生成器函数
```

A. 使用yield语句使Generator函数暂停执行，直到next方法的调用。yield语句是Generator函数的关键，它会产生一个值，并暂停函数的执行，等待下一次调用next方法时恢复执行。

B. Generator函数执行后得到的是一个生成器对象。生成器对象是由Generator函数返回的，它是一个特殊的迭代器，具有`next`方法和`Symbol.iterator`方法。

C. 声明Generator函数的关键字是function\*。在声明Generator函数时，需要在function关键字后面加上一个星号(*)，表示这是一个Generator函数。

### css中设置边框是哪一个属性？

在 CSS 中，设置边框可以使用 `border` 属性。

### 下列数据结构中，不能被for...of遍历的是

```B
A、Array数组
B、Object对象
C、String字符串
D、Set结构
```

`for...of` 循环用于遍历可迭代对象（iterable）的元素。可迭代对象包括数组、字符串、Set、Map 等。然而，普通的 Object 对象并不是一个可迭代对象，因此不能直接使用 `for...of` 来遍历它的属性或键值对。

其他选项都是可以使用 `for...of` 进行遍历的：

A. Array数组是一个可迭代对象，可以使用 `for...of` 遍历它的元素。

C. String字符串也是一个可迭代对象，可以使用 `for...of` 遍历它的字符。

D. Set结构是一个可迭代对象，可以使用 `for...of` 遍历它的元素。

### 有以下ES6代码，说法正确的是

```
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
```

```C
A.	gen()执行后返回2 
B.	gen()执行后返回undefined 
C.	gen()执行后返回一个Generator对象 
D.	gen()执行后返回1
```

调用Generator函数后，函数并不执行，而是返回一个迭代器。当该迭代器第一次调用next方法时，函数从头开始执行，内部指针从函数头部指向第一个yield语句，函数执行到该yield语句之后自动暂停，yield后面表达式的值会作为next方法的返回值中的value值。当迭代器再次调用next方法时才会从上次停止的地方 (yield ［表达式］处的后面)开始继续执行， 直到执行完下一句yield语句，或return语句为止。

### 一级跨域传值使用（）

```B
A.Dx...
B.url
C.localStorage
D.cookie
```

在一级跨域传值中，URL 参数传递是一种常见的方式。通过在 URL 中添加参数，可以将数据传递给跨域的目标页面。目标页面可以通过解析 URL 参数来获取传递的值。

其他选项的解释：

A. Dx...：选项 A 不是有效的选择，可能是输入中的错误或不完整的内容。

C. localStorage：localStorage 是一种在浏览器中本地存储数据的机制，可以用于跨页面传递数据，但它并不属于一级跨域传值的直接方法。

D. cookie：cookie 是一种在浏览器中存储数据的机制，它可以在不同页面之间传递数据，但它也不属于一级跨域传值的直接方法。

综上所述，正确的选项是 B. URL。

### 关于WeakSet结构，说法错误的是

```D
A.	与Set结构一样，成员值都是唯一
B.	成员值必须是对象
C.	WeakSet 中的对象都是弱引用
D.	可以forEach( )方法实现遍历
```

### 不是android中activity的生命周期的是：

```A
A.	Onbind
B.	Onstop
C.	Oncreate
D.	Ondestroy
```

### 下面哪个的优先级最高

```C
A.	类选择器、属性选择器
B.	Html元素选择器、伪元素选择器
C.	Html内联样式
D.	Id选择器
```

根据CSS选择器的优先级规则，正确的顺序应该是：

1. Html内联样式的优先级最高。
2. Id选择器的优先级高于类选择器和属性选择器。
3. 类选择器和属性选择器的优先级相同。
4. Html元素选择器和伪元素选择器的优先级最低。

因此，正确的答案是：C. Html内联样式具有最高的优先级，高于Id选择器。

### 以下错误的是

```C
A.400：语义有误，当前请求无法被服务器理解
B.401：当前请求需要用户验证
C.403：浏览器已经理解请求，但是拒绝执行它// 服务器
D.500-599 用于指出服务器错误
```

## 多选：

### Java web应用程序中，必须配置的配置文件为？

```B（C）
A.config.js   
B.web.xml		
C.applicationContext.xml	
D.jdbc.properties
```

在Java Web应用程序中，必须配置的配置文件是：

B. web.xml

web.xml 是 Java Web应用程序的部署描述符文件，它必须存在于 WEB-INF 目录下，并包含了对应用程序的配置信息和部署规范的定义。该文件用于配置 Servlet、Filter、Listener 等组件的映射和参数设置，以及其他相关的部署配置。

**其他选项：**

A. config.js 是 JavaScript 应用程序的配置文件，不是 Java Web应用程序必须的配置文件。

C. applicationContext.xml 是 Spring Framework 的配置文件，用于配置应用程序的依赖注入和组件配置，它并不是 Java Web应用程序必须的配置文件，而是用于配置 Spring 相关的功能。

D. jdbc.properties 是用于配置数据库连接的属性文件，它不是 Java Web应用程序必须的配置文件，而是用于配置数据库连接信息的。

因此，正确答案是 B. web.xml 是 Java Web应用程序必须的配置文件。

### 将文件从docker中拷贝下来的指令有几种？

```AB
A.COPY		
B.ADD	 
C.WORKDIR		
D.忘了
```

在Docker中，可以使用以下指令将文件从容器中复制到主机：

A. COPY：使用 COPY 指令可以将文件从主机复制到容器内部，或者从一个容器复制到另一个容器。语法如下：
   ```
   COPY <源路径> <目标路径>
   ```

B. ADD：ADD 指令与 COPY 指令类似，但 ADD 指令还支持自动解压缩功能。除了复制文件，它还可以复制 URL、本地 tar 文件、并且在复制的过程中自动解压缩。语法如下：
   ```
   ADD <源路径> <目标路径>
   ```

C. WORKDIR：WORKDIR 指令用于设置容器内部的工作目录，它不直接用于文件复制，而是用于指定容器中的工作目录路径。

所以，可以使用 A. COPY 和 B. ADD 两种指令将文件从 Docker 容器中复制到主机。

### ES2017 引入了字符串补全长度的功能，如果某个字符串不够指定长度，用（）补全。

```AB
A.padStart()
B.padEnd()
C.Repeat()
D.Foreach()
```

### 页面有一个id为 button1的按钮，如何通过原生的js禁用？(IE 考虑IE 8.0以上版本) ()

```CD
A.document.getElementById("button1").readonly= true;
B.document.getElementById("button1").setAttribute('readonly','true');
C.document.getElementById("button1").disabled = true;
D.document.getElementById("button1").setAttribute('disabled','true');
```

通过原生js的 `document.getElementById("button1").setAttribute` 属性设置禁用时，第二个参数不论设置什么样的值,都能进行禁用。应该js在检测标签时只要有disabled时，便设置为禁用。

### CSS准从什么原则

```ABCD
A.	单一负责
B.	样式是唯一来源
C.	修饰符
D.	分离容器和内容
```

### java中线程安全的类有

```CD
A.string
B.arraylist
C.hashtable
D.vector
E.statck
```

Hashtable和Vector类都是早期版本的集合类，它们在设计时考虑了线程安全性。它们在多线程环境中使用时可以确保线程安全，但在单线程环境中可能会引入性能开销。

A. String类是不可变类，因此它天生是线程安全的。

B. ArrayList类和E. Stack类不是线程安全的。如果在多线程环境中使用它们，需要采取额外的同步措施来确保线程安全，例如使用Collections类的synchronizedList方法包装ArrayList，或使用java.util.concurrent包中的并发集合类。

### Activity启动方式有：

```BCD
A.singleactivity
B.singleTop
C.singleTask
D.singleInstance
```

### 测试包括：

```ABCD
A.	安全测试
B.	性能测试
C.	功能测试
D.	单元测试
```

测试通常包括以下几个方面：

A. 安全测试：用于评估系统或应用程序的安全性，检测潜在的漏洞和风险，并验证安全措施的有效性。

B. 性能测试：用于评估系统或应用程序在各种负载条件下的性能和响应能力，包括处理速度、吞吐量、资源利用率等方面的测试。

C. 功能测试：用于验证系统或应用程序的功能是否按照规格要求正确运行，包括输入输出的正确性、界面交互的准确性等方面的测试。

D. 单元测试：用于测试软件的最小可测试单元，通常是代码中的函数或方法，以验证其行为是否符合预期。

这只是测试的一些常见类型，实际上还有其他类型的测试，如回归测试、集成测试、验收测试等，根据具体的项目和需求可能会有所不同。

### Nginx中属于全局块配置的有（）

```ABD
A.  允许生成的worker process数
B.  进程pid存放路径
C.  每个work process可以同时支持的最大连接数
D.  日志存放
```

几个重要的块，包括全局块、events 块、http 块、server 块和 location 块。这些块在 Nginx 配置文件中起着不同的作用。

1. 全局块：这是配置影响整个 Nginx 服务器的指令的地方。例如，设置运行 Nginx 服务器的用户组、Nginx 进程的 PID 存放路径、日志存放路径、配置文件的引入以及允许生成的 worker process 数量等。

2. events 块：这是配置影响 Nginx 服务器与用户网络连接的指令的地方。您可以在这里设置每个进程的最大连接数、选择使用哪种事件驱动模型来处理连接请求、是否允许同时接受多个网络连接、是否开启多个网络连接序列化等。

3. http 块：这是一个包含多个 server 块的容器，用于配置 HTTP 服务器相关的全局参数。您可以在此处进行文件引入、定义 MIME 类型、自定义日志、指定是否使用 sendfile 传输文件、设置连接超时时间、限制单连接请求数等。

4. server 块：这是配置虚拟主机相关参数的地方，一个 http 块可以包含多个 server 块。每个 server 块定义了一个虚拟主机，您可以在此处设置主机名、监听端口、SSL 配置、代理等。

5. location 块：这是配置请求的路由和处理不同页面的情况的地方。您可以在此处根据 URI 匹配规则，指定特定的处理逻辑或重定向规则。

这些块在 Nginx 配置文件中起到关键作用，通过合理配置这些块，可以实现丰富的功能和灵活的请求处理。

### 下面在android中合法的属性有哪些（）

```ABC
A.  android：id
B.  android：name
C.  android：description
D.  android：protectionlevel
```

### 项目管理包括（）

```
A.	负责人
B.	设计
C.	目标
D.	计划
```

A. 负责人：确定项目的负责人和团队成员，分配任务和责任，协调团队工作。

B. 设计：在项目管理中，设计通常是指项目的整体设计和规划，包括项目范围、目标、工作分解结构等。

C. 目标：确定项目的目标和期望结果，明确项目的愿景和目标，以便在项目执行过程中保持一致性和导向性。

D. 计划：制定项目计划，包括项目的时间计划、资源分配、风险管理等，确保项目按照预期的时间和资源进行管理和实施。

综上所述，选项A、C和D都是项目管理的内容，而选项B中的"设计"可能与具体项目的设计阶段相关，但并不是项目管理的核心内容。因此，选项B是错误的。

## 判断：

```
1.^\d{n,}$表示只能输入至少n位的字符串
2.命令模式由于为每一个请求封装一个对象，所以会增加系统的复杂度
3.命令模式会解除请求的发送者与请求的执行者之间的耦合
4.http和https性能相差无几
5.迭代器模式
6.设计模式的链式模式
7.过程可视化中流水线也需要被公开
8.设计模式的中介模式， 订阅者是双向的，既可以是消息的发布者，也可以是消息的订阅者
9.观察者模式降低了目标与观察者之间的耦合关系,独立控制
```

1. 错误。正则表达式^\d{n,}$表示只能输入至少n位的数字字符串。
2. 正确。命令模式的设计思想是将请求封装成对象，使得请求的发送者和请求的执行者解耦。封装每个请求为一个对象可能会增加系统的复杂度。
3. 正确。命令模式通过将请求封装成对象，使得发送者和执行者之间解耦，发送者只需要知道如何发送请求的命令对象，而无需关心请求的具体执行细节。
4. 错误。性能方面，HTTPS通常会比HTTP慢一些。HTTPS需要进行加密和解密操作，这会增加数据传输的时间和计算的开销，从而导致性能稍差于HTTP。
5. 迭代器模式是一种行为设计模式，它提供一种顺序访问聚合对象中各个元素的方法，而不需要暴露其内部表示。迭代器模式通过使用迭代器对象，客户端可以逐个访问聚合对象的元素，而无需了解其内部结构。
6. 链式模式不是设计模式的标准术语，可能是指链式调用或者链式编程的概念。链式调用是一种编码风格，通过在方法返回时返回对象自身，可以实现对同一个对象进行多个方法的连续调用，以提高代码的可读性和简洁性。链式编程则是指在编程过程中使用链式调用的方式来构建复杂的操作流程，使代码更加简洁、可读性更高。然而，链式调用或链式编程不是一种独立的设计模式。
7. 错误。在过程可视化中，流水线的公开性取决于具体的情况和需求。有时候，流水线的细节可能需要保密或仅限于特定的团队成员。
2. 错误。设计模式中的中介模式是用于解耦对象之间的关系，通过引入一个中介对象来协调它们的交互。订阅者是接收消息的一方，而发布者是发送消息的一方。订阅者不会直接成为消息的发布者。

3. 正确。观察者模式通过定义一对多的依赖关系，使得目标对象与观察者对象之间的耦合关系降低。目标对象只需要知道观察者接口，而不需要了解具体的观察者对象。这种解耦使得目标对象和观察者对象可以独立地进行扩展和修改。

## 单选

### 以下哪种不是安卓布局？

```C
A.FrameLayout
B.LinearLayout
C.BorderLayout
D.TableLayout
E.RelativeLayou
```

### 单选ios中，导航栏和侧边栏各占（）点

```A
A.49 44
B.44 44
C.44 49
D.49 49 
```

### 下面哪个不是RegExp对象的方法？（）

```B
A.test 
B.match 
C.exec 
D.compile
```

1. test(str)：检测给定的字符串是否匹配正则表达式。如果匹配返回true，否则返回false。
2. exec(str)：在给定的字符串中执行正则表达式的匹配。如果找到匹配项，则返回一个数组，否则返回null。数组包含匹配的文本以及捕获组的信息。
3. toString()：返回正则表达式的字符串形式。
4. compile()：用于动态编译正则表达式，已经在 ECMAScript 6 标准中被废弃，不推荐使用。在当前的 JavaScript 实现中，正则表达式在创建时已经自动编译，不需要显式地调用 compile 方法。
5. match是字符串对象的方法

### 使用AIDL完成远程service方法调用下列说法不正确的是（）

```A
A.aidl对应的接口名称不能与aidl文件名相同
B.aidl的文件的内容类似java代码
C.创建一个Service（服务），在服务的onBind(Intent intent)方法中返回实现了aidl接口的对象
D.aidl对应的接口的方法前面不能加访问权限修饰符
```

AIDL（Android Interface Definition Language）对应的接口名称可以与aidl文件名相同。AIDL文件定义了远程服务接口的方法和参数，而接口名称应该与aidl文件名一致。

### 接口的类型有

```ACD
A.  Soap
B.  http+url
C.  Resultful
D.  Web Service
```

接口的类型可以是Soap、Restful和Web Service。这些类型定义了接口的通信协议和数据传输方式。HTTP+URL不是一种独立的接口类型，而是一种使用HTTP协议和URL进行通信的方式，可以用于实现Soap、Restful或Web Service接口。因此，选项B不是接口的类型，而是一种通信方式。

### `Math.log1p(-1)`的值为（）

```B
A.	NaN
B.	-Infinity
C.	-1
D.	0
```

`Math.log1p(-1)` 是 JavaScript 中的一个数学函数调用。该函数返回给定数字加1后的自然对数值。

在这种情况下，`Math.log1p(-1)` 将返回 `-Infinity`，因为 `-1` 加1得到 `0`，而 `Math.log(0)` 的结果是 `-Infinity`，表示无穷小。

### Docker file中`add`和`copy`的区别

```C
A.没区别
B.copy复制并解压
C.add复制并解压
```

1. `COPY` 只能复制本地文件或目录到容器中，而 `ADD` 支持更多的源文件选项，包括远程文件 URL 和压缩文件自动解压。
2. `COPY` 只是简单地将文件复制到目标位置，而 `ADD` 则具有更多的功能。例如，`ADD` 可以自动解压缩压缩文件，并且还可以通过指定远程 URL 自动下载文件。
3. 由于 `ADD` 具有自动解压缩功能，因此在只需要简单复制文件时，推荐使用 `COPY`，这样可以更明确地表示意图，并避免不必要的行为。

### 下面不能设置宽度的是

```
A.textarea    
B.input   
C.image    
D.button
```

### devops和敏捷开发的区别

```D
A.devops会替代敏捷开发
B.没有区别
C.DevOps会持续的监控软件运行情况和进行持续的开发。
D.敏捷开发会持续的监控软件运行情况和进行持续的开发。
```

DevOps和敏捷开发是两个不同的概念，它们分别关注软件开发过程中的不同方面。

敏捷开发（Agile Development）：敏捷开发是一种软件开发方法论，旨在通过迭代和增量的方式开发软件，以快速响应变化的需求并提供高质量的软件。==不会持续监控软件运行情况，也不是强调持续的开发。敏捷开发主要关注快速交付高质量的软件，并通过迭代的方式不断改进和优化。==敏捷开发强调团队协作、自组织和快速交付，并倡导面对变化时灵活适应的能力。敏捷开发的核心原则包括：
- 个体和交互胜过过程和工具
- 可工作的软件胜过详尽的文档
- 客户合作胜过合同谈判
- 响应变化胜过遵循计划

DevOps（Development and Operations）：DevOps是一种软件开发和运维的理念和实践方法，旨在通过软件开发团队和运维团队之间的协作和自动化来实现快速、稳定和可靠的软件交付。DevOps关注软件开发和运维的整个生命周期，包括需求分析、开发、测试、部署和运维阶段。DevOps的核心原则包括：
- 自动化：通过自动化工具和流程提高效率和准确性
- 协作：开发团队和运维团队之间的紧密协作和沟通
- 持续交付：实现频繁、可靠的软件交付
- 监控和反馈：持续监控和反馈系统状态和性能

因此，敏捷开发侧重于软件开发过程中的灵活性和迭代交付，而DevOps关注整个软件交付过程中开发和运维的协同合作和自动化。它们可以相互配合，共同推动软件开发和交付的效率和质量。

### 以下命名不正确的有

```A
A.3hu        B._KK        C.$KK        D.const
```

合法的命名规则如下：

- 只能以字母、下划线（_）或美元符号（$）开头
- 其他字符可以是字母、数字、下划线或美元符号的组合
- 不得使用保留关键字或特殊字符作为命名
- 区分大小写

### Set集合使用forEach遍历返回的值是（）

```B
A.	{}
B.	遍历器对象
C.	0
D.	
```

当使用`forEach`方法遍历Set集合时，它会为每个元素执行提供的回调函数。该回调函数的参数包括当前遍历的元素值、元素索引和被遍历的Set集合本身。回调函数执行的返回值是undefined，而不是Set集合的元素。

`forEach`方法的返回值是一个遍历器对象。遍历器对象可以用于手动控制遍历过程，例如使用`next()`方法逐个访问Set集合的元素。

### 以下会返回true的是（）

```C
A.alert(isNaN(true))
B.alert(isNaN(10))
C.alert(isNaN('true))
D.alert(isNaN('10'))
```

A. `alert(isNaN(true));` 输出 `false`。因为`true`是一个数值类型的值（1），不是NaN。

B. `alert(isNaN(10));` 输出 `false`。因为整数值10是一个有效的数值，不是NaN。

C. `alert(isNaN('true'));` 输出 `true`。因为字符串'true'不能被转换为数值，所以返回NaN。

D. `alert(isNaN('10'));` 输出 `false`。因为字符串'10'可以被转换为整数值10，所以不是NaN。

### nginx通过___配置多个域名（）

```D
A.proxy
B.
C.
D.server
```

### 执行以下代码，其实现的效果为（）

```html
<div>
   <input type="button" id ="button1" value="1" onclick="moveBtn(this);">
   <input type="button" id ="button2" value="2" />
</div>
<script type="text/javascript">
   function moveBtn(obj) {
     var clone = obj.cloneNode(true);
     var parent = obj.parentNode;
     parent.appendChild(clone);
     parent.removeChild(obj);
  }
</script>
```

```B
A.鼠标单击button1后将button1链接到button2的后面
B.鼠标单击button1后将button1移动到button2的后面
C.鼠标单击button1后将button2移动到button1的后面
D.鼠标单击button1后将button2链接到button1的后面
```

button1节点绑定了点击事件，当鼠标点击该节点时，就会触发moveBtn事件处理函数，并为moveBtn函数传入button1节点。在该函数内部，先调用cloneNode()复制了button1节点，然后使用parentNode属性获取button1元素节点的父节点，即div元素节点，再通过appendChild()方法为div元素节点在其最后一个子节点，即button2节点末尾处添加button1子节点，最后调用removeChild()方法将当前被点击到的button1节点删除，整个效果相当于点击button1时，将button1移动到button2后面，B选项正确。

### Set 四个遍历方法的返回值

1. `Set.prototype.keys()`: 返回一个新的迭代器对象，包含 Set 对象中的所有元素的键值。

2. `Set.prototype.values()`: 返回一个新的迭代器对象，包含 Set 对象中的所有元素的值。

3. `Set.prototype.entries()`: 返回一个新的迭代器对象，包含 Set 对象中的所有元素的键值对。

4. `Set.prototype.forEach()`: 该方法没有返回值，它通过回调函数对 Set 对象中的每个元素进行迭代处理。

需要注意的是，Set 的迭代器对象是按照元素插入的顺序进行迭代的。

### 以下关于JWT说法不正确的是

```
A.JWT是JSON Web Token的简称
B.可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名
C.JWT 并不使用 Cookie，无需担心跨域资源共享问题（CORS）
D.用户状态不再存储在服务端的内存中，是一种有状态的认证机制
```

A. JWT是JSON Web Token的简称，它是一种用于在网络应用间传递信息的安全方法。

B. JWT可以使用HMAC算法或RSA的公/私钥对JWT进行签名，以确保其完整性和认证性。

C. JWT并不使用Cookie，因此可以避免跨域资源共享问题（CORS）。

D. 用户状态不再存储在服务端的内存中，而是一种==无状态的认证机制==，因为JWT包含了所有必要的信息，无需在服务端保留用户状态。

所以，不正确的说法是D. "用户状态不再存储在服务端的内存中，是一种有状态的认证机制"。正确的说法应该是JWT是一种无状态的认证机制。

### 以下关于cookie的描述，错误的是

```D
A.	浏览器对于cookie的尺寸和个数都有限制
B.	如果设置的cookie失效时间是一个已经过去的时间，则cookie会立刻被删除
C.	指定安全标志后，cookie只有在使用SSL连接时才会发送到服务器
D.	Window.cookie属性可以设置为一个新的cookie字符串
```

A. 浏览器对于cookie的尺寸和个数都有限制，不同浏览器有不同的限制。

B. 如果设置的cookie失效时间是一个已经过去的时间，浏览器会立刻删除该cookie。

C. 指定安全标志后，cookie只有在使用SSL连接时才会发送到服务器，提供更高的安全性。

D. Window.cookie属性是一个只读属性，用于获取当前文档的所有cookie字符串，而无法直接设置为一个新的cookie字符串。

### 以下不是js创建对象的设计模式

```D
A.	代理模式
B.	原型模式
C.	单例模式
D.	简单工厂模式
```

A. 代理模式是一种结构型设计模式，通过引入代理对象来控制对原始对象的访问。

B. 原型模式是一种创建型设计模式，通过克隆已有对象来创建新对象。

C. 单例模式是一种创建型设计模式，确保一个类只有一个实例，并提供全局访问点。

D. 简单工厂模式并不是一种创建对象的设计模式，它是一种用于创建对象的简单工厂方法。它并没有被广泛认可为设计模式的一部分。

所以，不是用于创建对象的设计模式是 D. 简单工厂模式。

### 对于一个li节点，哪一个优先级最高

```D
A.  li .cnt
B.  li #app
C.  #app span
D.  #app .cnt
```

标签权重为1，类选择器权重为10，id为100；

A 1+10 =11；B 1+100=101；C 100+1=101；D 100+10=110

### 以下关于css背景描述正确的是

```B
A.	Body-size属性规定背景图片的尺寸
B.	Background-origin属性规定背景图片的定位区域
C.	Css3不允许为元素设置多个背景图像
D.	背景图片大小只能通过像素数定义
```

A. Body-size属性并不存在，正确的属性是background-size，用于规定背景图片的尺寸。

B. Background-origin属性规定背景图片的定位区域。它可以设置背景图片的起始位置，可以是内容区域、内边距区域或边框区域。

C. CSS3允许为元素设置多个背景图像，通过使用多个background-image属性可以实现多个背景图层。

D. 背景图片的大小可以使用像素数来定义，也可以使用其他单位如百分比、em等来表示。可以通过background-size属性来设置背景图片的大小。

### 以下描述错误的是

```C
A.	Cookie和localstorage都会伴随着http请求发送到服务器
B.	在js中可以操作cookie
C.	Js在浏览器的执行是单线程的
D.	Html5的新增存储方式包括localstorage、sessionStorage
E.	Get提交的url会有长度限制，而post提交的数据则可以比较大
```

A. Cookie和localstorage都会伴随着HTTP请求发送到服务器，Cookie通过设置在请求头中，localstorage不会发送到服务器。

B. 在JavaScript中可以通过document.cookie属性操作cookie，包括设置、获取和删除。

C. 这个描述是错误的。JavaScript在浏览器中是单线程执行的，也就是说它一次只能执行一个任务。然而，浏览器中还有其他的线程，比如渲染线程和网络请求线程，这些线程可以并行执行。

D. 正确，HTML5新增了localstorage和sessionStorage两种存储方式，用于在浏览器端存储数据。

E. 正确，GET提交的URL有长度限制，不同浏览器有不同的限制，而POST提交的数据则可以相对较大，通常没有明确的长度限制。

所以，描述错误的是 C. Js在浏览器的执行是单线程的。

### 代码题

```
var s = new Set();
console.log(s.size); // 0
s.add({});
s.add({});
console.log(s.size); // 2
```

### JavaScript事件流顺序是什么？

```D
A.捕获阶段、目标阶段、触发阶段
B.捕获阶段、冒泡阶段、触发阶段
C.冒泡阶段、捕获阶段、目标阶段
D.捕获阶段、目标阶段、冒泡阶段
```

事件流的顺序是首先进入捕获阶段，然后是目标阶段，最后是冒泡阶段。

在捕获阶段，事件从最外层的元素开始向下传播，直到达到触发事件的目标元素。

在目标阶段，事件到达目标元素，即触发事件的元素。

在冒泡阶段，事件从目标元素开始向上冒泡，逐级向上传播到最外层的元素。

### 下面的代码运行结果是（）

```-22
var a = 20;
console.log(~a - 1);
```

在给定的代码中，变量 `a` 被赋值为 `20`。

在 JavaScript 中，`~` 是按位非（NOT）运算符。按位非运算符将操作数的每个位取反，即将 0 变为 1，将 1 变为 0。

将 `a` 进行按位非运算：`~a`

20 的二进制表示为 `00010100`。按位非运算后，对应位的结果为 `11101011`。

接下来，对结果再减去 1，即 `~a - 1`。

`~a` 的结果为 `11101011`，减去 1 后的结果为 `11101010`。

转换回十进制，`11101010` 对应的十进制值是 `-22`。

所以，运行 `console.log(~a - 1);` 的输出结果将是 `-22`。



```6
var a = 2;
var b = 4;
console.log(a ^ b);
```

在给定的代码中，变量 `a` 被赋值为 `2`，变量 `b` 被赋值为 `4`。

在 JavaScript 中，`^` 是按位异或（XOR）运算符。按位异或运算符将两个操作数的对应位进行异或操作，即如果对应位的两个操作数不相同，则结果为 1，否则为 0。

将 `a` 和 `b` 进行按位异或运算：`a ^ b`

2 的二进制表示为 `0010`，4 的二进制表示为 `0100`。按位异或运算后，对应位的结果为 `0110`。

转换回十进制，`0110` 对应的十进制值是 `6`。

所以，运行 `console.log(a ^ b);` 的输出结果将是 `6`。





```10
var het = 0xa;
console.log(het);
```

在给定的代码中，变量 `het` 被赋值为 `0xa`。

在 JavaScript 中，以 `0x` 开头的数值表示十六进制数。所以 `0xa` 表示十六进制的数值，对应的十进制值为 `10`。

因此，运行 `console.log(het);` 的输出结果将是 `10`。



```
'andandmomandmom'.match(/and(andmom(andmom))/)[2]
```

该代码使用正则表达式 `/and(andmom(andmom))/` 对字符串进行匹配，并返回匹配结果的第二个捕获组的值。

在给定的字符串 `'andandmomandmom'` 中，可以匹配到两个连续的子字符串 `'andmom(andmom)'`，因此第一个捕获组的值是 `'andmom(andmom)'`。

而在第一个捕获组 `'andmom(andmom)'` 中，可以再次匹配到一个子字符串 `'andmom'`，因此第二个捕获组的值是 `'andmom'`。

因此，`'andandmomandmom'.match(/and(andmom(andmom))/)[2]` 的值是 `'andmom'`。

### Input新增的属性是什么

一些常见的HTML5新增的输入类型包括：
- `color`：用于选择颜色的输入框
- `date`：用于选择日期的输入框
- `email`：用于输入电子邮件地址的输入框
- `number`：用于输入数值的输入框
- `range`：用于选择范围的滑块输入
- `url`：用于输入URL地址的输入框

此外，HTML5还引入了一些与输入相关的属性，如：
- `placeholder`：设置输入框的占位符文本
- `required`：指示输入框为必填项
- `autocomplete`：指示浏览器是否应该自动填充输入框
- `pattern`：设置输入框的正则表达式模式，用于验证输入值的格式

请注意，以上列出的属性和输入类型只是HTML5中的一部分新增内容。随着HTML标准的发展和更新，可能会引入更多新的属性和输入类型。如果您指的是其他时间点或更具体的属性，请提供更详细的信息。

### 下列哪个方法不是字符串使用正则的方法 

```B
A.	split
B.	test
C.	search
D.	replace
```

在 JavaScript 中，字符串可以使用正则表达式进行操作，如匹配、替换等。根据选项提供的方法，以下是答案：

B. test 方法是不是字符串使用正则的方法。test 方法是 RegExp 对象的方法，而不是字符串对象的方法。它用于测试正则表达式与字符串是否匹配，并返回布尔值。

而其他选项的方法都是字符串对象的方法，可以用于处理字符串与正则表达式的匹配和替换：

A. split 方法用于将字符串分割为字符串数组，可以使用正则表达式作为分隔符进行分割。
C. search 方法用于在字符串中查找与正则表达式匹配的子串，并返回匹配的位置。
D. replace 方法用于将字符串中与正则表达式匹配的子串替换为指定的字符串。

所以，答案是 B. test。

## 多选：

### 那些是集中式的开发工具

```A
A、SVN   
B、蓝鲸  
C、jmeter   
D、kaifa
```

SVN是一种版本控制系统，它采用集中式的工作模式，通过一个中央仓库来管理和协调多个开发者之间的代码版本控制。开发者可以从中央仓库中获取最新的代码，并将自己的修改提交回中央仓库。SVN提供了版本管理、分支管理、冲突解决等功能，适用于中小型团队的代码协作和版本控制。

其他选项蓝鲸、jmeter和kaifa不是常见的集中式开发工具。蓝鲸是一个面向企业的应用管理平台，jmeter是一款开源的性能测试工具，kaifa是中文词汇，表示"开发"，不是特指某个开发工具。

### 项目变更管理是为了

项目变更管理是为了有效管理和控制项目中的变更，以确保项目变更的合理性、可控性和稳定性。其主要目的包括：

1. 确保变更的合理性：通过评估变更的影响、风险和收益，确保只有合理的变更被引入项目中，以避免不必要的变更和潜在的问题。

2. 控制变更的范围：通过建立变更管理流程和规范，确保所有的变更都经过审批和控制，防止非授权的变更引入项目，从而维护项目的稳定性和可追踪性。

3. 最小化变更的风险：通过变更评估和测试，识别和减轻变更可能带来的风险，确保变更的实施不会对项目造成重大影响或负面后果。

4. 保证变更的可追踪性：建立变更记录和文档，跟踪和记录每个变更的详细信息，包括变更的原因、实施过程、相关人员等，以便后续追溯和审计。

5. 提高项目透明度和沟通：通过变更管理的过程，促进项目团队内部和相关利益相关者之间的沟通和协作，确保变更的共识和理解，并及时向相关方通报和更新变更的状态和进展。

总而言之，项目变更管理旨在管理和控制项目中的变更，确保变更的合理性、可控性和稳定性，以最大程度地减少风险并保证项目的成功交付。

### 度量覆盖范围

度量覆盖范围是指在软件测试中，用于评估测试的效果和质量的度量指标。它描述了测试活动对软件代码中的哪些部分进行了覆盖，并帮助确定测试的完整性和可靠性。

常见的度量覆盖范围指标包括以下几个方面：

1. 语句覆盖（Statement Coverage）：衡量在测试中执行了多少条源代码语句。它是最基本的覆盖指标，表示测试是否覆盖了代码中的每一条语句。

2. 分支覆盖（Branch Coverage）：衡量在测试中覆盖了多少个条件分支。它关注于测试是否覆盖了代码中的所有可能分支，包括条件语句中的每个分支和循环语句的退出条件。

3. 函数覆盖（Function Coverage）：衡量在测试中调用了多少个函数。它表示测试是否覆盖了代码中的每个函数。

4. 条件覆盖（Condition Coverage）：衡量在测试中覆盖了多少个条件。它关注于测试是否覆盖了代码中每个条件的所有可能取值，包括逻辑表达式和复合条件。

5. 路径覆盖（Path Coverage）：衡量在测试中覆盖了多少个可能的执行路径。它关注于测试是否覆盖了代码中所有可能的路径，包括循环的不同迭代次数和条件的不同组合。

这些覆盖范围度量指标可以帮助评估测试的全面性和质量，并指导测试活动的改进。在实际测试中，通常会综合使用多个覆盖范围指标来评估测试的效果，并根据需求和资源的限制进行权衡和选择。

## 判断

```
1、平铺导航模式是在内容组织上没有层次关系，展示的内容都放置在一个主屏幕上，采用分屏或分页控制器进行导航，可以左右或者上下滑动屏幕查看内容。

2、es6是在编译时执行的、

3、SaccDoc为创建一系列开放和个性化的文档提供了工具

4、Iterator接口是为for...of服务的

5、next返回值为false，代表代码结束

6、iOS从Backgroud转向Active调用的函数

7、JavaScript中trimEnd()会使字符串末尾换行无效。

8、生成器可以不写yield
```

1、平铺导航模式是在内容组织上没有层次关系，展示的内容都放置在一个主屏幕上，采用分屏或分页控制器进行导航，可以左右或者上下滑动屏幕查看内容。

2、ES6（ECMAScript 2015）是一种JavaScript的版本，它是在运行时执行的，而不是在编译时执行。ES6提供了许多新的语法和功能，例如箭头函数、类、模块等，这些功能在代码运行时被解释和执行。编译时执行通常指的是在代码编译阶段进行的静态分析、优化和转换等操作，而ES6的语法和功能是在JavaScript引擎解释执行阶段实际运行的。因此，判断是错误的。

3、

4、Iterator接口是为for...of服务的。正确。Iterator接口定义了一个迭代器对象，用于迭代可迭代对象的元素。

5、next返回值为false，代表代码结束。不正确。在迭代器中，next方法返回一个对象，其中包含value和done两个属性。done为true表示迭代结束，为false表示迭代还未结束。

6、iOS从Backgroud转向Active调用的函数：`applicationDidBecomeActive(_:)`。在iOS中，当应用从后台转到活动状态时，UIApplicationDelegate协议中的`applicationDidBecomeActive(_:)`方法会被调用。这个方法通常用于执行一些在应用活跃状态下需要执行的操作。

7、错误。应该是空格不是换行。知识点：trimStart(),trimEnd()。 ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。

8、错误。生成器函数必须包含至少一个 `yield` 语句。`yield` 是生成器函数的关键字，用于指示生成器的执行暂停并产生一个值。如果生成器函数没有 `yield` 语句，那么它实际上就不是一个生成器函数，而只是一个普通的函数。

### 常见的导航模式

1. 标签导航模式：使用标签或选项卡来组织和切换不同的内容区域。
2. 折叠导航模式：通过折叠或展开导航菜单来节省屏幕空间，用户可以选择性地显示或隐藏导航项。
3. 侧边栏导航模式：将导航菜单放置在屏幕的侧边栏，以便用户可以随时访问并进行导航。
4. 导航抽屉模式：通过滑动或点击按钮来打开或关闭一个导航抽屉，其中包含了导航链接或菜单。
5. 分级导航模式：将内容按照层级关系组织，用户可以通过导航菜单或面包屑进行深层次的导航。
6. 图标导航模式：使用图标或符号来表示不同的导航项，以便用户可以通过点击图标进行导航。

### `Await()`

`await`：在JavaScript中，`await` 是用于等待一个异步操作完成并返回结果的关键字。它只能在异步函数内部使用，并且用于等待一个返回 Promise 对象的表达式的完成。在等待期间，`await` 会暂停函数的执行，直到 Promise 对象被解析或拒绝。

### `sleep()`

