## CSS编写样式的方式以及应用场景

1、内联样式（Inline Style）：在 HTML 标签中直接写入样式代码，使用 style 属性，例如：

```css
<div style="color: red; font-size: 16px;">这是一个红色的字体，大小为 16px</div>
```

应用场景：适用于只需要对单个元素进行样式设置的情况，但不推荐频繁使用。

2、内部样式表（Internal Style Sheet）：在 HTML 文件的头部定义样式表，使用 style 标签，例如：

```css
<head>
  <style type="text/css">
    .box {
      color: red;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="box">这是一个红色的字体，大小为 16px</div>
</body>
```

应用场景：适用于需要对页面多个元素进行样式设置，但不需要全局应用的情况。

3、外部样式表（External Style Sheet）：将样式表放在一个独立的 CSS 文件中，使用 link 标签引入，例如：

```css
<head>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
  <div class="box">这是一个红色的字体，大小为 16px</div>
</body>
```

应用场景：适用于需要全局应用到网站中的多个页面的情况，提高代码的可维护性和复用性。

在 `index.css` 文件中使用 `@import url(路径)` 可以引入其他的 CSS 样式文件，例如：

```css
@import url("reset.css");
@import url("base.css");
```

4、除了以上的三种方式，还有一些 CSS 预处理器和框架，如 Sass、Less、Bootstrap 等，它们可以帮助开发者更加高效地编写和管理 CSS 代码。

## 颜色的表示方式

在 CSS 中，常用的颜色表示方式有以下几种：

1. 关键字表示法：使用预定义的颜色名称，如 `red`、`blue`、`green` 等。
2. RGB 表示法：使用三个数字来表示红、绿、蓝三个颜色通道的值，取值范围为 0-255，如 `rgb(255, 0, 0)` 表示红色，`rgb(0, 255, 0)` 表示绿色，`rgb(0, 0, 255)` 表示蓝色。
3. 十六进制表示法：使用 `#` 符号加六个十六进制数字来表示颜色，如 `#FF0000` 表示红色，`#00FF00` 表示绿色，`#0000FF` 表示蓝色。
4. RGBA 表示法：与 RGB 表示法类似，不同之处在于多了一个透明度（alpha）通道，取值范围为 0-1，如 `rgba(255, 0, 0, 0.5)` 表示半透明的红色。
5. HSL 表示法：使用色相（Hue）、饱和度（Saturation）、亮度（Lightness）三个参数来表示颜色，如 `hsl(0, 100%, 50%)` 表示红色，`hsl(120, 100%, 50%)` 表示绿色，`hsl(240, 100%, 50%)` 表示蓝色。
6. HSLA 表示法：与 HSL 表示法类似，不同之处在于多了一个透明度（alpha）通道，取值范围为 0-1，如 `hsla(0, 100%, 50%, 0.5)` 表示半透明的红色。

这些表示方式可以根据不同的需要进行选择，如需要精确控制颜色时使用 RGB 或十六进制表示法，需要设置透明度时使用 RGBA 或 HSLA 表示法，需要直观地表达颜色时使用关键字表示法等。

## 在网页中的应该使用奇数还是偶数的字体？为什么呢？

在网页中，通常应该使用偶数的字体大小。这是因为，在计算机屏幕上，每个像素点都是由一个红、绿、蓝三个子像素构成的，而子像素的数量是偶数。如果使用奇数的字体大小，就会出现一种情况，即字体在像素边界上的情况下，字体的边缘会落在两个子像素之间，导致字体显示不清晰，出现模糊、虚化的情况。

举个例子，假设使用 11px 大小的字体，在计算机屏幕上，每个像素点都由 3 个子像素构成，那么每个子像素就应该负责 11 / 3 = 3.67px 的区域。这时，就会出现一些子像素负责的区域只有 3px 或 4px 的情况，从而导致部分字体边缘的位置落在两个子像素之间，造成字体显示不清晰。

因此，为了保证字体在计算机屏幕上显示清晰，通常应该使用偶数的字体大小，如 10px、12px、14px 等。这样，每个子像素负责的区域就是一个整数像素，可以保证字体显示清晰。

偶数号字体比奇数号字体更容易对齐。这是因为在 CSS 中，字体的基线（baseline）和行高（line-height）都是按偶数像素值来计算的，使用偶数号字体可以使文字垂直对齐更加准确，使网页看起来更加整洁和美观。

如果使用奇数号字体，可能会出现基线和行高之间的偏差，导致文字垂直对齐不准确，给人留下不协调的感觉。此外，不同浏览器在处理奇数号字体的方式也可能会有所差异，因此使用偶数号字体可以提高网页的可移植性和兼容性。

需要注意的是，使用偶数号字体并不是绝对的规则，具体情况还需根据实际情况进行判断和调整。在某些特定情况下，如需要显示中文汉字，可能会使用奇数号字体来实现更好的排版效果。

## 具体说明text-align居中的条件

text-align 属性用于控制**行内内容**在**块级容器**内的水平对齐方式，包括文本、图片等元素。直接翻译过来设置文本的水平对齐方式 (是继承属性)

- MDN解释: 定义行内内容（例如文字）如何相对它的块父元素对齐(可以设置图片居中)
- W3C官方文档解释: 设置行内(inline-level)元素(没有填满父元素)在快级父元素的对齐方式

常见的属性值包括 left、center、right 和 justify。

需要注意的是，text-align 只影响行内元素的对齐，不影响容器本身的对齐方式。如果需要控制容器的对齐方式，可以使用其他的 CSS 布局属性。

对于行内元素，text-align 属性的居中条件取决于父容器的宽度和元素本身的宽度。当父容器具有固定的宽度时，可以使用 text-align:center 将元素居中对齐，且元素宽度小于等于父容器宽度时才能水平居中对齐。当元素为行内元素或浮动元素时，元素所在的容器宽度为其包含的所有文本宽度之和。

需要注意的是，对于块级元素，需要设置其 display 属性为 inline-block 或 table-cell，才能够使用 text-align 居中对齐。如果将块级元素的 display 属性设置为 block，则 text-align:center 不会起作用。

另外，需要注意的是，text-align:center 只控制文本的水平对齐，对于文本的垂直对齐需要使用其他属性，如 line-height、vertical-align 等。

text-align CSS 属性定义**行内内容**（例如文字）如何**相对它的块父元素**对齐。

text-align 并**不控制块元素自己的对齐**，只**控制它的行内内容的对齐。**

## 将块级元素居中

将块级元素转换为行内级元素，Dislplay:inline-block；

第二种调整外边距，Margin:0 auto；

## line-height和heigh区别

`line-height` 和 `height` 是 CSS 中用于控制元素高度的两个属性，但它们的作用有所不同。

`line-height` 属性用于设置元素的行高，即每一行文本的高度，包括文本本身和其周围的间距。该属性的取值可以是具体的像素值，也可以是相对于元素字体大小的百分比值。默认情况下，行高与元素的字体大小相等。

相比之下，`height` 属性则用于设置元素的高度，即元素所占据的垂直空间。该属性的取值可以是具体的像素值，也可以是相对于父元素或视口的百分比值或其他相对单位。

需要注意的是，`height` 属性只适用于非替换元素（如 `div`、`p` 等），它们的高度通常由它们的内容决定，如果没有显式设置高度，它们的高度将自适应其内容。而对于替换元素（如 `img`、`input` 等），其高度通常由其内容的大小和样式决定，可以使用 `height` 属性显式设置其高度。

因此，`line-height` 和 `height` 属性的作用是不同的，前者用于控制文本的行高，后者用于控制元素的高度。它们通常用于不同的场景中。

## line-height为什么可以让文字居中？

行高的严格定义是： 两行文字基线（ baseline ）之间的间距

基线（ baseline） ：与小写字母 x 最底部对齐的线

line-height 属性可以让文字垂直居中的原因是因为它控制的是行盒模型的高度，而不是文本本身的高度。每一行的行盒高度等于 line-height 的值，因此如果将 line-height 设置为与容器的高度相等，那么行盒的高度也与容器的高度相等。当文本放置在行盒内时，它会自动垂直居中。因此，通过将 line-height 和 height 设置为相同的值，可以使文本垂直居中于容器中。

例如，假设我们有一个 div 容器，其高度为 50px，如下所示：

```
<div style="height: 50px; line-height: 50px;">This is some text.</div>
```

在这个例子中，我们将 line-height 属性设置为 50px，这意味着行高和容器高度相等。因此，文本将垂直居中于 div 容器中。

需要注意的是，如果文本的高度超过行高，文本内容将会超出容器的高度范围。此外，line-height 属性的值还会影响行间距（行与行之间的距离）。如果 line-height 的值较小，那么行间距也会相应变小，反之亦然。

## CSS选择器归类

- 通用选择器（universal selector）
- 元素选择器（type selectors）
- 类选择器（class selectors）
- id选择器（id selectors）
- 属性选择器（attribute selectors）
- 组合（combinators）
- 伪类（pseudo-classes）
- 伪元素（pseudo-elements） 

## 总结目前所学过的所有选择器？

CSS选择器是用于定位和选择HTML或XML文档中的特定元素的模式。以下是CSS选择器的分类和应用场景总结：

### 基本选择器：

- 标签选择器：通过元素的标签名来选择元素。适用于需要对整个文档中的特定标签进行样式设置的情况。

```css
/* 设置所有 p 元素的文本颜色为红色 */
p {
  color: red;
}
```

- 类选择器：通过元素的class属性值来选择元素。适用于需要针对某个或某些元素进行样式设置的情况。

```css
/* 设置所有类名为 .button 的按钮元素的背景颜色为蓝色 */
.button {
  background-color: blue;
}
```

- ID选择器：通过元素的id属性值来选择元素。适用于需要仅对单个元素进行样式设置的情况。

```css
/* 设置 ID 为 #header 的元素的文本颜色为白色 */
#header {
  color: white;
}
```

### 属性选择器：

- 属性选择器：通过元素的属性名和属性值来选择元素。适用于需要选择具有特定属性和属性值的元素的情况。

```css
/* 设置所有带有 href 属性的 a 元素的文本颜色为蓝色 */
a[href] {
  color: blue;
}
```

### 伪类选择器：

- 链接伪类选择器：通过元素在不同状态下的链接状态来选择元素。适用于需要根据元素的链接状态来设置样式的情况。

```css
/* 设置所有链接在鼠标悬停时的文本颜色为红色 */
a:hover {
  color: red;
}
```

- 伪元素选择器：通过在元素的某个位置插入虚拟元素来选择元素。适用于需要在元素的特定位置设置样式的情况。

```css
/* 设置所有 p 元素的首行文本缩进为 2 个字符 */
p::first-line {
  text-indent: 2em;
}
```

### 组合选择器：

- 后代选择器：通过选择元素的后代元素来选择元素。适用于需要选择某个元素的后代元素进行样式设置的情况。

```css
/* 设置所有 div 元素内的 p 元素的文本颜色为绿色 */
div p {
  color: green;
}
```

- 子元素选择器：通过选择元素的子元素来选择元素。适用于需要选择某个元素的直接子元素进行样式设置的情况。

```css
/* 设置所有 ul 元素下的直接子元素 li 的文本颜色为灰色 */
ul > li {
  color: gray;
}
```

- 相邻兄弟选择器：通过选择与元素相邻的兄弟元素来选择元素。适用于需要选择某个元素相邻的兄弟元素进行样式设置的情况。

```css
/* 设置所有 class 为 .item 的元素后面紧邻的第一个兄弟元素的文本颜色为紫色 */
.item + * {
  color: purple;
}
```

- 通用兄弟选择器：通过选择与元素的兄弟元素来选择元素。适用于需要选择某个元素的兄弟元素进行样式设置的情况。

```css
/* 设置所有 class 为 .item 的元素后面所有的兄弟元素的文本颜色为灰色 */
.item ~ * {
  color: gray;
}
```

以上是CSS选择器的分类和应用场景总结。使用合适的选择器可以提高样式设置的效率和准确性。

## 结构伪类的使用方法？

结构伪类用于选择符合一定结构规则的元素，常用的结构伪类包括：nth-child、nth-of-type、first-child、last-child、only-child等。下面是这些结构伪类的使用方法：

1. :nth-child(n)：选择当前元素的父元素下的第n个子元素，无论是什么类型的元素。其中n可以为一个数值，也可以是一个表达式，例如：nth-child(2n+1)表示选择父元素下的第1、3、5、7、9……个子元素。
2. :nth-of-type(n)：选择当前元素的父元素下的第n个相同类型的子元素。其中n可以为一个数值，也可以是一个表达式。
3. :first-child：选择当前元素在其父元素下的第一个子元素。
4. :last-child：选择当前元素在其父元素下的最后一个子元素。
5. :only-child：选择当前元素在其父元素下仅有的一个子元素。

下面是一些示例：

```css
/* 选择表格的偶数行 */
tr:nth-child(even) {
  background-color: #f2f2f2;
}

/* 选择每个段落的第一个子元素 */
p:first-child {
  font-weight: bold;
}

/* 选择每个链接的最后一个子元素 */
a:last-child {
  text-decoration: underline;
}
```

结构伪类的使用方法较为简单，但需要注意选择器的精确匹配，以及表达式的正确性，才能达到想要的效果。

## CSS的层叠性和继承性

1、层叠性：当多个CSS规则应用于同一个HTML元素时，它们可能会产生冲突，例如多个规则定义相同的属性，但是使用不同的值。在这种情况下，CSS的层叠性会决定哪个规则应该具有最高的优先级，以及最终的属性值是什么。

层叠性的优先级是通过三种方式确定的：元素的重要性（如!important声明）、选择器的特殊性和规则的顺序。通常，重要性大于特殊性，而特殊性大于顺序。

2、继承性：CSS的另一个重要概念是继承性，它指的是父元素的某些CSS属性会自动传递到其子元素。例如，如果给body元素设置了字体颜色为红色，那么所有子元素的字体颜色默认也会是红色，除非它们自己定义了不同的颜色。

- 一般和字体相关的具有继承性
- 自己添加的属性，优先级较高
- 继承过来的属性，是**计算值**，不是设置值；
- 查阅文档看是否继承
- 可以强制继承，使用`inherit`

不是所有属性都具有继承性，只有一些特定的属性才能继承。通常，与文本样式相关的属性（如字体、颜色、行高、字母间距等）都具有继承性，而与盒模型相关的属性（如宽度、高度、边框、内边距等）则没有继承性。

继承性和层叠性共同影响了CSS样式的应用和优先级。理解这两个概念对于编写高效和可维护的CSS代码非常重要。

## CSS选择符有哪些？哪些属性可以继承？

CSS选择器是指定CSS规则将应用于哪些元素的方法。以下是一些常见的CSS选择器：

1. 元素选择器：通过元素名称选择元素，如p、h1、div等。
2. 类选择器：通过指定类名选择元素，以“.”开头，如.class。
3. ID选择器：通过指定ID选择元素，以“#”开头，如#id。
4. 属性选择器：通过元素的属性选择元素，如[type="text"]、[href]等。
5. 伪类选择器：用于指定元素的特殊状态，如:hover、:active等。
6. 伪元素选择器：用于指定元素的特殊部分，如::before、::after等。
7. 子元素选择器：用于选择元素的子元素，如ul > li，表示选择ul元素下的所有li子元素。
8. 相邻兄弟选择器：用于选择紧接在另一个元素后的兄弟元素，如h1 + p，表示选择紧接在h1元素后的p元素。
9. 通用选择器：用于选择任意元素，如*，表示选择所有元素。

CSS属性的继承性是指当父元素设置某些属性时，这些属性会自动传递给子元素。以下是一些具有继承性的常见CSS属性：

1. 字体属性：如font-family、font-size、font-weight、line-height等。
2. 文本属性：如color、text-align、text-decoration等。
3. 列表属性：如list-style-type、list-style-position等。
4. 表格属性：如border-collapse、border-spacing等。
5. 其他属性：如visibility、cursor等。

需要注意的是，并非所有的CSS属性都具有继承性，只有特定的属性才会被继承。

## CSS优先级算法如何计算？

优先级比较：!important > 内联样式 > id > class > 标签 > 通配

CSS优先级算法是用于确定给定选择器的样式规则的优先级的算法。CSS样式规则通常使用选择器指定应用它们的HTML元素，但是可能存在多个规则适用于同一个元素。在这种情况下，CSS优先级算法可以帮助浏览器确定应该使用哪个样式规则。

CSS优先级算法将选择器分成四个级别，每个级别的优先级不同。这些级别依次是：

1. 内联样式：使用style属性直接为元素指定样式的规则。
2. ID选择器：使用#标识符指定的规则。
3. 类选择器、属性选择器和伪类选择器：使用.、[]和：标识符指定的规则。
4. 元素选择器和伪元素选择器：使用标签名和::标识符指定的规则。

优先级算法通过给每个级别分配一个权重值，然后将这些权重值组合起来来确定每个规则的优先级。权重值的计算方法如下：

- 对于内联样式，权重值为1000。
- 对于每个ID选择器，权重值为100。
- 对于每个类选择器、属性选择器和伪类选择器，权重值为10。
- 对于每个元素选择器和伪元素选择器，权重值为1。

然后，将所有匹配的规则的权重值相加，以确定哪个规则的优先级最高。如果两个或多个规则的权重值相同，则后面出现的规则将覆盖先前出现的规则。

例如，如果一个元素同时匹配一个类选择器和一个元素选择器的规则，那么类选择器的规则将优先于元素选择器的规则，因为类选择器的权重值为10，而元素选择器的权重值为1。

需要注意的是，这个算法并不是绝对的，有时可能存在其他因素影响样式规则的应用。

!import **10000**

通配符选择器 **0**

## HTML元素的类型

1、块级元素：独占父元素的一行

2、行内级元素：多个行内级元素可以在父元素的同一行中显示

事实上，元素没有本质区别，块级元素仅仅是因为浏览器默认添加了display属性而已

**HTML元素编写的注意事项：**

1、块级元素、inline-block元素

- 一般情况下，可以包含其他任何元素（比如块级元素、行内级元素、inline-block元素）
- 特殊情况，p元素不能包含其他块级元素，

在`<p>`元素中不要放`<div>`元素，会出现问题。浏览器会默认将`<p>`元素单独包裹，并且独占一行。

2、行内级元素（比如a、span、strong等）

- 一般情况下，只能包含行内级元素
- 行内级元素内不要放块级元素，

## display常见的值（非常重要）

1、display属性，修改元素的显示类型，有四个常用值：

- block：让元素显示为块级元素
- inline：让元素显示为行内级元素
- inline-block：让元素同时具备行内级、块级元素的特征
- none：隐藏元素

2、block元素:块级元素

- 独占父元素的一行；
- 可以随意设置宽高，设置后依然独占一行；
- 高度默认由内容决定；

3、inline-block元素:行内块级元素

- 跟其他行内级元素在同一行显示；
- 可以随意设置宽高；
- 可以这样理解；
  - 对外来说，它是一个行内级元素
  - 对内来说，它是一个块级元素

4、inline:行内元素

- 跟其他行内级元素在同一行显示;；
- 不可以随意设置宽高;
  - （准确的说法：行内非替换元素不可以设置宽度和高度）

- 宽高都由内容决定（包裹内容），不能设置宽度和高度;
- 对于图像，虽然是一个行内元素，但是可以设置宽高，因为对于图像，他还是一个替换元素；
- 行内替换元素
  - 和其他行级内元素在同一行显示
  - 可以设置宽度和高度

## 总结元素隐藏的方法，并且说出他们的区别

方法一: display设置为none

- 元素不显示出来, 并且也不占据位置, 不占据任何空间(和不存在一样);
- 不会对子元素产生影响。

方法二: visibility设置为hidden

- 设置为hidden, 虽然元素不可见, 但是会占据元素应该占据的空间;
- 默认为visible, 元素是可见的;
- 对子元素也会生效。

方法三: rgba设置颜色, 将a的值设置为0

- rgba的a设置的是alpha值, 可以设置透明度, 不影响子元素;
- Background-color的默认值Transparent即为

```css
/* rgba：（0，0，0，0，） */
```

- 不会对子元素产生影响。

方法四: opacity设置透明度, 设置为0

- 设置整个元素的透明度, 会影响所有的子元素;
- 会影响所有的子元素

方式五：height: 0; 或者 width: 0;

- 使用该属性可以将元素的高度或者宽度设置为0，使得元素不占用页面空间，但是仍然可以在页面中找到该元素。

这些方法的区别主要体现在隐藏的效果、是否占用页面空间以及是否对子元素生效等方面。

## 对margin的传递和折叠的理解

Margin是CSS中用来控制元素边缘空白区域的属性。在元素布局和定位时，margin可以用来控制元素与其周围元素之间的间隔。在使用margin时，需要注意以下两个概念：margin传递和margin折叠。

1. Margin传递

Margin传递是指当一个元素有多个子元素时，子元素的margin可能会影响父元素的margin。当子元素的margin和父元素的margin相遇时，它们不会简单地叠加在一起，而是取两者之间的较大值作为实际的margin。这种传递效果可以将margin传递给父元素，使得父元素的margin随着子元素的margin发生变化。

2. Margin折叠

上下相邻元素的margin会发生折叠。当两个相邻的元素的margin值都是正数时，它们之间的实际margin值将是它们两者之间的较大值减去较小值。

- 上下相邻元素的margin会发生折叠。当两个相邻的元素的margin值都是正数时，它们之间的实际margin值将是它们两者之间的较大值减去较小值。
- 父子元素的margin也会发生折叠。当一个元素没有border或padding来阻止其与其子元素的margin合并时，它们之间的margin会发生折叠。这种情况可以通过设置border或padding来避免。


Margin传递和Margin折叠都是CSS中比较重要的概念，特别是在设计页面时需要特别注意它们的影响。Margin传递可以让我们更方便地控制页面元素的间距，而Margin折叠则可能会导致页面设计出现意料之外的效果，需要谨慎处理。

只有在正常流中的块级元素的 margin 才会发生折叠，行内元素和浮动元素之间的 margin 不会发生折叠。同时，使用了 flexbox 和 grid 布局的元素的 margin 也有可能不会发生折叠。

常见的产生margin折叠的情况包括：

- 相邻的两个元素都没有border、padding和inline内容；
- 相邻的两个元素的方向相同（都是垂直方向或都是水平方向）；
- 相邻的两个元素都属于同一个BFC（块级格式化上下文）。

为了避免margin折叠，开发者可以采取以下措施：

- 给元素添加border或padding；
- 将元素设置为inline-block或float；
- 将元素放在一个新的BFC中。

## CSS不生效技巧

1. CSS文件没有被正确链接：检查HTML文件中的链接地址是否正确，确保链接的是正确的CSS文件。
2. 样式表中的语法错误：检查CSS代码是否存在语法错误，例如拼写错误、遗漏分号等。
3. 权重值不正确：CSS选择器有优先级，如果另外一个样式具有更高的权重，那么当前样式可能会被覆盖。可以检查权重是否正确，并使用!important提高当前样式的权重。
4. 样式表的位置不正确：样式表应该放在head标签中，确保在页面渲染之前被加载。
5. 浏览器缓存：如果之前访问过同一个页面，可能会缓存之前的样式，需要清除浏览器缓存。
6. 网络问题：如果CSS文件在服务器上，可能会出现网络问题导致文件无法加载，可以检查网络连接是否正常。
7. 兼容性问题：某些CSS属性在一些浏览器中可能不支持或者有兼容性问题，可以通过浏览器的开发者工具进行调试。
8. CSS样式没有正确应用到对应的HTML元素：检查CSS选择器是否正确，确保样式被应用到正确的HTML元素上。

总之，在调试CSS时，应该仔细检查CSS代码、HTML代码以及浏览器的开发者工具，确定问题的具体原因，然后采取相应的措施进行解决。

## CSS的盒子模型 

CSS盒子模型指的是在HTML页面中，每个元素都被视为一个矩形盒子，该盒子由内容区域、内边距、边框和外边距四部分组成，这四部分共同构成了CSS盒子模型。

**具体来说，CSS盒子模型包含以下四个部分：**

内容区域（content）：该区域显示元素的实际内容，包括文本、图片等。其大小由元素的width和height属性决定。

内边距（padding）：该区域在内容区域与边框之间，用于控制内容区域与边框之间的距离。其大小由元素的padding属性决定。

边框（border）：该区域在内边距之外，用于包裹元素。其大小和样式由元素的border属性决定。

外边距（margin）：该区域在边框之外，用于控制元素与其他元素之间的距离。其大小由元素的margin属性决定。

总之，CSS盒子模型可以帮助我们更好地理解和控制网页元素的布局和样式，是前端开发中非常重要的概念。

**CSS的盒子模型有哪些：**

标准盒子模型、IE盒子模型

**CSS的盒子模型区别：**

标准盒子模型：margin、border、padding、content

- 它的计算方式是将元素的内容区域大小与内边距、边框和外边距分开计算。
- 元素的实际宽度 = 内容区域宽度 + 左右内边距宽度 + 左右边框宽度 + 左右外边距宽度，
- 元素的实际高度 = 内容区域高度 + 上下内边距高度 + 上下边框高度 + 上下外边距高度。

IE盒子模型 ：margin、content（ border +  padding  + content ）

- 它的计算方式是将元素的实际宽度和高度直接包括内边距、边框和外边距。
- 元素的实际宽度 = 内容区域宽度 + 左右内边距宽度 + 左右边框宽度
- 元素的实际高度 = 内容区域高度 + 上下内边距高度 + 上下边框高度

**通过CSS如何转换盒子模型：**

- box-sizing: content-box;    标准盒子模型
- box-sizing: border-box;      IE盒子模型

## margin和padding分别适合什么场景使用

Margin和Padding是CSS中用来控制元素之间距离的两种属性，它们适合的场景有些不同：

- Margin（外边距）适合用于控制元素与其他元素之间的距离，比如用来创建页面布局，控制元素之间的间隔或者使元素与页面边缘保持距离。
- Padding（内边距）适合用于控制元素内部内容与元素边缘之间的距离，比如用来为文本或其他内容创建空白区域，使元素内部内容与边框之间有一定的距离。

具体来说，Margin适合用于以下场景：

- 控制元素之间的距离，比如两个块级元素之间的间隔
- 控制元素与页面边缘的距离，比如将一个元素居中显示
- 控制元素在页面布局中的位置，比如通过设置margin值来实现两列等宽的页面布局

而Padding适合用于以下场景：

- 创建内部间距，使文本或其他内容不紧贴着边框显示
- 为元素的内容创建空白区域，使页面更加美观
- 控制元素内部内容与边框之间的距离，使元素内容看起来更加舒适

## 盒子模型包含的内容以及如何设置

盒子模型里包含

1、内容

- 通过宽度和高度设置

2、内边距

- 通过padding设置
- padding: padding-top    padding-right   padding-bottom    padding-left;

3、边框

- 通过border设置
- border: border-width   border-style   border-color

4、外边距

- 通过margin设置
- margin:   margin-top   margin-right   margin-bottom    margin-left

## 行内非替换元素在设置padding/border的上下时，有什么特殊的地方？

行内非替换元素（如span、a等）在设置上下padding/border时，会导致元素的行高发生变化，但不会撑起行内元素所在的行，也不会对其他行内元素产生影响。

这是因为行内非替换元素默认的高度是由其包含的文本或其他行内元素的高度决定的，而padding/border是应用于元素的内容框而不是盒子本身，所以不会改变内容的高度，只会改变内容框的尺寸。

需要注意的是，如果行内非替换元素设置了display属性为block或inline-block，那么设置padding/border时，会对元素的高度产生影响，撑起所在的行，而不是只影响元素的行高。

## 整理box-sizing的作用，以及content-box和border-box的区别

box-sizing是CSS中用于控制元素盒子模型计算方式的属性，它有两个取值：content-box和border-box。

content-box是默认值，它计算宽度和高度时只包括元素的内容区域（即元素内部的空间），不包括元素的内边距(padding)、边框(border)和外边距(margin)。

- padding 、 border 都布置在 width 、 height 外边

border-box计算宽度和高度时，将包括元素的内容区域、内边距(padding)和边框(border)，但不包括外边距(margin)。也就是说，元素的宽度和高度是包含了边框和内边距的。

- padding 、 border 都布置在 width 、 height 里边

这个属性的主要作用是让开发者更方便地控制元素的尺寸和位置，而不需要考虑元素的边框和内边距对尺寸和位置的影响。另外，如果开发者使用了border-box的取值，可以更方便地实现响应式布局。

## 行内级非替换元素

以下属性对行内级非替换元素**不起作用**：

- width：行内级非替换元素的宽度由其包含的内容决定，不能通过设置 width 属性来改变宽度。
- height：行内级非替换元素的高度同样由其包含的内容决定，不能通过设置 height 属性来改变高度。
- margin-top、margin-bottom：行内级非替换元素的 margin 属性只能设置左右方向的外边距，不能设置上下方向的外边距。

以下属性对行内级非替换元素的**效果比较特殊**：

- padding-top、padding-bottom：行内级非替换元素的 padding 属性可以设置上下方向的内边距，**上下会被撑起来，但是不占据空间，**但是对行内级非替换元素的影响取决于具体实现和浏览器的解析方式。
- 上下方向的 border：同样地，对于行内级非替换元素，上下方向的 border 属性也可能会产生特殊的效果，取决于具体实现和浏览器的解析方式。通常情况下，上下方向的 border 只会影响行内级非替换元素的行高而不会改变其实际高度。

## 元素水平居中的方案以及对应的场景

1、使用margin: auto实现水平居中

这是一种最简单的实现方式，只需要设置元素的左右margin为auto即可实现水平居中。适用于宽度固定的**块级元素**，例如div、img等。但是这种方式对于宽度不确定的元素无法实现居中。

示例代码：

```css
div {
  width: 300px;
  margin: 0 auto;
}
```

2、使用text-align: center实现水平居中

这种方式适用于**行内元素**或者一些可以被text-align属性控制的块级元素，例如p、span等。只需要将父元素的text-align属性设置为center即可实现子元素的水平居中。

示例代码：

```css
div {
  text-align: center;
}

span {
  display: inline-block;
}
```

3、使用flexbox实现水平居中

使用flexbox布局是一种强大的实现水平居中的方式。只需要将父元素的display属性设置为flex，然后通过justify-content属性设置为center即可实现子元素的水平居中。这种方式适用于各种宽度不确定的元素。

示例代码：

```css
div {
  display: flex;
  justify-content: center;
}
```

4、使用position和transform实现水平居中

这种方式通过设置元素的绝对定位和transform属性来实现水平居中。适用于宽度不确定的**块级元素**，例如弹出层、提示框等。

示例代码：

```css
div {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
```

需要注意的是，这种方式需要设置元素的父元素的position属性为relative或者设置body的position属性为relative或者absolute。

这些水平居中的方式在不同场景下都有其适用性，需要根据具体情况选择合适的方式来实现水平居中。

## 显示省略号

```css
/** *单行显示省略号* **/
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
```

## background-image 和img对比

|                        | Img              | background-image |
| ---------------------- | ---------------- | ---------------- |
| 性质                   | HTML元素         | CSS样式          |
| 图片是否占用空间       | √                | ×                |
| 浏览器右键直接查看地址 | √                | ×                |
| 支持CSS sprite         | ×                | √                |
| 更有可能被搜索引擎收录 | √（结合alt属性） | ×                |

- img ，作为网页内容的重要组成部分，比如广告图片、 LOGO 图片、文章配图、产品图片，
- Background-image ，可有可无。有，能让网页更加美观。无，也不影响用户获取完整的网页内容信息，支持CSS sprite

## 表单元素什么情况下使用name和value？ 

在HTML表单中，name和value是两个非常重要的属性，它们用于标识表单中的元素和指定表单元素的值。一般来说，以下情况下应该使用name和value属性：

1. 对于`<input>`元素，name属性用于指定该元素的名称，而value属性用于指定该元素的值。例如，对于一个文本框，name属性用于标识文本框，而value属性用于指定用户在文本框中输入的值。
2. 对于`<select>`元素，name属性用于指定下拉列表的名称，而value属性用于指定选中的选项的值。例如，如果一个下拉列表中有三个选项：A、B、C，那么当用户选择选项A时，value属性应该指定为"A"。
3. 对于`<radio>`和`<checkbox>`元素，name属性用于指定该元素的名称，而value属性用于指定该选项的值。例如，如果一个单选框包含两个选项："是"和"否"，那么当用户选择"是"时，value属性应该指定为"yes"。

总之，使用name和value属性可以让服务器端能够准确地识别和处理表单数据。

## 说出form提交时的属性作用？

HTML中的`<form>`元素是用于创建表单的标准元素，通过它我们可以将用户输入的数据提交到服务器进行处理。在`<form>`元素中，有一些常用的属性可以用来控制表单的提交方式和相关的行为：

1. action属性：指定表单数据提交的目标URL。当用户点击提交按钮时，表单数据将被发送到这个URL。
2. method属性：指定表单数据提交的方式，常用的有GET和POST两种方式。GET方式会将表单数据附加在URL后面，而POST方式则将表单数据放在请求体中发送。
3. target属性：指定表单提交后的响应结果显示在哪个窗口或框架中。常用的取值有\_blank、\_self、\_parent和\_top等。

**以下作为了解**

4. enctype属性：指定表单数据的编码类型，用于支持上传文件等二进制数据的提交方式。常用的取值有application/x-www-form-urlencoded、multipart/form-data和text/plain等。
5. name属性：指定表单的名称，用于与JavaScript交互或者服务器端处理表单数据时的标识。
6. autocomplete属性：控制是否开启表单自动填充功能，可以设置为on或off。
7. novalidate属性：用于禁用浏览器默认的表单验证功能，可以用于自定义表单验证的实现。

通过设置这些属性，我们可以灵活地控制表单数据的提交方式、目标URL、响应结果的显示位置以及数据编码方式等，从而实现各种不同的表单交互场景。

## 结构伪类nth-child和nth-of-type的区别

nth-child和nth-of-type是CSS中常用的结构伪类选择器，它们的区别在于匹配的元素不同：

1. nth-child选择器：匹配父元素下的第n个子元素，无论该子元素的类型是什么。例如，nth-child(2)可以匹配父元素下的第二个子元素，无论它是什么类型的元素。
2. nth-of-type选择器：只匹配指定类型的子元素中的第n个元素。例如，nth-of-type(2)只会匹配父元素下第二个该类型的子元素，而不管其他类型的子元素。

下面是两个示例：

nth-child示例：

```html
<ul>
  <li>第一个元素</li>
  <li>第二个元素</li>
  <li>第三个元素</li>
  <li>第四个元素</li>
  <li>第五个元素</li>
</ul>

/* 匹配父元素下的第二个子元素，即第二个li元素 */
li:nth-child(2) {
  color: red;
}
```

nth-of-type示例：

```html
<ul>
  <li>第一个元素</li>
  <li>第二个元素</li>
  <li>第三个元素</li>
  <li>第四个元素</li>
  <li>第五个元素</li>
  <div>这是一个div元素</div>
  <li>第六个元素</li>
</ul>

/* 匹配父元素下第二个li元素，即第三个元素 */
li:nth-of-type(2) {
  color: red;
}
```

从上面两个示例可以看出，nth-child和nth-of-type在匹配的元素上有一定的区别。在实际应用中，我们需要根据不同的需求选择合适的选择器来匹配元素。

## 伪类和伪元素的区别

伪类和伪元素都是CSS中的重要概念，它们用于对元素进行样式化，但它们之间有一些区别。

伪类是一种用于选择处于特定状态元素的特殊关键词，它们以冒号（:）作为前缀。伪类通常用于根据元素在其当前状态下的某些特性来选择元素，例如:hover、:active、:focus等。这些伪类可以用来为用户提供交互性，例如在鼠标悬停或元素被点击时改变其外观或行为。

伪元素是一种用于选择元素特定部分的关键词，它们以双冒号（::）作为前缀。伪元素用于创建元素内部的样式化内容，例如添加一个额外的文本行或在元素的前面或后面插入一些内容。常用的伪元素包括::before、::after和::first-line等。

总的来说，伪类和伪元素都是CSS的非常重要的概念，它们都可以用来对元素进行样式化，但是它们的作用和使用方式有所不同。

## 如何使用字体图标（从iconfont中下载图标练习）

使用字体图标的步骤如下：

1. 从iconfont中选择并下载需要的图标，可以选择自定义的图标库或者已有的图标库。
2. 解压下载的文件，其中会包含一个名为iconfont.css的样式表文件，以及一组字体文件（通常是.eot、.woff、.ttf和.svg格式），这些字体文件包含了我们需要的图标信息。
3. 将iconfont.css文件复制到项目的CSS目录中，并在HTML文件中引入该样式表，如下所示：

```css
<link rel="stylesheet" type="text/css" href="css/iconfont.css">
```

4. 在HTML文件中使用对应的图标，可以直接在元素中添加class类名来使用，如下所示：

```css
<i class="iconfont icon-heart"></i>
```

在这个例子中，使用了i标签来创建一个字体图标元素，并且添加了两个class类名，分别是iconfont和icon-heart。其中，iconfont是我们自定义的字体图标库名称，而icon-heart则是具体的图标名称，它们的组合表示我们要使用的是一个名为"heart"的图标。

在CSS文件中，我们可以为不同的图标定义不同的样式，例如字体大小、颜色、字体加粗等等。通过修改这些样式，我们可以实现不同的字体图标效果。

```css
.iconfont {
  font-family: "iconfont" !important;
  font-size: 16px;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.icon-heart {
  font-size: 20px;
  color: red;
}
```

在这个例子中，我们首先定义了.iconfont类的样式，指定了字体库的名称以及一些字体相关的样式。然后，定义了.icon-heart类的样式，指定了图标的大小和颜色等属性。这样，我们就可以在HTML文件中使用.icon-heart类来显示一个红色的心形图标。


总之，使用字体图标可以使我们的网页更加美观、灵活和易于维护。通过选择合适的字体图标库，并正确地应用相关的样式，我们可以轻松地在网页中添加各种各样的图标，从而为用户提供更好的体验。

## CSSSprite是什么，有什么优缺点？

CSS Sprite（CSS 精灵）是将多个小图标合并成一张大图，再利用 CSS 的背景定位属性将大图中的不同部分显示为不同的小图标的技术。通常用于优化网页性能，减少 HTTP 请求次数，从而加快网页加载速度。

**CSS Sprite 的优点包括：**

1. 减少 HTTP 请求次数：将多个小图标合并成一张大图后，只需要一个 HTTP 请求就可以获取所有的小图标，减少了 HTTP 请求次数，从而减少了网页加载时间。
2. 提高网页加载速度：由于减少了 HTTP 请求次数，因此可以大大提高网页的加载速度，从而提高用户的体验感。
3. 减小图片文件的大小：将多个小图标合并成一张大图后，可以有效地减小图片文件的大小，从而减小了网页的总体积，提高了网页的加载速度。
4. 减少带宽消耗：由于减小了图片文件的大小和 HTTP 请求次数，因此可以减少带宽消耗，降低了网站的运营成本。

**CSS Sprite 的缺点包括：**

1. 制作和维护成本较高：制作和维护 CSS Sprite 需要一定的技术水平和时间成本，特别是在需要频繁修改或添加图标时，需要重新生成大图，并且需要修改 CSS 样式，这会增加一定的工作量。
2. 可读性和可维护性较差：CSS Sprite 会将多个小图标合并到一张大图中，因此在维护时需要注意图标之间的间距和背景位置等参数，否则容易出现错位或显示不正确的情况。
3. 部分图标显示不完整：由于 CSS Sprite 是将多个小图标合并成一张大图，因此如果某个小图标的位置被其他图标覆盖，那么这个小图标可能会显示不完整，需要特别注意。

总体来说，CSS Sprite 是一种非常实用的技术，可以有效地优化网页性能，但在使用时需要权衡其优缺点，谨慎使用。

## 引入图片的方式

以下是引入图片的不同方式以及适用场景：

`<img>`标签

`<img>`标签是最常用的引入图片的方式，适用于需要在文档中嵌入单张图片的情况。使用`<img>`标签时，可以通过指定`src`属性来引入图片，例如：

```
phpCopy code
<img src="image.jpg" alt="My Image">
```

在这个例子中，使用`<img>`标签来显示名为"image.jpg"的图片，并且添加了一个"alt"属性，用于在图片无法加载时显示替代文本。

`background-image`属性

`background-image`属性可以用于设置元素的背景图片，适用于需要在元素背景中嵌入图片的情况。使用`background-image`属性时，可以通过CSS样式来指定背景图片的URL地址，例如：

```
cssCopy codediv {
  background-image: url("image.jpg");
}
```

在这个例子中，使用CSS样式来将名为"image.jpg"的图片设置为div元素的背景图片。

`border`属性

`border`属性可以用于在元素的边框中嵌入图片，适用于需要在元素边框中显示图片的情况。使用`border`属性时，可以通过CSS样式来指定边框的样式、宽度、颜色等属性，同时使用`url()`函数来指定边框中的图片，例如：

```css
cssCopy codediv {
  border: 10px solid transparent;
  border-image: url("border.png") 30 30 stretch;
}
```

在这个例子中，使用CSS样式来创建一个宽度为10像素、样式为实线、颜色为透明的边框，并且将名为"border.png"的图片嵌入到边框中。

字体图标

字体图标是一种基于字体文件的图标，可以使用CSS样式来引入并显示，适用于需要在网页中使用矢量图标的情况。使用字体图标时，需要先下载字体文件，并将其引入到网页中，然后使用`<i>`或`<span>`等标签来创建图标元素，例如：

```css
<link rel="stylesheet" href="iconfont.css">
<i class="iconfont">&#xe604;</i>
```

在这个例子中，首先通过`<link>`标签引入了字体图标的CSS文件，然后使用`<i>`标签创建一个图标元素，并指定了一个class类名和一个实体字符编码。在CSS文件中，可以为每个图标定义不同的样式，例如颜色、大小、字体加粗等等。

精灵图

精灵图是一种将多张小图片合并成一张大图片的技术，可以通过CSS样式来引用和显示其中的某个小图片，适用于需要在网页中同时显示多个小图片的情况，例如图标、按钮、背景等。使用精灵图时，需要将多张小图片拼合成一张大图片，并通过CSS样式来定义背景位置、大小、重复方式等属性，例如：

```css
.icon {
  width: 20px;
  height: 20px;
  background-image: url("sprite.png");
  background-position: -10px -10px;
}
```

在这个例子中，首先定义了一个宽度和高度都为20像素的元素，并指定了一个名为"sprite.png"的精灵图作为背景图片，然后使用`background-position`属性来指定该元素应该显示精灵图中的哪个小图片。

SVG

SVG是一种基于XML语法的矢量图形格式，可以通过CSS样式和JavaScript脚本来操作和渲染，适用于需要在网页中使用高品质、可缩放的矢量图形的情况。使用SVG时，可以通过`<svg>`标签来创建一个SVG元素，并在其中使用各种形状、路径、文本等元素来描述图形，例如：

```css
<svg width="100" height="100">
  <rect x="10" y="10" width="80" height="80" fill="red" />
</svg>
```

在这个例子中，使用`<svg>`标签创建了一个宽度和高度都为100像素的SVG元素，并在其中使用`<rect>`标签创建一个矩形元素，并指定了其位置、大小和填充颜色等属性。可以通过CSS样式和JavaScript脚本来修改和控制SVG元素的各种属性和行为。

## 绝对定位的相对元素以及常见的解决方案 

子绝父相

- 子元素绝对定位、
- 父元素相对定位

子绝父绝

- 子元素绝对定位
- 父元素绝对定位

子绝父固

- 子元素绝对定位
- 父元素固定定位

## 画布和视口

画布和视口都是与网页中元素的位置和大小有关的概念，它们是页面布局和响应式设计的重要组成部分。

画布（Canvas）指的是浏览器渲染页面的区域，它是一个固定的矩形区域，包含了所有的HTML元素和CSS样式。画布的大小由浏览器窗口的大小和滚动条的位置决定。可以通过CSS设置画布的大小，例如设置页面宽度为100%。

视口（Viewport）指的是用户当前可见的区域，它是浏览器中用于显示页面内容的矩形区域。视口的大小和位置取决于设备的屏幕大小和浏览器窗口的大小，通常情况下，视口的大小比画布小。在移动设备上，用户可以通过缩放来改变视口的大小。

为了使网页在不同设备上都能够正常显示，需要根据视口大小来动态调整页面布局和样式。可以使用CSS媒体查询来检测视口的大小，并根据不同的视口大小应用不同的CSS样式。

在响应式设计中，通常会将视口设置为“响应式”，即使浏览器窗口大小发生变化时，页面的布局和样式也能够自动调整。可以使用CSS的viewport单位和viewport meta标签来实现这个效果。

总之，画布和视口都是页面布局和响应式设计中非常重要的概念，它们之间的关系是浏览器渲染页面的基础。理解这些概念对于开发高质量的网页非常重要。

## 有几种定位？分别是根据什么定位的？

1. 静态定位（static）：元素的默认定位方式，不会被特殊定位，遵循文档流排版。
2. 相对定位（relative）：相对于元素本身在文档流中的位置进行定位，通过top、right、bottom、left属性来控制偏移位置，不影响其他元素的位置，**不脱离文档流**。
3. 绝对定位（absolute）：相对于最近的已定位的父元素进行定位，如果没有已定位的父元素，则相对于文档的初始包含块（initial containing block）进行定位。初始包含块通常是视口（viewport），但在某些情况下可以是其他容器，通过top、right、bottom、left属性来控制偏移位置，**会脱离文档流**，影响其他元素的位置。
4. 固定定位（fixed）：与绝对定位类似，但是它是相对于浏览器窗口进行定位，元素不随页面滚动而移动。
5. 粘性定位（sticky）：在元素到达特定位置时变为固定定位，否则为相对定位。通常使用top、bottom等属性来定义触发位置，需要指定容器元素的宽度和高度。

## relative和absolute区别

`relative`和`absolute`是CSS中两种定位方式，它们有以下的区别：

1. 定位参照不同：`relative`定位相对于元素在文档流中的初始位置进行定位，而`absolute`定位相对于最近的非`static`定位的祖先元素进行定位。

2. 是否影响文档流：`relative`定位不会影响文档流，而`absolute`定位会将元素从文档流中移除，并且不再占据原先的空间。

3. 是否脱离文档流：`relative`定位不会使元素脱离文档流，而`absolute`定位会使元素脱离文档流，不再占据原先的空间。

4. 是否需要设置宽高：`relative`定位不需要设置元素的宽高，可以自动占据原先的空间，而`absolute`定位需要设置元素的宽高，因为它不再占据原先的空间。

5. 是否具有定位上下文：`relative`定位不会创建新的定位上下文，而`absolute`定位会创建新的定位上下文。

在实际开发中，`relative`定位通常用于实现一些相对定位的效果，例如微调元素的位置或者在元素内部进行定位，而`absolute`定位通常用于实现一些绝对定位的效果，例如固定在页面某个位置或者在某个容器内部进行绝对定位。需要注意的是，使用`absolute`定位时应该尽量避免在页面中创建大量的定位上下文，以避免影响性能。

## 浮动常见的规则内容有哪些

**常见规则**

1、元素一旦浮动后, 脱离标准流

- 朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止
- 定位元素会层叠在浮动元素上面

如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界

2、浮动元素之间不能层叠

- 如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）
- 如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止

3、浮动元素不能与行内级内容层叠

4、行内级内容将会被浮动元素推出

- 比如行内级元素、inline-block元素、块级元素的文字内容
- 行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐

**注意**

1. 元素浮动后，会尽量向左或向右移动，直到碰到父容器或另一个浮动元素为止。
2. 父容器的高度不会自适应浮动元素的高度，需要使用清除浮动（clear float）的技巧，例如在父容器最后添加一个空的块级元素，并设置clear属性为both。
3. 元素浮动后，会脱离文档流，影响其他元素的布局和位置。
4. 浮动元素的宽度默认为内容宽度，可以通过设置width属性来指定宽度。
5. 浮动元素可以设置margin、padding和border等样式属性，但需要注意边框和外边距会影响元素的位置和宽度。
6. 替换元素（例如img标签）的宽度由其固有的尺寸计算，而不是根据父容器的尺寸。
7. 可以使用clear属性来清除某个方向的浮动，例如clear:left可以清除左侧的浮动元素影响。
8. 在浮动元素前面的非浮动元素会自动排列在浮动元素的下方，如果需要使非浮动元素和浮动元素并列，可以设置非浮动元素的float属性为相同的方向。
9. 浮动元素可以使用z-index属性来控制层叠顺序，但需要注意浮动元素的z-index值只能在同一层级内比较，与非浮动元素的层叠顺序无关。

## 为什么需要清除浮动？如何清除浮动？

在进行浮动布局时，由于浮动元素脱离了标准流，所以不再向父元素汇报高度，导致父元素无法正确计算子元素的高度，从而产生高度坍塌的问题。

**什么是高度塌陷？**

浮动元素引起的高度坍塌（也称为父元素高度塌陷）是指父元素高度不能自动撑开以适应内部浮动元素的高度，导致父元素的高度计算不正确。具体来说，当一个元素的所有子元素都是浮动元素时，该元素的高度会坍塌为0，因为浮动元素从普通流中脱离，不再影响父元素的高度。

这种高度坍塌现象在布局中可能会带来一些问题，例如无法实现预期的页面布局、内容被遮挡等。

**如何解决？**

为了解决这个问题，需要清浮动。清浮动的目的是让父元素计算总高度的时候，把浮动子元素的高度算进去，从而避免高度坍塌的问题。

清除浮动的方法有多种，其中比较常用的包括：

1. 父容器设置overflow属性为hidden或auto。通过设置overflow属性，可以触发BFC（块级格式化上下文），从而清除浮动。但需要注意，该方法会隐藏超出父容器的内容，可能会影响布局效果。
2. 在浮动元素后添加一个空的块级元素，并设置clear属性为both。该方法可以清除浮动，同时不会影响布局效果。但需要注意，这种方法会增加HTML代码量。
3. 使用伪元素清除浮动，例如在父容器中添加如下CSS样式：

```css
.clear_fix::after {
    content: "";
    display: block;
    clear:both;
    visibility: hidden; /* 浏览器兼容性 */
    height: 0; /* 浏览器兼容性 */
/* 在某些浏览器中，伪元素的高度会占据一定的空间，因此需要设置visibility: hidden和height: 0来隐藏伪元素并占据尽可能少的空间。 */
}
.clear_fix {
*zoom: 1; /* IE6/7兼容性，触发IE6/7的hasLayout属性，从而解决高度塌陷的问题。 */
}
```

然后在父容器中添加一个clearfix类，即可清除浮动。

该方法可以清除浮动，同时不会影响布局效果，而且不需要增加HTML代码量。但需要注意，如果需要支持低版本的IE浏览器，可能需要特殊处理。


总之，清除浮动是一个常见的布局技巧，可以避免浮动元素对布局产生影响。选择合适的方法清除浮动，需要根据具体情况进行选择。

浮动正在退出历史舞台，比较古老的布局方案，目前大多使用flex布局。

## 如何将多个行内级元素中间的空格（间隙）去除

可以使用CSS中的letter-spacing属性来实现去除多个行内级元素中间的空格（间隙）。letter-spacing属性可以设置字符之间的间隔距离，将其设置为负值即可去除字符之间的间隔。

例如，如果想去除多个行内级元素之间的空格，可以将它们的父元素的letter-spacing属性设置为负值，如下所示：

```css
.parent-element {
  letter-spacing: -0.5em;
}
```

上述代码将去除父元素内所有行内级元素之间的空格（间隙），间隙大小为0.5个字母的宽度。需要注意的是，该方法会将所有字符之间的间隔都去除，包括中间的空格和其他字符之间的间隔，因此需要根据实际情况进行调整。

**其他不推荐**

1. 删除换行符：这种方法虽然简单，但是会破坏HTML的结构，不利于代码的维护和阅读。
2. 将父级元素的font-size设置为0：这种方法需要注意子元素设置回原来的字体大小，否则会影响到子元素的布局。此外，如果子元素中本身就有字体大小为0的元素，会产生样式冲突。
3. 通过浮动去除：这种方法需要注意清除浮动，否则可能会导致高度塌陷等问题。另外，如果希望有空隙，需要设置margin-left/right，增加样式的复杂度。
4. flex布局：这种方法的兼容性比float差，需要考虑浏览器兼容性问题。另外，如果需要适配旧版本的浏览器，可能需要使用autoprefixer等工具添加厂商前缀。

总的来说，不同的方法适用于不同的场景，需要根据具体情况选择合适的方法。

## flex布局container和item的属性以及作用（重要）

Flex布局（弹性布局）是CSS3中新增的一种布局方式，通过在容器上设置display:flex或display:inline-flex来触发弹性布局，然后通过设置容器和子元素的各种属性，来实现弹性布局的效果。下面是容器和子元素的一些常用属性及作用：

**容器属性：**

1. display:flex或display:inline-flex：触发容器为弹性容器。
2. flex-direction：设置主轴方向。可选值有row（默认值，表示从左到右）、row-reverse（表示从右到左）、column（表示从上到下）和column-reverse（表示从下到上）。
3. flex-wrap：设置是否换行。可选值有nowrap（默认值，不换行）、wrap（换行，第一行在上）、wrap-reverse（换行，第一行在下）。
4. justify-content：设置主轴上的对齐方式。可选值有flex-start（默认值，左对齐）、flex-end（右对齐）、center（居中对齐）、space-between（两端对齐，中间间隔相等）、space-around（每个项目两侧的间隔相等）。
5. align-items：设置交叉轴上的对齐方式。可选值有flex-start（顶部对齐）、flex-end（底部对齐）、center（居中对齐）、baseline（基线对齐，项目的基线对齐）和stretch（默认值，拉伸对齐，所有项目都拉伸以填满交叉轴）。
6. align-content：设置多根轴线（即多行）的对齐方式。可选值有flex-start（顶部对齐）、flex-end（底部对齐）、center（居中对齐）、space-between（两端对齐，中间间隔相等）、space-around（每个项目两侧的间隔相等）和stretch（默认值，拉伸对齐，所有项目都拉伸以填满交叉轴）。

**子元素属性：**

1. order：设置项目的排列顺序。数值越小，排列越靠前，默认为0。
2. flex-grow：设置项目的放大比例。默认为0，即不放大。
3. flex-shrink：设置项目的缩小比例。默认为1，即如果空间不足，项目将缩小。
4. flex-basis：设置项目在主轴上的初始大小。默认值为auto。
5. flex：是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。
6. align-self：设置单个项目在交叉轴上的对齐方式。可选值有flex-start、flex-end、center、baseline、stretch。

这些属性的组合可以实现各种弹性布局的效果，具体应用需要根据实际情况来选择。

## flex布局之前的痛点

在使用Flex布局之前，Web开发者经常遇到以下痛点：

1. 布局不灵活：在传统的盒模型布局中，元素的宽度和高度受到父元素和子元素的限制，因此在需要自适应布局时，往往需要使用大量的计算和调整。这导致代码复杂度和维护难度增加。
2. 对齐方式不便捷：在传统的布局方式中，实现水平和垂直居中需要使用一些技巧，例如设置margin和padding、使用absolute等，这些方式不仅繁琐，而且在改变元素大小或父元素大小时，需要重新计算位置。
3. 响应式设计困难：传统的盒模型布局无法很好地应对不同设备的屏幕尺寸和分辨率。因此，在响应式设计时，需要使用媒体查询等技术手段，增加代码量和复杂度。
4. 水平对齐和垂直对齐困难：在传统的布局方式中，实现水平和垂直对齐需要使用多种技巧和技术手段，例如使用浮动和定位等。这些技术不仅繁琐，而且在改变元素大小或父元素大小时，需要重新计算位置。

Flex布局通过提供一种基于弹性盒子模型的布局方式，解决了这些痛点。Flex布局可以实现更加灵活和便捷的布局，同时能够很好地支持响应式设计和水平对齐、垂直对齐等常见布局需求。

## 常见的CSS Transform形变有哪些

CSS Transform是一种通过改变元素的形状、大小、位置等来实现动画效果的技术。常见的CSS Transform形变包括：

1. 旋转（rotate）：通过rotate函数改变元素的旋转角度，可以实现元素绕自身中心点或者指定的中心点进行旋转。
2. 缩放（scale）：通过scale函数改变元素的宽度和高度比例，可以实现元素的缩放效果。
3. 移动（translate）：通过translate函数改变元素的位置，可以实现元素的平移效果。
4. 倾斜（skew）：通过skew函数改变元素的倾斜角度，可以实现元素的倾斜效果。
5. 3D变换（3D transform）：通过matrix3d、perspective等函数改变元素在三维空间中的位置、旋转、缩放等属性，可以实现三维效果。
6. 扭曲（matrix）：通过matrix函数改变元素的变换矩阵，可以实现多种形变效果，如扭曲、拉伸、错切等。

> 需要注意的是，CSS Transform是一种渲染技术，不会改变元素的实际属性值，因此不会影响到其他元素的布局和位置。同时，CSS Transform可以与其他动画效果如transition、animation等结合使用，实现更加丰富的动画效果。

## transform/translate/transition分别的作用

transform、translate和transition都是CSS3中常用的动画效果属性，它们的作用如下：

1. transform：transform属性用于对元素进行变形，包括旋转、缩放、倾斜和平移等操作。它可以通过多个变换函数的组合实现复杂的变换效果，例如旋转和缩放同时进行。transform不会影响元素的文档流和布局，因此可以安全地用于动画效果。
2. translate：translate是transform属性中的一个函数，用于将元素在水平和垂直方向上移动。它的语法为translate(x,y)，其中x和y表示元素在水平和垂直方向上移动的距离。如果只指定一个值，则另一个值默认为0。使用translate可以实现元素的平移效果。
3. transition：transition属性用于在元素属性变化时，添加过渡效果。它可以指定属性变化的持续时间、缓动函数和延迟时间等参数，使元素在属性变化时产生渐变的过渡效果。transition可以应用于所有CSS属性，包括颜色、大小、位置、透明度等。

总之，transform和translate用于实现元素的变形和平移效果，而transition用于添加元素属性变化时的渐变过渡效果，从而增强页面的视觉体验。这些属性的使用可以使网页更加生动有趣，提升用户体验。

## CSS Transition 和 Animation 动画的区别

CSS Transition 和 Animation 都是用于实现动画效果的 CSS 属性。它们的区别主要有以下几个方面：

1. 实现方式：Transition 是通过对某个属性的变化来实现动画效果的，而 Animation 则是通过使用 @keyframes 定义关键帧来控制元素的动画过程的。
2. 时间控制：Transition 通过设置一个过渡时间来控制动画的持续时间和速度，而 Animation 可以通过定义多个关键帧以及每个关键帧的时间点和动画效果来精确控制动画的时间和速度。
3. 动画效果：Transition 只能实现相对简单的动画效果，比如颜色渐变、大小变化等，而 Animation 可以实现更加复杂的动画效果，比如旋转、缩放、位移等。
4. 可控性：Animation 可以通过 JavaScript 控制动画的播放、暂停、重复等行为，而 Transition 则相对简单，只能通过控制元素的属性来实现简单的动画效果。

总的来说，Transition 更适合实现简单的动画效果，而 Animation 则更适合实现复杂的动画效果，并且在动画时间的精确控制以及动画行为的可控性方面更加优秀。但是，两种属性也可以结合使用，例如使用 Transition 实现简单的颜色渐变，再通过 Animation 实现复杂的旋转效果。


transition只能实现从一个状态过渡到另一个状态的简单动画效果，无法实现复杂的动画效果。

animation可以使用关键帧（@keyframes）定义动画序列，精细控制每一帧的动画效果。

transition的持续时间、延迟时间和速度曲线等属性是通过CSS属性来控制的，而animation则有自己独立的属性（如animation-duration、animation-delay和animation-timing-function等）来控制动画的时间、延迟和速度曲线。

animation可以使用animation-iteration-count来控制动画的重复次数，而transition只能在执行完一次动画后再次触发才能重复执行。

animation还有一些其他的属性，如animation-direction、animation-fill-mode和animation-play-state等，可以控制动画的播放方向、填充方式和播放状态等。

综上所述，transition适用于简单的过渡效果，而animation则适用于更为复杂的动画效果，可以精细地控制每一帧的动画效果。

## 理解vertical-align的作用和行盒的理解

在CSS中，vertical-align属性用于控制行内元素和表格单元格中元素的垂直对齐方式。它不仅适用于行内元素，也适用于表格单元格中的元素。当我们设置一个元素的vertical-align属性时，它会影响该元素和其相邻元素的垂直对齐方式。

在行内元素中，行盒是一个重要的概念。行盒是由一行内的所有行内盒子（inline boxes）组成的，它们排列在一条基线上。这个基线被定义为行盒的底部，而行盒的顶部则是行内盒子的顶部的最高点。

对于行内盒子而言，其大小和位置受到字体大小、行高、文本间距等因素的影响。当我们设置一个行内盒子的vertical-align属性时，它会影响该盒子和行盒底部之间的垂直距离，进而影响行盒的位置。

需要注意的是，行盒的高度是由最高的行内盒子的顶部和最低的行内盒子的底部之间的距离决定的。因此，当行内盒子的高度不同时，行盒的高度也会不同。在这种情况下，我们可以使用vertical-align属性来控制不同行内盒子之间的垂直对齐方式，以达到视觉上的对齐效果。

在表格单元格中，vertical-align属性同样可以用于控制单元格中的元素的垂直对齐方式。在表格单元格中，行盒的概念不是特别重要，而单元格的高度由其内容决定，因此设置vertical-align属性时需要注意其对单元格内部内容的垂直对齐方式的影响。

总之，vertical-align属性是一个重要的CSS属性，用于控制行内元素和表格单元格中元素的垂直对齐方式，而行盒则是用于描述行内元素排列的概念。了解它们的作用和原理对于理解和掌握CSS布局有着重要的帮助。

**总结：**

1. vertical-align属性用于控制行内元素和表格单元格中元素的垂直对齐方式。
2. 在行内元素中，行盒是由一行内的所有行内盒子（inline boxes）组成的，它们排列在一条基线上。
3. 在行内盒子中，vertical-align属性会影响该盒子和行盒底部之间的垂直距离，进而影响行盒的位置。
4. 在表格单元格中，vertical-align属性同样可以用于控制单元格中的元素的垂直对齐方式。
5. 行盒的高度是由最高的行内盒子的顶部和最低的行内盒子的底部之间的距离决定的。
6. 使用vertical-align属性可以控制不同行内盒子之间的垂直对齐方式，以达到视觉上的对齐效果。

## 对BFC规范的理解？

BFC，即“块级格式化上下文”（Block Formatting Context），是CSS中一个重要的概念，它定义了一套渲染规则来决定块级盒子的布局及其子元素与父元素之间的关系。

BFC是一个独立的布局环境，相当于是一个容器，在其中按照一定的规则对块级元素进行摆放，并且不会影响其他的布局环境中的盒子。

如果一个元素触发BFC，则BFC中的元素布局不受外界的影响。另外，块级元素在标准流中的布局属于BFC。

1、创建条件：

1. 根元素或包含根元素的元素；
2. 浮动元素（float不为none）；
3. 绝对定位元素（position为absolute或fixed）；
4. 行内块元素（display为inline-block）；
5. 表格单元格（display为table-cell）；
6. 表格标题（display为table-caption）；
7. overflow不为visible的块级元素；

2、特点：

1. BFC中的所有元素垂直排列，两个相邻元素的间距由margin决定；
2. BFC中的元素不会被浮动元素覆盖，即不会发生浮动溢出；
3. BFC可以包含浮动元素，从而避免父元素高度塌陷；
4. BFC可以阻止元素被浮动元素覆盖或影响，从而实现布局的控制。

3、作用：

1. 清除浮动：在父元素上触发BFC属性，可以清除浮动，防止**高度塌陷**；
2. 布局控制：通过BFC的一些特性，可以实现布局的控制，例如让两栏布局自适应等；
3. **避免 margin 折叠**：两个相邻的元素在同一个BFC中时，它们之间的margin会发生折叠，而在不同的BFC中时则不会；
4. 实现一些特殊效果：例如多列布局、自适应布局、文字环绕等，都可以通过BFC来实现。

总之，BFC是CSS中非常重要的一个概念，它可以提供很多有用的特性，实现更加灵活和高效的布局效果。在前端开发中，理解BFC的原理和使用方法，对于解决一些布局问题和优化页面性能都非常有帮助。

## 整理<王者荣耀>用到的CSS知识点

1、定位: absolute relative fixed

- 定位实现左右或者垂直居中
- 给盒子一个高度或宽度 l0r0/t0b0 设置margin在对应方向的auto
- 对z-index的设置决定部分定位元素的层叠

2、flex布局

- 运用justify-content align-items来决定axis与cross axis上的元素的位置
- 以及让单个 flex item 不拉伸 设置flex-shrink的值 单纯设置 flex-grow避免flex-basis的影响

3、动画以及transition

- 设置帧动画
- @keyframes来进行透明度的动画
- 设置animation: name duration timing-function delay  等等
- display对动画无效 可以在disblock的时候设置透明度的动画
- 对height设置的transition 可以给父元素设置对应的padding-bottom以及box-sizing:border-box使得文字不动

## CSS编写顺序

1. 布局样式（Layout）：设置元素的布局样式，如display、position、float、clear等。
2. 盒模型（Box Model）：设置元素的大小、边框、内边距和外边距等属性。
3. 字体和文本（Typography）：设置字体、字号、颜色、行高、文本对齐等属性。
4. 背景（Background）：设置元素的背景颜色、背景图片等属性。
5. 边框（Border）：设置元素的边框样式、颜色、宽度等属性。
6. 动画和过渡（Animation & Transition）：设置元素的动画和过渡效果。
7. 其他样式（Miscellaneous）：设置其他样式，如光标样式、溢出处理、轮廓线等。

## 不同像素之间的差异

1. 物理像素（physical pixel）：也称为设备像素，是显示器或移动设备屏幕上的最小物理单元，它们是硬件设备固有的像素。例如，一个分辨率为 1920x1080 的屏幕，就有 1920*1080 个物理像素。
2. 逻辑像素（logical pixel）：也称为设备无关像素，是在软件层面上定义的虚拟像素，是对应于设计师和开发者而言的像素单位。在不同的设备上，逻辑像素的大小可能不同。
3. 设备像素比（device pixel ratio）：是逻辑像素与物理像素的比例关系。例如，若一个移动设备的设备像素比为2，则一个逻辑像素将由4个物理像素来显示。
4. CSS像素（CSS pixel）：也称为视口像素（viewport pixel），是相对长度单位，是基于屏幕的分辨率而定义的。在浏览器中，1个CSS像素等于1个逻辑像素，因此可以用来描述网页中的长度和位置。

## 说出你对视口的理解(面试题)

视口（viewport）是指用户当前正在浏览的网页区域，也称为浏览器窗口。在移动设备上，由于屏幕尺寸较小，需要通过对视口进行设置，使网页在移动设备上得到更好的显示效果。

### pc端的视口

- 就是浏览器的可视区域

### 移动端视口

- 布局视口

  - 会按照一个默认宽度980px,来布局一个页面盒子的内容
  - 为了可以显示完整的页面,会对整个页面进行缩小

  ```html
  <!-- width: 设置布局视口的宽度 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  ```


- 视觉视口

  - 显示在可视区域的视口,就是视觉视口

- 理想视口

  - 当布局视口 = 视觉视口的时候,就是理想视口
  - 怎样是这理想视口呢?

  ```html
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  ```

### 视口可以通过以下方式进行设置：

**meta标签：**

可以通过设置meta标签中的viewport属性来控制视口的大小和缩放等行为。例如：

```
cssCopy code
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

这个meta标签指定了视口的宽度为设备的宽度，初始缩放比例为1。

**CSS：**

可以使用CSS中的@viewport规则来控制视口。例如：

```
@viewport {
  width: device-width;
  initial-scale: 1.0;
}
```

这个@viewport规则指定了视口的宽度为设备的宽度，初始缩放比例为1。

通过设置视口，可以使网页在移动设备上得到更好的显示效果，包括：

1. 自适应布局：可以根据视口的大小自动调整布局，使网页在不同设备上都能得到较好的显示效果。
2. 缩放：用户可以通过手动缩放来调整网页的大小，以适应不同的屏幕尺寸。
3. 移动：用户可以通过手指在屏幕上滑动来移动网页。

## 用CSS画一个三角形

-----

```css
<div class="triangle"></div>

<!-- CSS -->
.triangle {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent #000 transparent;
}
```

## 一个盒子不给宽度和高度如何水平垂直居中？

1. 使用Flexbox布局：将盒子的父元素设置为Flex容器，然后在容器上设置justify-content和align-items属性为center，即可将盒子水平垂直居中。具体代码如下：

```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

```html
<div class="container">
  <div class="box"></div>
</div>
```

2. 使用绝对定位：将盒子的父元素设置为相对定位，然后在盒子上设置绝对定位和top、left、right、bottom属性为0，并将margin设置为auto。具体代码如下：

```css
.container {
  position: relative;
}

.box {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}
```

```html
<div class="container">
  <div class="box"></div>
</div>
```


以上两种方法都可以实现水平垂直居中，具体使用哪种方法取决于具体的需求和情况。

## 写出如下结构及样式

写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块。

```css
<style>
.container {
  display: flex;
  flex-wrap: nowrap;
  height: 100vh;
}

.middle {
  flex-grow: 1;
  min-width: 0;
}

.left,
.right {
  flex: 0 0 200px;
}

.left {
  order: -1;
}

/* 加载中间块 */
.middle {
  background: #ccc;
}
.left {
  background: #f00;
}
.right {
  background: #00f;
}
</style>

<div class="container">
  <div class="middle"></div>
  <div class="left"></div>
  <div class="right"></div>
</div>
```

其中，使用flex-wrap: nowrap来让容器内元素不换行，使用flex-grow: 1来让中间块自适应宽，

使用flex: 0 0 200px来让左右块固定宽200，使用order: -1来将左块置于中间块前面。

为了先加载中间块，可以在CSS中先定义中间块的样式，再定义左右块的样式。

## 什么是CSSreset？

CSS reset（CSS重置）是一种CSS技术，旨在通过移除默认的CSS样式规则并在文档中引入自定义样式规则，以创建一个跨浏览器和跨平台的一致样式。

它的目的是消除不同浏览器之间的默认样式差异，从而提供更加一致的外观和布局，方便开发人员实现定制化的设计。一些常用的CSS reset包括Normalize.css、Reset CSS等。

## display有哪些值？说明他们的作用。

`display`是CSS中用于设置元素展示方式的属性，常见的取值及其作用如下：

1. `block`：块级元素，占据一整行，可设置宽度和高度，可以设置上下左右的外边距和内边距。常用于布局中。

2. `inline`：行内元素，仅占据自身内容的大小，不能设置宽度和高度，只能设置左右的外边距和内边距。常用于文本、图片等元素。

3. `inline-block`：行内块级元素，具有行内元素的特性，同时可以设置宽度和高度，可以设置上下左右的外边距和内边距。常用于实现水平布局。

4. `none`：元素不会被显示出来，常用于通过JavaScript控制元素的显示与隐藏。

5. `flex`：弹性布局，子元素按照一定的规则自动排列，可以设置子元素的排列方向、排列方式、对齐方式等。常用于实现响应式布局。

6. `grid`：网格布局，将页面划分为网格区域，子元素可以占据多个网格，可以设置子元素的位置、大小等。常用于复杂的布局。

7. `table`：表格元素，可设置表格的列宽、行高等样式。

8. `inline-table`：行内表格元素，与`table`类似，但是可以在一行内展示多个表格。

9. `table-cell`：表格单元格元素，只能作为`table-row`的子元素，可以设置单元格的内容、边框等样式。

10. `table-row`：表格行元素，只能作为`table`的子元素，可以设置行高、背景色等样式。

11. `list-item`：列表元素，表现为块级元素，可设置列表项的符号、位置等样式。

除了上述常见的取值外，还有一些不常用的取值，如`inline-flex`、`inline-grid`、`run-in`等，这些取值的作用可以根据具体场景进行查阅。

## 全局属性data-*

全局属性`data-*`是HTML5中新增的自定义数据属性，用于在HTML标签中嵌入自定义数据，以便JavaScript等脚本语言使用。该属性的命名规则必须以`data-`为前缀，后面可以跟任意的自定义名称，但必须是小写字母、数字、连字符（-）或下划线（_）的组合。

例如，我们可以在一个div标签中添加一个自定义数据属性`data-user-id`：

```html
<div data-user-id="12345">John Doe</div>
```

在JavaScript中，可以通过元素对象的`dataset`属性来访问这个自定义数据属性：

```js
var userId = document.querySelector('div').dataset.userId;
console.log(userId); // "12345"
```

`data-*`属性可以用于许多场景，例如在渲染HTML模板时，可以将一些数据嵌入到HTML标签中，从而实现更好的灵活性和可重用性。同时，它也是一种语义化的方式，可以为Web应用程序提供更好的结构和可读性。

## `display:none`与`visibility:hidden`的区别

1、占用位置的区别

`display: none`不占用位置

`visibility: hidden`虽然隐藏了，但是占用位置

2、重绘和回流的问题

`visibility: hidden`和`display: none`产生重绘

`display: none`还会产生一次回流

> 产生回流一定会造成重绘，但是重绘不一定会造成回流。
>
> 产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....
>
> 产生重绘的情况：样式改变、换皮肤

## opacity和rgba区别

opacity 和 rgba() 都可以用来控制元素的透明度，但它们的实现方式不同。

opacity 是一个数值，表示元素的透明度，取值范围是 0（完全透明）到 1（完全不透明）。opacity 的取值**会影响元素及其子元素的透明度**，且会影响元素的交互和事件响应，即透明度为 0 的元素不可交互，透明度为 0 的元素及其子元素不会响应鼠标事件。

rgba() 是一种颜色表示方式，包含四个数值，前三个是 RGB 颜色值，取值范围是 0 到 255，最后一个是透明度值，取值范围是 0（完全透明）到 1（完全不透明）。rgba() 只是控制元素的颜色透明度，**不会影响元素及其子元素的交互和事件响应。**

因此，如果只需要控制元素的透明度，可以使用 opacity；如果需要控制元素的颜色和透明度，可以使用 rgba()。

## ::before和:after

**::before和:after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用。**

在 CSS 中，`::before` 和 `::after` 是伪元素，它们分别在元素的内容前面和后面插入一个虚拟的元素。它们的作用是可以用来为元素添加一些装饰性的内容，如图标、箭头、边框等，同时又不影响元素的语义结构。

在 CSS3 中，`::before` 和 `::after` 伪元素用双冒号 `::` 来表示。而在 CSS2 中，这两个伪元素用单冒号 `:` 来表示。在 CSS3 中，单冒号 `:` 仍然可以用来表示这两个伪元素，但是为了区分伪元素和伪类，推荐使用双冒号 `::`。

双冒号和单冒号的区别在于，双冒号 `::` 表示伪元素，单冒号 `:` 表示伪类。伪元素和伪类都是用来为元素添加一些特殊效果的，但是它们的作用和实现方式不同。

具体来说，`::before` 和 `::after` 伪元素可以通过 CSS 的 `content` 属性来定义它们的内容，同时也可以使用其他 CSS 属性来对它们进行样式设置。例如，下面的代码定义了一个带有箭头的按钮：

```css
button::before {
  content: "";
  display: inline-block;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-color: transparent transparent transparent #333;
  margin-right: 10px;
}
```

上面的代码中，通过 `content: ""` 定义了伪元素的内容为空，然后使用 `border` 属性定义了一个三角形，并设置了右边距。这样，所有的按钮元素都会自动添加这个带有箭头的装饰性元素。

总之，`::before` 和 `::after` 伪元素是一个很方便的功能，可以为元素添加一些装饰性的内容，而又不会影响到 HTML 结构和语义。它们可以通过 CSS 的各种属性来进行样式设置，使得网页设计更加丰富和有趣。

**常见的用途有：**

- 在页面中插入一些特殊的字符或图标，例如箭头、加减号等。
- 使用 CSS 实现一些特殊的装饰效果，例如分割线、标签等。
- 在响应式布局中使用，可以使用 `::before` 或 `::after` 创建一个空的块级元素，然后通过设置宽度、高度、padding 等样式属性来实现自适应的布局效果。

> 需要注意的是，`::before`和`::after`只是虚拟的元素，并不存在于文档中，因此它们不能用于添加交互事件或 JavaScript 操作。

## 对HTML5和CSS3新特性的理解。你在实际项目中如何运用这些新特性？

HTML5新出了许多语义化标签（nav，header，main等）和API（canvas,webGL），语义化标签优点在于提高代码可读性和可维护性，有利于搜索引擎更容易读懂（seo），有些特殊的屏幕阅读器可以通过分析语义化标签进行展示（比如盲人阅读器）。

CSS3新出了圆角，阴影，过渡，动画，弹性布局等使创造复杂样式和交互变得更简单，也使我们可以更快的去完成页面样式。

## 如何关闭iOS键盘首字母自动大写

在 iOS 设备上关闭键盘首字母自动大写有两种方式：

通过在相应的 `input` 元素上添加 `autocapitalize` 属性并将其设置为 `none`：

```css
<input type="text" autocapitalize="none">
```

通过在相应的 `input` 元素上添加 `autocorrect` 属性并将其设置为 `off`：

```css
<input type="text" autocorrect="off">
```

这两种方式都可以关闭 iOS 键盘首字母自动大写的功能。

## 怎么让Chrome支持小于12px的文字？

在Chrome中，默认情况下，文字的最小大小为12px，如果你想要设置小于12px的文字，可以使用以下两种方法：

1、使用`-webkit-text-size-adjust`属性：这个属性可以用来控制Chrome浏览器中文字的最小大小。将其设置为`none`可以关闭自动调整文字大小的功能。例如：

```css
body {
  -webkit-text-size-adjust: none;
}
```

2、使用`transform`属性：在Chrome浏览器中，可以使用`transform`属性对文字进行缩放，从而实现小于12px的文字大小。例如：

```css
body {
  transform: scale(0.8);
}
```

这个例子将页面中的所有元素缩小了20%。需要注意的是，这种方法可能会影响页面中其他元素的布局和位置。因此，建议仅在必要时使用此方法。

## rem和em区别

rem和em是两种不同的CSS长度单位。

**em是相对于其父元素字体大小（front-size）的单位。如果没有设置父元素的字体大小，则默认继承父元素的字体大小。**

例如，如果一个元素的字体大小为16px，一个使用1em单位的子元素将具有16px的字体大小，而一个使用0.5em单位的子元素将具有8px的字体大小。

**rem是相对于根元素（即html元素）字体大小的单位。**

例如，如果根元素的字体大小为16px，则一个使用1rem单位的元素将具有16px的字体大小，而一个使用0.5rem单位的元素将具有8px的字体大小。

由于em是相对于父元素字体大小的单位，所以在多层嵌套时会产生累计效应，而rem相对于根元素的字体大小，不会受到父元素字体大小的影响，因此在多层嵌套时更容易控制。

总的来说，使用rem单位可以更方便地实现响应式设计，而使用em单位则更适合在具有固定字体大小的情况下进行相对大小的调整。

## 相对单位vw/wh

vw：相对于视口宽度的单位，即视口宽度的1%。例如，如果你设置一个元素的宽度为50vw，那么它的宽度就是视口宽度的50%。

wh：相对于视口高度的单位，即视口高度的1%。例如，如果你设置一个元素的高度为50wh，那么它的高度就是视口高度的50%。

## ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉

iOS系统中元素被触摸时产生的半透明灰色遮罩是由浏览器自带的默认样式所导致的，可以通过CSS属性 `-webkit-tap-highlight-color` 来去掉。

要去掉灰色遮罩，可以将其设置为透明：

```css
/* 去掉 iOS 点击高亮效果 */
-webkit-tap-highlight-color: transparent;
```

注意：该属性只对 Safari 和 Chrome 浏览器有效。在其他浏览器中可能需要使用其他属性或方法去掉默认的点击效果。

## webkit表单输入框placeholder的颜色值能改变吗？

可以通过设置CSS样式来改变WebKit浏览器中表单输入框placeholder的颜色值。使用下面的代码可以更改placeholder文本的颜色：

```css
::-webkit-input-placeholder {
  color: #999;
}
```

其中，`::`或`:`都可以用来表示伪元素，因为Webkit内核的不同版本对`::`和`:`支持不同，所以两者都需要考虑。`-webkit-input-placeholder`是WebKit内核的私有属性，可以通过该属性来改变placeholder文本的颜色。

## CSS3新增了哪些新特性

1、新的选择器：

CSS3引入了很多新的选择器，例如属性选择器、伪类选择器、伪元素选择器、通用选择器等，这使得选择元素变得更加灵活和简单。

2、盒模型：

CSS3引入了新的盒模型，它允许开发人员更准确地控制盒子的尺寸和定位，特别是在处理边框和内边距时。

3、多列布局：

CSS3允许创建多列布局，这使得开发人员可以更容易地创建分栏布局，而无需使用复杂的HTML和CSS技术。

4、圆角和阴影效果：

CSS3引入了圆角和阴影效果，这使得开发人员可以更容易地创建圆角和阴影效果，而无需使用图片或JavaScript。

5、渐变和背景图片：

CSS3允许使用渐变和背景图片来装饰网页元素，这使得网页设计更加灵活和多样化。

6、动画和过渡效果：

CSS3引入了动画和过渡效果，这使得开发人员可以更容易地创建动态和交互性效果，而无需使用JavaScript或Flash。

7、媒体查询：

CSS3允许使用媒体查询来检测设备的属性和特征，例如屏幕大小、分辨率、方向等，这使得网页可以适应不同的设备和浏览器。

8、字体：

CSS3引入了新的字体属性和单位，例如@font-face、rem等，这使得网页字体的使用更加方便和灵活。

## 响应式和自适应

响应式设计和自适应设计是两个相关但又不完全相同的概念。

响应式设计指的是网站或应用程序能够根据不同的屏幕尺寸和设备类型（如台式机、笔记本电脑、平板电脑、智能手机等）自动适应不同的布局、分辨率和显示效果，以提供更好的用户体验。响应式设计通常使用CSS媒体查询和弹性网格布局等技术来实现。

自适应设计则强调的是网站或应用程序能够根据用户的设备和环境条件（如屏幕尺寸、带宽、操作系统、浏览器等）自动调整和优化显示效果和交互方式，以提供更好的性能和可用性。自适应设计包括了响应式设计，但不仅限于此，还涉及到诸如设备检测、内容分发、图片压缩、前端缓存等技术。

综合来看，响应式设计和自适应设计都是为了提高网站或应用程序在多种设备和环境下的体验和效果。

## 如何处理浏览器兼容性问题的？

处理浏览器兼容性问题是 Web 开发中常见的任务，以下是一些常见的处理方式：

1. 使用 polyfill：polyfill 是一种 JavaScript 库，它可以在不支持某些新特性的浏览器中模拟这些特性。可以使用一些成熟的 polyfill 库，如 babel-polyfill 和 es6-shim 等，来解决兼容性问题。
2. 特性检测：在代码中检测浏览器是否支持某个特定的 API 或功能，并在不支持的情况下提供备用方案。可以使用一些成熟的库，如 Modernizr 和 caniuse 等，来进行特性检测。
3. 浏览器嗅探：检测浏览器类型和版本，并根据检测结果提供相应的解决方案。但是，浏览器嗅探的方式可能不准确，并且可能受到用户代理字符串被篡改的影响。
4. 使用 CSS Hack：一些特定的 CSS 属性和值只在某些浏览器中生效，我们可以使用 CSS Hack 来对不同浏览器提供不同的样式。
5. 优雅降级：在不支持某些新特性的浏览器中，提供类似但降级的功能。例如，在不支持 CSS3 的浏览器中，可以使用 CSS2 提供的类似的效果。
6. 最小化依赖：尽量减少代码依赖的库和框架，以减少出现兼容性问题的可能性。
7. 使用自适应布局：使用自适应布局可以在不同设备上提供一致的用户体验，减少兼容性问题的出现。

总之，处理浏览器兼容性问题需要综合考虑多种因素，包括技术栈、团队开发水平、用户群体、需求等等。在实践中，我们需要根据具体情况选择合适的方案。

## CSS Hack

CSS Hack 是一种在不同浏览器中使用不同 CSS 代码的方法，以解决浏览器兼容性问题。由于不同浏览器对 CSS 规范的实现方式存在差异，因此在实际开发中可能需要使用不同的 CSS 代码来适配不同的浏览器。

以下是一些常见的 CSS Hack：

1. IE Hack：使用 IE 的特定 CSS 属性和值来针对 Internet Explorer 浏览器进行样式调整。

```css
/* 仅在 IE6 中生效 */
* html {
  font-size: 100%;
}
```

2. 属性前缀 Hack：使用不同浏览器的特定 CSS 属性前缀来针对不同浏览器进行样式调整。

```css
cssCopy code/* 针对 Webkit 内核浏览器设置边框圆角 */
-webkit-border-radius: 5px;
/* 针对 Firefox 浏览器设置边框圆角 */
-moz-border-radius: 5px;
/* 针对 Opera 浏览器设置边框圆角 */
border-radius: 5px;
```

3. 选择器 Hack：使用不同浏览器的 CSS 选择器来针对不同浏览器进行样式调整。

```css
cssCopy code/* 针对 IE6 浏览器的选择器 Hack */
* html body {
  font-size: 100%;
}
/* 针对 IE7 浏览器的选择器 Hack */
* + html body {
  font-size: 100%;
}
```


但需要注意的是，使用 CSS Hack 也可能存在一些问题，例如代码冗余、不可维护、兼容性不完全等，因此应尽量避免滥用 CSS Hack，并考虑使用其他更为合适的解决方案。

## 如何实现响应式布局？如何处理移动端和桌面端之间的差异？

实现响应式布局可以使用一些CSS技术，如媒体查询、flexbox和grid布局等。以下是一些实现响应式布局的方法：

1. 使用媒体查询：通过设置不同的CSS样式来适应不同的设备屏幕大小和分辨率。
2. 使用相对单位：使用相对单位（如em和rem）代替固定单位（如px）来实现页面元素的缩放。
3. 使用flexbox布局：使用CSS3的flexbox布局可以轻松地实现自适应布局。
4. 使用grid布局：使用CSS3的grid布局可以实现更复杂的响应式布局。

在处理移动端和桌面端之间的差异时，可以使用以下方法：

5. 使用媒体查询：使用不同的媒体查询来适应不同的屏幕大小和分辨率，从而实现移动端和桌面端之间的差异。
6. 使用响应式框架：使用响应式框架（如Bootstrap和Foundation）来简化响应式布局的开发，它们会自动适应不同的设备和屏幕大小。
7. 使用设备像素比（DPR）：移动设备通常具有更高的设备像素比，因此可以使用DPR来适应不同的设备。

总之，在设计和实现响应式布局时，需要考虑到不同设备之间的差异，通过灵活使用CSS技术和工具，可以轻松地实现适应不同设备的响应式布局。

## 请谈谈你对响应式设计（Responsive Design）的理解以及如何在项目中实现响应式设计

响应式设计是一种基于网页设计和开发的理念，旨在使网站能够在不同设备上展示出最佳的用户体验。这种设计方法的核心思想是让网站能够自适应不同的屏幕尺寸、分辨率和设备类型，以便在各种设备上都能提供一致的访问体验。

在项目中实现响应式设计，通常需要考虑以下几个方面：

1. 流式布局：使用相对单位（如百分比、em 等）来定义元素的大小和位置，从而确保网站在不同的屏幕尺寸下能够自适应。
2. 媒体查询：使用 CSS 的媒体查询功能，根据屏幕宽度等属性来选择不同的样式，以适应不同的屏幕大小。
3. 图片优化：使用适当的图片大小和格式，以确保在不同设备上加载速度快，同时又不失去图片质量。
4. 栅格系统：使用栅格系统可以将页面布局分为多个列和行，从而让页面在不同屏幕尺寸下能够自适应。
5. 视口设置：使用视口元标签来设置网页的视口大小和缩放级别，以确保在移动设备上呈现的效果良好。

总的来说，实现响应式设计需要一个整体的思考和计划，需要考虑到不同的设备和屏幕尺寸，以及用户的行为和需求。只有在充分理解用户和设计要求的情况下，才能够开发出一个完美的响应式设计。